{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"arcpie","text":"<p>A simple interface for working with arcpy Featureclasses</p>"},{"location":"#the-old","title":"The Old","text":"<pre><code>import arcpy\n\nfc1 = r'C:\\Data\\db.gdb\\FC1'\nfc2 = r'C:\\Data\\db.gdb\\FC2'\nl1 = arcpy.management.MakeFeatureLayer(fc1, 'memory/fc1', 'size &gt; 10')\nl2 = arcpy.management.MakeFeatureLayer(fc2, 'memory/fc2')\narcpy.management.SelectLayerByLocation(l2, fc1)\nprint(arcpy.management.getCount(l2)[0])\n</code></pre>"},{"location":"#the-new","title":"The New","text":"<pre><code>from arcpie import FeatureClass, count\n\nfc1 = FeatureClass[Polyline](r'C:\\Data\\db.gdb\\FC1')\nfc2 = FeatureClass[PointGeometry](r'C:\\Data\\db.gdb\\FC2')\n\nwith fc1.where('length &gt; 10'):\n    print(count(fc2[fc1.footprint()])\n\ndef under(dist: int) -&gt; Callable:\n    def _inner(row: dict[str, Any]) -&gt; bool:\n        return row['SHAPE@'].length &lt; dist\n    return _inner\n\nfor row in fc1[under(10)]:\n    print(row)\n\nfor oid, shape in fc1[('OID@', 'SHAPE@')]:\n    print(f'{fc1.name} {oid} is {shape.length} {fc1.unit_name} long'\n\nref = SpatialReference(4326)\nwith fc1.projection_as(ref):\n    for oid, shape in fc1[('OID@', 'SHAPE@')]:\n        print(f'{fc1.name} {oid} is {shape.length} {ref.linearUnitName} long' \n</code></pre>"},{"location":"cursor/","title":"cursor","text":"<p>Cursor Helper module</p>"},{"location":"cursor/#arcpie.cursor.Field","title":"<code>Field</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Field Representation</p> <p>Parameters:</p> Name Type Description Default <code>field_type</code> <code>FieldType</code> <p>The type of the field (required)</p> required <code>field_precision</code> <code>int</code> <p>The precision (digits) of numeric fields (default: database determined)</p> required <code>field_scale</code> <code>int</code> <p>The number of decimal places for floating point fields (default: database determined)</p> required <code>field_length</code> <code>int</code> <p>The maximum character count for <code>TEXT</code> fields (default: 255)</p> required <code>field_alias</code> <code>str</code> <p>Human readable alias for fields with confusing internal names (optional)</p> required <code>field_is_nullable</code> <code>bool</code> <p>Allow null values (default: <code>True</code>)</p> required <code>field_is_required</code> <code>bool</code> <p>Field requires a value to be set (default: False)</p> required <code>field_domain</code> <code>str</code> <p>Existing Domain name to bind to field (optional)</p> required Source code in <code>src/arcpie/cursor.py</code> <pre><code>class Field(TypedDict, total=False):\n    \"\"\"Field Representation\n\n    Args:\n        field_type (FieldType): The type of the field (required)\n        field_precision (int): The precision (digits) of numeric fields (default: database determined)\n        field_scale (int): The number of decimal places for floating point fields (default: database determined)\n        field_length (int): The maximum character count for `TEXT` fields (default: 255)\n        field_alias (str): Human readable alias for fields with confusing internal names (optional)\n        field_is_nullable (bool): Allow null values (default: `True`)\n        field_is_required (bool): Field requires a value to be set (default: False)\n        field_domain (str): Existing Domain name to bind to field (optional)\n    \"\"\"\n    field_type: FieldType\n    field_precision: int\n    field_scale: int\n    field_length: int\n    field_alias: str\n    field_is_nullable: Literal['NULLABLE', 'NON_NULLABLE']\n    field_is_required: Literal['REQUIRED']\n    field_domain: bool\n</code></pre>"},{"location":"cursor/#arcpie.cursor.InsertOptions","title":"<code>InsertOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Optional parameters for InsertCursors</p> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class InsertOptions(TypedDict, total=False):\n    \"\"\"Optional parameters for InsertCursors\"\"\"\n    datum_transformation: str\n    explicit: bool\n</code></pre>"},{"location":"cursor/#arcpie.cursor.SQLClause","title":"<code>SQLClause</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Wrapper for Cursor sql_clause attribute,</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>The SQL prefix to be prepended to the <code>FROM</code> part of the statment</p> required <code>postfix</code> <code>str</code> <p>The SQL postfix that will be appended to the <code>WHERE</code> clause</p> required Format <pre><code>SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}\n</code></pre> Usage <pre><code>&gt;&gt;&gt; five_longest = SQLClause(prefix='TOP 5', postfix='ORDER BY LENGTH DESC')\n&gt;&gt;&gt; fc_result = feature_class.get_tuples(('NAME', 'LENGTH'), sql_clause=five_longest))\n&gt;&gt;&gt; print(list(fc_result))\n[('foo', 1001), ('bar', 999), ('baz', 567), ('buzz', 345), ('bang', 233)]\n</code></pre> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class SQLClause(NamedTuple):\n    \"\"\"Wrapper for Cursor sql_clause attribute,\n\n    Arguments:\n        prefix (str): The SQL prefix to be prepended to the `FROM` part of the statment\n        postfix (str): The SQL postfix that will be appended to the `WHERE` clause\n\n    Format:\n        ```sql\n        SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}\n        ```\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; five_longest = SQLClause(prefix='TOP 5', postfix='ORDER BY LENGTH DESC')\n        &gt;&gt;&gt; fc_result = feature_class.get_tuples(('NAME', 'LENGTH'), sql_clause=five_longest))\n        &gt;&gt;&gt; print(list(fc_result))\n        [('foo', 1001), ('bar', 999), ('baz', 567), ('buzz', 345), ('bang', 233)]\n        ```\n    \"\"\"\n    prefix: str|None\n    postfix: str|None\n</code></pre>"},{"location":"cursor/#arcpie.cursor.SearchOptions","title":"<code>SearchOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Optional parameters for SearchCursors</p> <p>Parameters:</p> Name Type Description Default <code>where_clause</code> <code>str</code> <p>A SQL query that is inserted after the SQL <code>WHERE</code> (<code>SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}...</code>)</p> required <code>spatial_reference</code> <code>str | int | SpatialReference</code> <p>Perform an on the fly projection of the yielded geometry to this reference</p> required <code>explode_to_points</code> <code>bool</code> <p>Return a row per vertex in each feature (e.g. <code>[SHAPE, 'eric', 'idle'] -&gt; [Point, 'eric', 'idle'], [Point, 'eric', 'idle'], ...</code>)</p> required <code>sql_clause</code> <code>SQLClause</code> <p>A tuple of SQL queries that is inserted after the SQL  <code>SELECT</code> and <code>WHERE</code> clauses (<code>SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}...</code>)</p> required <code>datum_transformation</code> <code>str</code> <p>The transformation to use during projection if there is a datum difference between the feature projection and the  target SpatialReference (you can use <code>arcpy.ListTransformations</code> to find valid transformations)</p> required <code>spatial_filter</code> <code>Geometry</code> <p>A shape that will be used to test each feature against using the specified <code>spatial_relationship</code> (<code>'INTERSECTS'</code>) by default.</p> required <code>spatial_relationship</code> <code>SpatialRelationship</code> <p>The type of relationship with the <code>spatial_filter</code> to test for in each row. Only rows with shapes that match this relationship will be yielded.</p> required <code>search_order</code> <code>SearchOrder</code> <p>Run the <code>where_clause {sql_clause}</code> (<code>'ATTRIBUTEFIRST'</code> default) or <code>spatial_filter</code> (<code>'SPATIALFIRST'</code>) first. This can be used to optimize a cursor. If you have a complex <code>where_clause</code>, consider switching to <code>'SPATIALFIRST'</code> to cut down on the number of records that the <code>where_clause</code> runs for. These two operations are done as seperate SQL operations and <code>JOINED</code> in the result</p> required <p>Returns:</p> Type Description <code> dict </code> <p>A dictionary with the populated keys</p> Usage <pre><code>&gt;&gt;&gt; options = SearchOptions(where_clause='OBJECTID &gt; 10')\n&gt;&gt;&gt; not_first_ten = feature_class.get_tuples(['NAME', 'LENGTH'], **options)\n&gt;&gt;&gt; print(list(not_first_ten))\n[('cleese', 777), ('idle', 222), ('gilliam', 111), ...]\n</code></pre> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class SearchOptions(TypedDict, total=False):\n    \"\"\"Optional parameters for SearchCursors\n\n    Arguments:\n        where_clause (str): A SQL query that is inserted after the SQL `WHERE` (`SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}...`)\n        spatial_reference (str | int | SpatialReference): Perform an on the fly projection of the yielded geometry to this reference\n        explode_to_points (bool): Return a row per vertex in each feature (e.g. `[SHAPE, 'eric', 'idle'] -&gt; [Point, 'eric', 'idle'], [Point, 'eric', 'idle'], ...`)\n        sql_clause (SQLClause): A tuple of SQL queries that is inserted after the SQL \n            `SELECT` and `WHERE` clauses (`SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}...`)\n        datum_transformation (str): The transformation to use during projection if there is a datum difference between the feature projection and the \n            target SpatialReference (you can use `arcpy.ListTransformations` to find valid transformations)\n        spatial_filter (Geometry): A shape that will be used to test each feature against using the specified `spatial_relationship` (`'INTERSECTS'`)\n            by default.\n        spatial_relationship (SpatialRelationship): The type of relationship with the `spatial_filter` to test for in each row. Only rows with shapes\n            that match this relationship will be yielded.\n        search_order (SearchOrder): Run the `where_clause {sql_clause}` (`'ATTRIBUTEFIRST'` default) or `spatial_filter` (`'SPATIALFIRST'`) first.\n            This can be used to optimize a cursor. If you have a complex `where_clause`, consider switching to `'SPATIALFIRST'` to cut down on the number\n            of records that the `where_clause` runs for. These two operations are done as seperate SQL operations and `JOINED` in the result\n\n    Returns:\n        ( dict ): A dictionary with the populated keys\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; options = SearchOptions(where_clause='OBJECTID &gt; 10')\n        &gt;&gt;&gt; not_first_ten = feature_class.get_tuples(['NAME', 'LENGTH'], **options)\n        &gt;&gt;&gt; print(list(not_first_ten))\n        [('cleese', 777), ('idle', 222), ('gilliam', 111), ...]\n        ```\n    \"\"\"\n    where_clause: str\n    spatial_reference: str | int | SpatialReference\n    explode_to_points: bool\n    sql_clause: SQLClause\n    datum_transformation: str\n    spatial_filter: GeometryType | Extent\n    spatial_relationship: SpatialRelationship\n    search_order: SearchOrder\n</code></pre>"},{"location":"cursor/#arcpie.cursor.UpdateOptions","title":"<code>UpdateOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Optional parameters for UpdateCursors</p> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class UpdateOptions(TypedDict, total=False):\n    \"\"\"Optional parameters for UpdateCursors\"\"\"\n    where_clause: str\n    spatial_reference: str | int | SpatialReference\n    explode_to_points: bool\n    sql_clause: SQLClause\n    #skip_nulls: bool\n    #null_value: dict[str, Any]\n    datum_transformation: str\n    explicit: bool\n    spatial_filter: GeometryType | Extent\n    spatial_relationship: SpatialRelationship\n    search_order: SearchOrder\n</code></pre>"},{"location":"cursor/#arcpie.cursor.WhereClause","title":"<code>WhereClause</code>","text":"Source code in <code>src/arcpie/cursor.py</code> <pre><code>class WhereClause:\n    def __init__(self, where_clause: str, skip_validation: bool=False) -&gt; None:\n        \"\"\"Object for storing and validating where clauses\n\n        Args:\n            where_clause (str): The where clause that you want to pass to a FeatureClass\n            skip_validation (bool): Skip the validation step (default: False)\n        \"\"\"\n        if '@' in where_clause:\n            raise AttributeError(\n                '`@` Parameters/Tokens not supported in WhereClauses, Please use full fieldname'\n            )\n        self.where_clause = where_clause\n        self.fields = self.get_fields(where_clause)\n        self.skip_validation = skip_validation\n\n    def __repr__(self) -&gt; str:\n        return self.where_clause\n\n    def get_fields(self, clause: str) -&gt; Sequence[str]:\n        \"\"\"Sanitize a where clause by removing whitespace\"\"\"\n\n        #    -0-     1    2      3      -4-      5    6\n        # '&lt;FIELD&gt; &lt;OP&gt; &lt;VAL&gt; &lt;AND/OR&gt; &lt;FIELD&gt; &lt;OP&gt; &lt;VAL&gt; ...'\n        # A properly structured WhereClause should have a field\n        # as every 4th token split on spaces\n\n        # CAVEAT: Parens and whitespace\n        # This comprehension drops individual parens, replaces ', ' with ','\n        # and finds all field components\n\n        # TODO: This needs thorough testing\n        return [\n            fld.strip().replace('(', '').replace(')', '')\n            for fld in [\n                tok for tok in\n                clause.replace(', ', ',').split()\n                if tok not in '()'\n            ][::4]\n        ]\n\n    def validate(self, fields: Sequence[str]) -&gt; bool:\n        \"\"\"Check to see if the clause fields are in the fields list\n\n        Args:\n            fields (Sequence[str]): The fields to check against\n        \"\"\"\n        return self.skip_validation or set(self.fields) &lt;= set(fields)\n</code></pre>"},{"location":"cursor/#arcpie.cursor.WhereClause.__init__","title":"<code>__init__(where_clause, skip_validation=False)</code>","text":"<p>Object for storing and validating where clauses</p> <p>Parameters:</p> Name Type Description Default <code>where_clause</code> <code>str</code> <p>The where clause that you want to pass to a FeatureClass</p> required <code>skip_validation</code> <code>bool</code> <p>Skip the validation step (default: False)</p> <code>False</code> Source code in <code>src/arcpie/cursor.py</code> <pre><code>def __init__(self, where_clause: str, skip_validation: bool=False) -&gt; None:\n    \"\"\"Object for storing and validating where clauses\n\n    Args:\n        where_clause (str): The where clause that you want to pass to a FeatureClass\n        skip_validation (bool): Skip the validation step (default: False)\n    \"\"\"\n    if '@' in where_clause:\n        raise AttributeError(\n            '`@` Parameters/Tokens not supported in WhereClauses, Please use full fieldname'\n        )\n    self.where_clause = where_clause\n    self.fields = self.get_fields(where_clause)\n    self.skip_validation = skip_validation\n</code></pre>"},{"location":"cursor/#arcpie.cursor.WhereClause.get_fields","title":"<code>get_fields(clause)</code>","text":"<p>Sanitize a where clause by removing whitespace</p> Source code in <code>src/arcpie/cursor.py</code> <pre><code>def get_fields(self, clause: str) -&gt; Sequence[str]:\n    \"\"\"Sanitize a where clause by removing whitespace\"\"\"\n\n    #    -0-     1    2      3      -4-      5    6\n    # '&lt;FIELD&gt; &lt;OP&gt; &lt;VAL&gt; &lt;AND/OR&gt; &lt;FIELD&gt; &lt;OP&gt; &lt;VAL&gt; ...'\n    # A properly structured WhereClause should have a field\n    # as every 4th token split on spaces\n\n    # CAVEAT: Parens and whitespace\n    # This comprehension drops individual parens, replaces ', ' with ','\n    # and finds all field components\n\n    # TODO: This needs thorough testing\n    return [\n        fld.strip().replace('(', '').replace(')', '')\n        for fld in [\n            tok for tok in\n            clause.replace(', ', ',').split()\n            if tok not in '()'\n        ][::4]\n    ]\n</code></pre>"},{"location":"cursor/#arcpie.cursor.WhereClause.validate","title":"<code>validate(fields)</code>","text":"<p>Check to see if the clause fields are in the fields list</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Sequence[str]</code> <p>The fields to check against</p> required Source code in <code>src/arcpie/cursor.py</code> <pre><code>def validate(self, fields: Sequence[str]) -&gt; bool:\n    \"\"\"Check to see if the clause fields are in the fields list\n\n    Args:\n        fields (Sequence[str]): The fields to check against\n    \"\"\"\n    return self.skip_validation or set(self.fields) &lt;= set(fields)\n</code></pre>"},{"location":"database/","title":"database","text":""},{"location":"database/#arcpie.database.Dataset","title":"<code>Dataset</code>","text":"<p>A Container for managing workspace connections.</p> <p>A Dataset is initialized using <code>arcpy.da.Walk</code> and will discover all child datasets, tables, and featureclasses. These discovered objects can be accessed by name directly (e.g. <code>dataset['featureclass_name']</code>) or by inspecting the property of the type they belong to (e.g. dataset.feature_classes['featureclass_name']). The benefit of the second  method is that you will be able to know you are getting a <code>FeatureClass</code>, <code>Table</code>, or <code>Dataset</code> object.</p> Usage <pre><code>&gt;&gt;&gt; dataset = Dataset('dataset/path')\n&gt;&gt;&gt; fc1 = dataset.feature_classes['fc1']\n&gt;&gt;&gt; fc1 = dataset.feature_classes['fc2']\n&gt;&gt;&gt; len(fc1)\n243\n&gt;&gt;&gt; len(fc2)\n778\n\n&gt;&gt;&gt; count(dataset['fc1'][where('LENGTH &gt; 500')])\n42\n&gt;&gt;&gt; sum(dataset['fc2']['TOTAL'])\n3204903\n</code></pre> <p>As you can see, the dataset container makes it incredibly easy to interact with data concisely and clearly. </p> <p>Datasets also implement <code>__contains__</code> which allows you to check membership from the root node:</p> Example <pre><code>&gt;&gt;&gt; 'fc1' in dataset\nTrue\n&gt;&gt;&gt; 'fc6' in dataset\nTrue\n&gt;&gt;&gt; list(dataset.feature_classes)\n['fc1', 'fc2']\n&gt;&gt;&gt; list(dataset.datasets)\n['ds1']\n&gt;&gt;&gt; list(dataset['ds1'].feature_classes)\n['fc3', 'fc4', 'fc5', 'fc6']\n</code></pre> Source code in <code>src/arcpie/database.py</code> <pre><code>class Dataset:\n    \"\"\"A Container for managing workspace connections.\n\n    A Dataset is initialized using `arcpy.da.Walk` and will discover all child datasets, tables, and featureclasses.\n    These discovered objects can be accessed by name directly (e.g. `dataset['featureclass_name']`) or by inspecting the\n    property of the type they belong to (e.g. dataset.feature_classes['featureclass_name']). The benefit of the second \n    method is that you will be able to know you are getting a `FeatureClass`, `Table`, or `Dataset` object.\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; dataset = Dataset('dataset/path')\n        &gt;&gt;&gt; fc1 = dataset.feature_classes['fc1']\n        &gt;&gt;&gt; fc1 = dataset.feature_classes['fc2']\n        &gt;&gt;&gt; len(fc1)\n        243\n        &gt;&gt;&gt; len(fc2)\n        778\n\n        &gt;&gt;&gt; count(dataset['fc1'][where('LENGTH &gt; 500')])\n        42\n        &gt;&gt;&gt; sum(dataset['fc2']['TOTAL'])\n        3204903\n        ```\n    As you can see, the dataset container makes it incredibly easy to interact with data concisely and clearly. \n\n    Datasets also implement `__contains__` which allows you to check membership from the root node:\n\n    Example:\n        ```python\n        &gt;&gt;&gt; 'fc1' in dataset\n        True\n        &gt;&gt;&gt; 'fc6' in dataset\n        True\n        &gt;&gt;&gt; list(dataset.feature_classes)\n        ['fc1', 'fc2']\n        &gt;&gt;&gt; list(dataset.datasets)\n        ['ds1']\n        &gt;&gt;&gt; list(dataset['ds1'].feature_classes)\n        ['fc3', 'fc4', 'fc5', 'fc6']\n        ```\n    \"\"\"\n    def __init__(self, conn: str|Path, *, parent: Dataset|None=None) -&gt; None:\n        self.conn = Path(conn)\n        self.parent = parent\n        self._datasets: dict[str, Dataset] | None = None\n        self._feature_classes: dict[str, FeatureClass[GeometryType]] | None=None\n        self._tables: dict[str, Table] | None=None\n        self.walk()\n\n    @property\n    def datasets(self) -&gt; dict[str, Dataset]:\n        \"\"\"A mapping of dataset names to child `Dataset` objects\"\"\"\n        return self._datasets or {}\n\n    @property\n    def feature_classes(self) -&gt; dict[str, FeatureClass[GeometryType]]:\n        \"\"\"A mapping of featureclass names to `FeatureClass` objects in the dataset root\"\"\"\n        return self._feature_classes or {}\n\n    @property\n    def tables(self) -&gt; dict[str, Table]:\n        \"\"\"A mapping of table names to `Table` objects in the dataset root\"\"\"\n        return self._tables or {}\n\n    def walk(self) -&gt; None:\n        \"\"\"Traverse the connection/path using `arcpy.da.Walk` and discover all dataset children\n\n        Note:\n            This is called on dataset initialization and can take some time. Larger datasets can take up to\n            a second or more to initialize.\n\n        Note:\n            If the contents of a dataset change during its lifetime, you may need to call walk again. All \n            children that are already initialized will be skipped and only new children will be initialized\n        \"\"\"\n        self._feature_classes = {}\n        for root, _, fcs in Walk(str(self.conn), datatype=['FeatureClass']):\n            root = Path(root)\n            for fc in fcs:\n                # Backlink Datasets to parent\n                if self.parent is not None and fc in self.parent:\n                    self._feature_classes[fc] = self.parent.feature_classes[fc]\n                else:\n                    self._feature_classes[fc] = FeatureClass(root / fc)\n\n        self._tables = {}\n        for root, _, tbls in Walk(str(self.conn), datatype=['Table']):\n            root = Path(root)\n            self._tables.update({tbl: Table(root / tbl) for tbl in tbls if tbl not in self})\n            for tbl in tbls:\n                # Backlink Datasets to parent (Should never hit since tables are in root only)\n                if self.parent and tbl in self.parent:\n                    self._tables[tbl] = self.parent.tables[tbl]\n                else:\n                    self._tables[tbl] = Table(root / tbl)\n\n        # Handle datasets last to allow for backlinking     \n        self._datasets = {}\n        for root, ds, _ in Walk(str(self.conn), datatype=['FeatureDataset']):\n            root = Path(root)\n            self._datasets.update({d: Dataset(root / d, parent=self) for d in ds})\n\n    def __getitem__(self, key: str) -&gt; FeatureClass[GeometryType] | Table | Dataset:\n        ret = self.tables.get(key) or self.feature_classes.get(key) or self.datasets.get(key)\n        if not ret:\n            raise KeyError(f'{key} is not a child of {self.conn.stem}')\n        return ret\n\n    def __contains__(self, key: str) -&gt; bool:\n        try:\n            self[key]\n            return True\n        except KeyError:\n            return False\n\n    def __iter__(self) -&gt; Iterator[Table]:\n        for feature_class in self.feature_classes.values():\n            yield feature_class\n\n        for table in self.tables.values():\n            yield table\n</code></pre>"},{"location":"database/#arcpie.database.Dataset.datasets","title":"<code>datasets</code>  <code>property</code>","text":"<p>A mapping of dataset names to child <code>Dataset</code> objects</p>"},{"location":"database/#arcpie.database.Dataset.feature_classes","title":"<code>feature_classes</code>  <code>property</code>","text":"<p>A mapping of featureclass names to <code>FeatureClass</code> objects in the dataset root</p>"},{"location":"database/#arcpie.database.Dataset.tables","title":"<code>tables</code>  <code>property</code>","text":"<p>A mapping of table names to <code>Table</code> objects in the dataset root</p>"},{"location":"database/#arcpie.database.Dataset.walk","title":"<code>walk()</code>","text":"<p>Traverse the connection/path using <code>arcpy.da.Walk</code> and discover all dataset children</p> Note <p>This is called on dataset initialization and can take some time. Larger datasets can take up to a second or more to initialize.</p> Note <p>If the contents of a dataset change during its lifetime, you may need to call walk again. All  children that are already initialized will be skipped and only new children will be initialized</p> Source code in <code>src/arcpie/database.py</code> <pre><code>def walk(self) -&gt; None:\n    \"\"\"Traverse the connection/path using `arcpy.da.Walk` and discover all dataset children\n\n    Note:\n        This is called on dataset initialization and can take some time. Larger datasets can take up to\n        a second or more to initialize.\n\n    Note:\n        If the contents of a dataset change during its lifetime, you may need to call walk again. All \n        children that are already initialized will be skipped and only new children will be initialized\n    \"\"\"\n    self._feature_classes = {}\n    for root, _, fcs in Walk(str(self.conn), datatype=['FeatureClass']):\n        root = Path(root)\n        for fc in fcs:\n            # Backlink Datasets to parent\n            if self.parent is not None and fc in self.parent:\n                self._feature_classes[fc] = self.parent.feature_classes[fc]\n            else:\n                self._feature_classes[fc] = FeatureClass(root / fc)\n\n    self._tables = {}\n    for root, _, tbls in Walk(str(self.conn), datatype=['Table']):\n        root = Path(root)\n        self._tables.update({tbl: Table(root / tbl) for tbl in tbls if tbl not in self})\n        for tbl in tbls:\n            # Backlink Datasets to parent (Should never hit since tables are in root only)\n            if self.parent and tbl in self.parent:\n                self._tables[tbl] = self.parent.tables[tbl]\n            else:\n                self._tables[tbl] = Table(root / tbl)\n\n    # Handle datasets last to allow for backlinking     \n    self._datasets = {}\n    for root, ds, _ in Walk(str(self.conn), datatype=['FeatureDataset']):\n        root = Path(root)\n        self._datasets.update({d: Dataset(root / d, parent=self) for d in ds})\n</code></pre>"},{"location":"diff/","title":"diff","text":""},{"location":"diff/#arcpie.diff.feature_diff","title":"<code>feature_diff(source, target)</code>","text":"<p>Get features that are added/removed from source/target</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Dataset</code> <p>The starting point of the delta</p> required <code>target</code> <code>Dataset</code> <p>The ending point of the delta</p> required <p>Returns:</p> Type Description <code>Diff</code> <p>FeatureClass delta</p> Source code in <code>src/arcpie/diff.py</code> <pre><code>def feature_diff(source: Dataset, target: Dataset) -&gt; Diff:\n    \"\"\"Get features that are added/removed from source/target\n\n    Args:\n        source (Dataset): The starting point of the delta\n        target (Dataset): The ending point of the delta\n\n    Returns:\n        (Diff): FeatureClass delta\n    \"\"\"\n    _diff: Diff = {}\n    _diff['added'] = list(set(target.feature_classes) - set(source.feature_classes))\n    _diff['removed'] = list(set(source.feature_classes) - set(target.feature_classes))\n    return _diff if _diff['added'] or _diff['removed'] else {}\n</code></pre>"},{"location":"diff/#arcpie.diff.field_diff","title":"<code>field_diff(source, target)</code>","text":"<p>Get fields that are added/removed from source/target</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Dataset</code> <p>The starting point of the delta</p> required <code>target</code> <code>Dataset</code> <p>The ending point of the delta</p> required <p>Returns:</p> Type Description <code>dict[str, Diff]</code> <p>A Mapping of feature names to field deltas</p> Source code in <code>src/arcpie/diff.py</code> <pre><code>def field_diff(source: Dataset, target: Dataset) -&gt; dict[str, Diff]:\n    \"\"\"Get fields that are added/removed from source/target\n\n    Args:\n        source (Dataset): The starting point of the delta\n        target (Dataset): The ending point of the delta\n\n    Returns:\n        (dict[str, Diff]): A Mapping of feature names to field deltas\n    \"\"\"\n    _diffs: dict[str, Diff] = {}\n    for fc_name, source_fc in source.feature_classes.items():\n        if (target_fc := target.feature_classes.get(fc_name, None)) is not None:\n            _diffs.setdefault(fc_name, {})\n            _diffs[fc_name]['added'] = [f for f in target_fc.fields if f not in source_fc.fields]\n            _diffs[fc_name]['removed'] = [f for f in source_fc.fields if f not in target_fc.fields]\n    return {k:v for k, v in _diffs.items() if v['added'] or v['removed']}\n</code></pre>"},{"location":"diff/#arcpie.diff.layer_diff","title":"<code>layer_diff(source, target)</code>","text":"<p>Get layers that are added/removed from source/target</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Project</code> <p>The starting point of the delta</p> required <code>target</code> <code>Project</code> <p>The ending point of the delta</p> required <p>Returns:</p> Type Description <code>dict[str, Diff]</code> <p>A Mapping of map names to layer deltas</p> Source code in <code>src/arcpie/diff.py</code> <pre><code>def layer_diff(source: Project, target: Project) -&gt; dict[str, Diff]:\n    \"\"\"Get layers that are added/removed from source/target\n\n    Args:\n        source (Project): The starting point of the delta\n        target (Project): The ending point of the delta\n\n    Returns:\n        (dict[str, Diff]): A Mapping of map names to layer deltas\n    \"\"\"\n    _diffs: dict[str, Diff] = {}\n    for source_map in source.maps:\n        map_name = source_map.name\n        if (target_map := target.maps.get(source_map.name, None)) is not None:\n            _diffs.setdefault(map_name, {})\n            _diffs[map_name]['added'] = list(set(target_map.layers.names) - set(source_map.layers.names))\n            _diffs[map_name]['removed'] = list(set(source_map.layers.names) - set(target_map.layers.names))\n    return {k:v for k, v in _diffs.items() if v['added'] or v['removed']}\n</code></pre>"},{"location":"featureclass/","title":"featureclass","text":"<p>Sumbodule that helps wrap featureclass objects with useful methods</p> <p>options: show_submodules: true</p>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass","title":"<code>FeatureClass</code>","text":"<p>               Bases: <code>Table</code>, <code>Generic[_GeometryType]</code></p> <p>A Wrapper for ArcGIS FeatureClass objects</p> Example <pre><code>&gt;&gt;&gt; # Initialize FeatureClass with Geometry Type\n&gt;&gt;&gt; point_features = FeatureClass[PointGeometry]('&lt;feature_class_path&gt;')\n&gt;&gt;&gt; # Create a buffer Iterator\n&gt;&gt;&gt; buffers = (pt.buffer(10) for pt in point_features.shapes)\n... \n&gt;&gt;&gt; sr = SpatialReference(4206)\n&gt;&gt;&gt; # Set a new spatial reference\n&gt;&gt;&gt; with point_features.reference_as(sr):\n...     # Consume the Iterator, but with the new reference\n...     for buffer in buffers:\n...        area = buffer.area\n...        units = sr.linearUnitName\n...        print(f\"{area} Sq{units}\")\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>class FeatureClass(Table, Generic[_GeometryType]):\n    \"\"\"A Wrapper for ArcGIS FeatureClass objects\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # Initialize FeatureClass with Geometry Type\n        &gt;&gt;&gt; point_features = FeatureClass[PointGeometry]('&lt;feature_class_path&gt;')\n        &gt;&gt;&gt; # Create a buffer Iterator\n        &gt;&gt;&gt; buffers = (pt.buffer(10) for pt in point_features.shapes)\n        ... \n        &gt;&gt;&gt; sr = SpatialReference(4206)\n        &gt;&gt;&gt; # Set a new spatial reference\n        &gt;&gt;&gt; with point_features.reference_as(sr):\n        ...     # Consume the Iterator, but with the new reference\n        ...     for buffer in buffers:\n        ...        area = buffer.area\n        ...        units = sr.linearUnitName\n        ...        print(f\"{area} Sq{units}\")\n        ```\n    \"\"\"\n\n    Tokens = FeatureTokens\n\n    def __init__(\n            self, path: str|Path,\n            *,\n            search_options: SearchOptions|None=None, \n            update_options: UpdateOptions|None=None, \n            insert_options: InsertOptions|None=None,\n            clause: SQLClause|None=None,\n            where: str|None=None,\n            shape_token: ShapeToken='SHAPE@'\n        ) -&gt; None:\n        super().__init__(\n            path=path, \n            search_options=search_options, update_options=update_options, insert_options=insert_options, \n            clause=clause, where=where\n        )\n        self._shape_token: ShapeToken = shape_token\n\n    # rw Properties\n\n    @property\n    def shape_token(self) -&gt; ShapeToken:\n        \"\"\"Set the default `SHAPE@??` token for iteration. Use `SHAPE@` for full shape (default: `SHAPE@`)\"\"\"\n        return self._shape_token\n\n    @shape_token.setter\n    def shape_token(self, shape_token: ShapeToken) -&gt; None:\n        self._shape_token = shape_token\n\n    # ro Properties\n\n    @property\n    def describe(self) -&gt; dt.FeatureClass: # pyright: ignore[reportIncompatibleMethodOverride]\n        return Describe(self.path) # type: ignore\n\n    @property\n    def shape_field_name(self) -&gt; str:\n        return self.describe.shapeFieldName\n\n    @property\n    def fields(self) -&gt; tuple[FieldName | FeatureToken, ...]:\n        \"\"\"Tuple of all fieldnames in the FeatureClass with `OID@` and `SHAPE@` as first 2\"\"\"\n        if self._fields:\n            return self._fields\n        exclude = (self.oid_field_name, self.shape_field_name)\n        replace = ('OID@', self.shape_token)\n        _fields = ()\n        with self.search_cursor('*') as c:\n            _fields = c.fields\n        self._fields = replace + tuple((f for f in _fields if f not in exclude))\n        return self._fields\n\n    @property\n    def shapes(self) -&gt; Iterator[_GeometryType]:\n        yield from ( shape for shape, in self.search_cursor('SHAPE@'))\n\n    @property\n    def spatial_reference(self):\n        return self.describe.spatialReference\n\n    @property\n    def unit_name(self) -&gt; str:\n        return self.spatial_reference.linearUnitName\n\n    @property\n    def extent(self) -&gt; Extent:\n        \"\"\"Get the stored extent of the feature class\"\"\"\n        return self.describe.extent\n\n    @property\n    def py_types(self) -&gt; dict[str, type]:\n        \"\"\"Get a mapping of the field types for the FeatureClass\"\"\"\n        _types = convert_dtypes(self.np_dtypes)\n        if 'SHAPE@' in _types and len(self) &gt; 0:\n                _types['SHAPE@'] = type(next(self.shapes))\n        return _types\n    # Data Operations\n\n    def footprint(self, buffer: float|None=None) -&gt; _GeometryType | None:\n        \"\"\"Merge all geometry in the featureclass using current SelectionOptions into a single geometry object to use \n        as a spatial filter on other FeatureClasses\n\n        Args:\n            buffer (float | None): Optional buffer (in feature units, respects projection context) to buffer by (default: None)\n\n        Returns:\n            (GeometryType | None): A merged Multi-Geometry of all feature geometries or `None` if no features in FeatureClass\n        \"\"\"\n        if len(self) == 0:\n            return None\n\n        def merge(acc: _GeometryType, nxt: _GeometryType) -&gt; _GeometryType:\n            if buffer:\n                nxt = nxt.buffer(buffer)\n            return acc.union(nxt)\n\n        # Consume the shape generator popping off the first shape and applying the buffer, \n        # Then buffering each additional shape and merging it into the accumulator (starting with _first)\n        _shapes = self.shapes\n        _first = next(_shapes)\n        if buffer:\n            _first = _first.buffer(buffer)\n\n        return reduce(merge, _shapes, _first)\n\n    def recalculate_extent(self) -&gt; None:\n        \"\"\"Recalculate the FeatureClass Extent\"\"\"\n        RecalculateFeatureClassExtent(self.path, 'STORE_EXTENT')\n\n    # Magic Methods\n\n    if TYPE_CHECKING:\n\n        _OVERLOAD_TYPES = Table._OVERLOAD_TYPES | Extent | GeometryType\n\n        @overload\n        def __getitem__(self, field: tuple[FieldName, ...]) -&gt; Iterator[tuple[Any, ...]]:\n            \"\"\"Yield tuples of the requested field values\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: list[FieldName]) -&gt; Iterator[list[Any]]:\n            \"\"\"Yield lists of the requested field values\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: set[FieldName]) -&gt; Iterator[RowRecord]:\n            \"\"\"Yield dictionaries of the requested field values\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: FieldName) -&gt; Iterator[Any]:\n            \"\"\"Yield values from the requested field\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: FilterFunc) -&gt; Iterator[RowRecord]:\n            \"\"\"Yield dictionaries of the rows that match the filter function\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: WhereClause) -&gt; Iterator[RowRecord]:\n            \"\"\"Yield values that match the provided WhereClause SQL statement\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: None) -&gt; Iterator[None]:\n            \"\"\"Yield nothing (used as fallback if an indexing argument is None)\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: GeometryType | Extent) -&gt; Iterator[RowRecord]:\n            \"\"\"Yield rows that intersect the provided geometry\"\"\"\n            pass\n\n    def __getitem__(self, field: _OVERLOAD_TYPES) -&gt; Iterator[Any]:\n        \"\"\"Handle all defined overloads using pattern matching syntax\n\n        Args:\n            field (str): Yield values in the specified column (values only)\n            field (list[str]): Yield lists of values for requested columns (requested fields)\n            field (tuple[str]): Yield tuples of values for requested columns (requested fields)\n            field (set[str]): Yield dictionaries of values for requested columns (requested fields)\n            field (Geometry | Extent): Yield dictionaries of values for all features intersecting the specified shape\n            field (FilterFunc): Yield rows that match function (all fields)\n            field (WhereClause): Yield rows that match clause (all fields)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; # Single Field\n            &gt;&gt;&gt; print(list(fc['field']))\n            [val1, val2, val3, ...]\n\n            &gt;&gt;&gt; # Field Tuple\n            &gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n            [(val1, val2), (val1, val2), ...]\n\n            &gt;&gt;&gt; # Field List\n            &gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n            [[val1, val2], [val1, val2], ...]\n\n            &gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n            &gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n            [{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n            &gt;&gt;&gt; # Last two options always return all fields in a mapping\n            &gt;&gt;&gt; # Filter Function (passed to FeatureClass.filter())\n            &gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n            &gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # Shape Filter (provide a shape to use as a spatial filter on the rows)\n            &gt;&gt;&gt; print(list(fc[shape]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # None (Empty Iterator)\n            &gt;&gt;&gt; print(list(fc[None]))\n            ```\n        \"\"\"\n        match field:\n            case shape if isinstance(shape, Extent | GeometryType):\n                with self.search_cursor(self.fields, spatial_filter=shape) as cur:\n                    yield from (row for row in as_dict(cur))\n            case field if isinstance(field, str|list|tuple|set|Callable|WhereClause):\n                yield from super().__getitem__(field)\n            case _:\n                raise KeyError(\n                    f\"Invalid option: {field}\\n\"\n                    \"Must be a filter functon, set of keys, list of keys, or tuple of keys\"\n                )\n\n    def __format__(self, format_spec: str) -&gt; str:\n        match format_spec:\n            case 'shape' | 'shp':\n                return self.describe.shapeType\n            case 'wkid' | 'code':\n                return str(self.spatial_reference.factoryCode)\n            case 'unit':\n                return self.spatial_reference.linearUnitName\n            case _:\n                return super().__format__(format_spec)\n\n    # Context Managers\n\n    @contextmanager\n    def reference_as(self, spatial_reference: SpatialReference):\n        \"\"\"Allows you to temporarily set a spatial reference on SearchCursor and UpdateCursor objects within a context block\n\n        Args:\n            spatial_reference (SpatialReference): The spatial reference to apply to the cursor objects\n\n        Yields:\n            (self): Mutated self with search and update options set to use the provided spatial reference\n\n        Example:\n            ```python\n            &gt;&gt;&gt; sr = arcpy.SpatialReference(26971)\n            &gt;&gt;&gt; fc = FeatureClass[Polygon]('&lt;fc_path&gt;')\n\n            &gt;&gt;&gt; orig_shapes = list(fc.shapes)\n\n            &gt;&gt;&gt; with fc.project_as(sr):\n            ...     proj_shapes = list(fc.shapes)\n\n            &gt;&gt;&gt; print(orig_shapes[0].spatialReference)\n            SpatialReference(4326)\n\n            &gt;&gt;&gt; print(proj_shapes[0].spatialReference)\n            SpatialReference(26971)\n            ```\n        \"\"\"\n        with self.options(\n            search_options=SearchOptions(spatial_reference=spatial_reference), \n            update_options=UpdateOptions(spatial_reference=spatial_reference)):\n            yield self\n\n    @contextmanager\n    def spatial_filter(self, spatial_filter: GeometryType | Extent, spatial_relationship: SpatialRelationship='INTERSECTS'):\n        \"\"\"Apply a spatial filter to the FeatureClass in a context\n\n        Args:\n            spatial_filter (Geometry | Extent): The geometry to use as a spatial filter\n            spatial_relationship (SpatialRelationship): The relationship to check for (default: `INTERSECTS`)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; with fc.spatial_filter(boundary) as f:\n            ...     print(len(fc))\n            100\n            &gt;&gt;&gt; print(len(fc))\n            50000\n            ```\n\n        Note:\n            Same as with `where`, this method will be much faster than any manual `filter` you can apply using python. \n            If you need to filter a FeatureClass by a spatial relationship, use this method, then do your expensive \n            `filter` operation on the reduced dataset\n\n            ```python\n            &gt;&gt;&gt; def expensive_filter(rec):\n            &gt;&gt;&gt;     ...\n            &gt;&gt;&gt; with fc.spatial_filter(boundary) as local:\n            &gt;&gt;&gt;     for row in fc.filter(expensive_filter):\n            &gt;&gt;&gt;         ...\n            ```\n        \"\"\"\n        with self.options(\n            search_options=SearchOptions(\n                spatial_filter=spatial_filter, \n                spatial_relationship=spatial_relationship)):\n            yield self\n\n    # Factory Constructors\n\n    @classmethod\n    def from_layer(cls, layer: Layer,\n                   *,\n                   ignore_selection: bool = False,\n                   ignore_def_query: bool = False,) -&gt; FeatureClass[_GeometryType]:\n        \"\"\"Build a FeatureClass object from a layer applying the layer's current selection to the stored cursors\n\n        Args:\n            layer (Layer): The layer to convert to a FeatureClass\n            ignore_selection (bool): Ignore the layer selection (default: False)\n            ignore_definition_query (bool): Ignore the layer definition query (default: False)\n        Returns:\n            ( FeatureClass ): The FeatureClass object with the layer query applied\n        \"\"\"\n        fc = cls(layer.dataSource)\n\n        selected_ids: set[int] | None = (\n            layer.getSelectionSet() or None\n            if not ignore_selection \n            else None\n        )\n        definition_query: str|None = (\n            layer.definitionQuery or None\n            if not ignore_def_query \n            else None\n        )\n        selection: str|None = (\n            f\"{fc.oid_field_name} IN ({format_query_list(selected_ids)})\" \n            if selected_ids \n            else None\n        )\n\n        if (query_components := list(filter(None, [definition_query, selection]))):\n            where_clause = ' AND '.join(query_components)\n            fc.search_options = SearchOptions(where_clause=where_clause)\n            fc.update_options = UpdateOptions(where_clause=where_clause)\n\n        fc.layer = layer\n        return fc\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.extent","title":"<code>extent</code>  <code>property</code>","text":"<p>Get the stored extent of the feature class</p>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.fields","title":"<code>fields</code>  <code>property</code>","text":"<p>Tuple of all fieldnames in the FeatureClass with <code>OID@</code> and <code>SHAPE@</code> as first 2</p>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.py_types","title":"<code>py_types</code>  <code>property</code>","text":"<p>Get a mapping of the field types for the FeatureClass</p>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.shape_token","title":"<code>shape_token</code>  <code>property</code> <code>writable</code>","text":"<p>Set the default <code>SHAPE@??</code> token for iteration. Use <code>SHAPE@</code> for full shape (default: <code>SHAPE@</code>)</p>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.__getitem__","title":"<code>__getitem__(field)</code>","text":"<pre><code>__getitem__(field: tuple[FieldName, ...]) -&gt; Iterator[tuple[Any, ...]]\n</code></pre><pre><code>__getitem__(field: list[FieldName]) -&gt; Iterator[list[Any]]\n</code></pre><pre><code>__getitem__(field: set[FieldName]) -&gt; Iterator[RowRecord]\n</code></pre><pre><code>__getitem__(field: FieldName) -&gt; Iterator[Any]\n</code></pre><pre><code>__getitem__(field: FilterFunc) -&gt; Iterator[RowRecord]\n</code></pre><pre><code>__getitem__(field: WhereClause) -&gt; Iterator[RowRecord]\n</code></pre><pre><code>__getitem__(field: None) -&gt; Iterator[None]\n</code></pre><pre><code>__getitem__(field: GeometryType | Extent) -&gt; Iterator[RowRecord]\n</code></pre> <p>Handle all defined overloads using pattern matching syntax</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>Yield values in the specified column (values only)</p> required <code>field</code> <code>list[str]</code> <p>Yield lists of values for requested columns (requested fields)</p> required <code>field</code> <code>tuple[str]</code> <p>Yield tuples of values for requested columns (requested fields)</p> required <code>field</code> <code>set[str]</code> <p>Yield dictionaries of values for requested columns (requested fields)</p> required <code>field</code> <code>Geometry | Extent</code> <p>Yield dictionaries of values for all features intersecting the specified shape</p> required <code>field</code> <code>FilterFunc</code> <p>Yield rows that match function (all fields)</p> required <code>field</code> <code>WhereClause</code> <p>Yield rows that match clause (all fields)</p> required Example <pre><code>&gt;&gt;&gt; # Single Field\n&gt;&gt;&gt; print(list(fc['field']))\n[val1, val2, val3, ...]\n\n&gt;&gt;&gt; # Field Tuple\n&gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n[(val1, val2), (val1, val2), ...]\n\n&gt;&gt;&gt; # Field List\n&gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n[[val1, val2], [val1, val2], ...]\n\n&gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n&gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n[{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n&gt;&gt;&gt; # Last two options always return all fields in a mapping\n&gt;&gt;&gt; # Filter Function (passed to FeatureClass.filter())\n&gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n&gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # Shape Filter (provide a shape to use as a spatial filter on the rows)\n&gt;&gt;&gt; print(list(fc[shape]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # None (Empty Iterator)\n&gt;&gt;&gt; print(list(fc[None]))\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __getitem__(self, field: _OVERLOAD_TYPES) -&gt; Iterator[Any]:\n    \"\"\"Handle all defined overloads using pattern matching syntax\n\n    Args:\n        field (str): Yield values in the specified column (values only)\n        field (list[str]): Yield lists of values for requested columns (requested fields)\n        field (tuple[str]): Yield tuples of values for requested columns (requested fields)\n        field (set[str]): Yield dictionaries of values for requested columns (requested fields)\n        field (Geometry | Extent): Yield dictionaries of values for all features intersecting the specified shape\n        field (FilterFunc): Yield rows that match function (all fields)\n        field (WhereClause): Yield rows that match clause (all fields)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # Single Field\n        &gt;&gt;&gt; print(list(fc['field']))\n        [val1, val2, val3, ...]\n\n        &gt;&gt;&gt; # Field Tuple\n        &gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n        [(val1, val2), (val1, val2), ...]\n\n        &gt;&gt;&gt; # Field List\n        &gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n        [[val1, val2], [val1, val2], ...]\n\n        &gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n        &gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n        [{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n        &gt;&gt;&gt; # Last two options always return all fields in a mapping\n        &gt;&gt;&gt; # Filter Function (passed to FeatureClass.filter())\n        &gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n        &gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # Shape Filter (provide a shape to use as a spatial filter on the rows)\n        &gt;&gt;&gt; print(list(fc[shape]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # None (Empty Iterator)\n        &gt;&gt;&gt; print(list(fc[None]))\n        ```\n    \"\"\"\n    match field:\n        case shape if isinstance(shape, Extent | GeometryType):\n            with self.search_cursor(self.fields, spatial_filter=shape) as cur:\n                yield from (row for row in as_dict(cur))\n        case field if isinstance(field, str|list|tuple|set|Callable|WhereClause):\n            yield from super().__getitem__(field)\n        case _:\n            raise KeyError(\n                f\"Invalid option: {field}\\n\"\n                \"Must be a filter functon, set of keys, list of keys, or tuple of keys\"\n            )\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.footprint","title":"<code>footprint(buffer=None)</code>","text":"<p>Merge all geometry in the featureclass using current SelectionOptions into a single geometry object to use  as a spatial filter on other FeatureClasses</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>float | None</code> <p>Optional buffer (in feature units, respects projection context) to buffer by (default: None)</p> <code>None</code> <p>Returns:</p> Type Description <code>GeometryType | None</code> <p>A merged Multi-Geometry of all feature geometries or <code>None</code> if no features in FeatureClass</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def footprint(self, buffer: float|None=None) -&gt; _GeometryType | None:\n    \"\"\"Merge all geometry in the featureclass using current SelectionOptions into a single geometry object to use \n    as a spatial filter on other FeatureClasses\n\n    Args:\n        buffer (float | None): Optional buffer (in feature units, respects projection context) to buffer by (default: None)\n\n    Returns:\n        (GeometryType | None): A merged Multi-Geometry of all feature geometries or `None` if no features in FeatureClass\n    \"\"\"\n    if len(self) == 0:\n        return None\n\n    def merge(acc: _GeometryType, nxt: _GeometryType) -&gt; _GeometryType:\n        if buffer:\n            nxt = nxt.buffer(buffer)\n        return acc.union(nxt)\n\n    # Consume the shape generator popping off the first shape and applying the buffer, \n    # Then buffering each additional shape and merging it into the accumulator (starting with _first)\n    _shapes = self.shapes\n    _first = next(_shapes)\n    if buffer:\n        _first = _first.buffer(buffer)\n\n    return reduce(merge, _shapes, _first)\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.from_layer","title":"<code>from_layer(layer, *, ignore_selection=False, ignore_def_query=False)</code>  <code>classmethod</code>","text":"<p>Build a FeatureClass object from a layer applying the layer's current selection to the stored cursors</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer to convert to a FeatureClass</p> required <code>ignore_selection</code> <code>bool</code> <p>Ignore the layer selection (default: False)</p> <code>False</code> <code>ignore_definition_query</code> <code>bool</code> <p>Ignore the layer definition query (default: False)</p> required <p>Returns:     ( FeatureClass ): The FeatureClass object with the layer query applied</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@classmethod\ndef from_layer(cls, layer: Layer,\n               *,\n               ignore_selection: bool = False,\n               ignore_def_query: bool = False,) -&gt; FeatureClass[_GeometryType]:\n    \"\"\"Build a FeatureClass object from a layer applying the layer's current selection to the stored cursors\n\n    Args:\n        layer (Layer): The layer to convert to a FeatureClass\n        ignore_selection (bool): Ignore the layer selection (default: False)\n        ignore_definition_query (bool): Ignore the layer definition query (default: False)\n    Returns:\n        ( FeatureClass ): The FeatureClass object with the layer query applied\n    \"\"\"\n    fc = cls(layer.dataSource)\n\n    selected_ids: set[int] | None = (\n        layer.getSelectionSet() or None\n        if not ignore_selection \n        else None\n    )\n    definition_query: str|None = (\n        layer.definitionQuery or None\n        if not ignore_def_query \n        else None\n    )\n    selection: str|None = (\n        f\"{fc.oid_field_name} IN ({format_query_list(selected_ids)})\" \n        if selected_ids \n        else None\n    )\n\n    if (query_components := list(filter(None, [definition_query, selection]))):\n        where_clause = ' AND '.join(query_components)\n        fc.search_options = SearchOptions(where_clause=where_clause)\n        fc.update_options = UpdateOptions(where_clause=where_clause)\n\n    fc.layer = layer\n    return fc\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.recalculate_extent","title":"<code>recalculate_extent()</code>","text":"<p>Recalculate the FeatureClass Extent</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def recalculate_extent(self) -&gt; None:\n    \"\"\"Recalculate the FeatureClass Extent\"\"\"\n    RecalculateFeatureClassExtent(self.path, 'STORE_EXTENT')\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.reference_as","title":"<code>reference_as(spatial_reference)</code>","text":"<p>Allows you to temporarily set a spatial reference on SearchCursor and UpdateCursor objects within a context block</p> <p>Parameters:</p> Name Type Description Default <code>spatial_reference</code> <code>SpatialReference</code> <p>The spatial reference to apply to the cursor objects</p> required <p>Yields:</p> Type Description <code>self</code> <p>Mutated self with search and update options set to use the provided spatial reference</p> Example <pre><code>&gt;&gt;&gt; sr = arcpy.SpatialReference(26971)\n&gt;&gt;&gt; fc = FeatureClass[Polygon]('&lt;fc_path&gt;')\n\n&gt;&gt;&gt; orig_shapes = list(fc.shapes)\n\n&gt;&gt;&gt; with fc.project_as(sr):\n...     proj_shapes = list(fc.shapes)\n\n&gt;&gt;&gt; print(orig_shapes[0].spatialReference)\nSpatialReference(4326)\n\n&gt;&gt;&gt; print(proj_shapes[0].spatialReference)\nSpatialReference(26971)\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef reference_as(self, spatial_reference: SpatialReference):\n    \"\"\"Allows you to temporarily set a spatial reference on SearchCursor and UpdateCursor objects within a context block\n\n    Args:\n        spatial_reference (SpatialReference): The spatial reference to apply to the cursor objects\n\n    Yields:\n        (self): Mutated self with search and update options set to use the provided spatial reference\n\n    Example:\n        ```python\n        &gt;&gt;&gt; sr = arcpy.SpatialReference(26971)\n        &gt;&gt;&gt; fc = FeatureClass[Polygon]('&lt;fc_path&gt;')\n\n        &gt;&gt;&gt; orig_shapes = list(fc.shapes)\n\n        &gt;&gt;&gt; with fc.project_as(sr):\n        ...     proj_shapes = list(fc.shapes)\n\n        &gt;&gt;&gt; print(orig_shapes[0].spatialReference)\n        SpatialReference(4326)\n\n        &gt;&gt;&gt; print(proj_shapes[0].spatialReference)\n        SpatialReference(26971)\n        ```\n    \"\"\"\n    with self.options(\n        search_options=SearchOptions(spatial_reference=spatial_reference), \n        update_options=UpdateOptions(spatial_reference=spatial_reference)):\n        yield self\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.FeatureClass.spatial_filter","title":"<code>spatial_filter(spatial_filter, spatial_relationship='INTERSECTS')</code>","text":"<p>Apply a spatial filter to the FeatureClass in a context</p> <p>Parameters:</p> Name Type Description Default <code>spatial_filter</code> <code>Geometry | Extent</code> <p>The geometry to use as a spatial filter</p> required <code>spatial_relationship</code> <code>SpatialRelationship</code> <p>The relationship to check for (default: <code>INTERSECTS</code>)</p> <code>'INTERSECTS'</code> Example <pre><code>&gt;&gt;&gt; with fc.spatial_filter(boundary) as f:\n...     print(len(fc))\n100\n&gt;&gt;&gt; print(len(fc))\n50000\n</code></pre> Note <p>Same as with <code>where</code>, this method will be much faster than any manual <code>filter</code> you can apply using python.  If you need to filter a FeatureClass by a spatial relationship, use this method, then do your expensive  <code>filter</code> operation on the reduced dataset</p> <pre><code>&gt;&gt;&gt; def expensive_filter(rec):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt; with fc.spatial_filter(boundary) as local:\n&gt;&gt;&gt;     for row in fc.filter(expensive_filter):\n&gt;&gt;&gt;         ...\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef spatial_filter(self, spatial_filter: GeometryType | Extent, spatial_relationship: SpatialRelationship='INTERSECTS'):\n    \"\"\"Apply a spatial filter to the FeatureClass in a context\n\n    Args:\n        spatial_filter (Geometry | Extent): The geometry to use as a spatial filter\n        spatial_relationship (SpatialRelationship): The relationship to check for (default: `INTERSECTS`)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; with fc.spatial_filter(boundary) as f:\n        ...     print(len(fc))\n        100\n        &gt;&gt;&gt; print(len(fc))\n        50000\n        ```\n\n    Note:\n        Same as with `where`, this method will be much faster than any manual `filter` you can apply using python. \n        If you need to filter a FeatureClass by a spatial relationship, use this method, then do your expensive \n        `filter` operation on the reduced dataset\n\n        ```python\n        &gt;&gt;&gt; def expensive_filter(rec):\n        &gt;&gt;&gt;     ...\n        &gt;&gt;&gt; with fc.spatial_filter(boundary) as local:\n        &gt;&gt;&gt;     for row in fc.filter(expensive_filter):\n        &gt;&gt;&gt;         ...\n        ```\n    \"\"\"\n    with self.options(\n        search_options=SearchOptions(\n            spatial_filter=spatial_filter, \n            spatial_relationship=spatial_relationship)):\n        yield self\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table","title":"<code>Table</code>","text":"<p>A Wrapper for ArcGIS Table objects</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>class Table:\n    \"\"\"A Wrapper for ArcGIS Table objects\"\"\"\n\n    Tokens = TableTokens\n\n    def __init__(\n            self, path: str|Path,\n            *,\n            search_options: SearchOptions|None=None, \n            update_options: UpdateOptions|None=None, \n            insert_options: InsertOptions|None=None,\n            clause: SQLClause|None=None,\n            where: str|None=None,\n        ) -&gt; None:\n        self._path = str(path)\n        self._clause = clause or SQLClause(None, None)\n        self._search_options = search_options or SearchOptions()\n        self._insert_options = insert_options or InsertOptions()\n        self._update_options = update_options or UpdateOptions()\n\n        # Override\n        if where:\n            self._search_options['where_clause'] = where\n            self._update_options['where_clause'] = where\n\n        self._layer: Layer|None=None\n        self._in_edit_session=False\n        self._fields: tuple[TableToken | str, ...]|None=None\n\n    # rw Properties\n\n    @property\n    def search_options(self) -&gt; SearchOptions:\n        return self._search_options.copy()\n\n    @search_options.setter\n    def search_options(self, search_options: SearchOptions) -&gt; None:\n        self._search_options = search_options or SearchOptions()\n\n    @property\n    def insert_options(self) -&gt; InsertOptions:\n        return self._insert_options.copy()\n\n    @insert_options.setter\n    def insert_options(self, insert_options: InsertOptions) -&gt; None:\n        self._insert_options = insert_options or InsertOptions()\n\n    @property\n    def update_options(self) -&gt; UpdateOptions:\n        return self._update_options.copy() # pyright: ignore[reportReturnType]\n\n    @update_options.setter\n    def update_options(self, update_options: UpdateOptions) -&gt; None:\n        self._update_options = update_options or UpdateOptions()\n\n    @property\n    def clause(self) -&gt; SQLClause:\n        return self._clause\n\n    @clause.setter\n    def clause(self, clause: SQLClause) -&gt; None:\n        \"\"\"Set a feature level SQL clause on all Insert and Search operations\n\n        This clause is overridden by all Option level clauses\n        \"\"\"\n        self._clause = clause\n\n    @property\n    def layer(self) -&gt; Layer|None:\n        return self._layer\n\n    @layer.setter\n    def layer(self, layer: Layer) -&gt; None:\n        \"\"\"Set a layer object for the Table or FeatureClass, layer datasource must be this feature class!\"\"\"\n        if layer.dataSource != self.path:\n            raise ValueError(f'Layer: {layer.name} does not source to {self.name} Table or FeatureClass at {self.path}!')\n        self._layer = layer\n\n    # ro Properties\n\n    @property\n    def path(self) -&gt; str:\n        return self._path\n\n    @property\n    def describe(self) -&gt; dt.Table:\n        \"\"\"Access the arcpy.Describe object for the `Table` or `FeatureClass`\"\"\"\n        return Describe(self.path) #type:ignore (Will be dt.Table or FeatureClass)\n\n    @property\n    def da_describe(self) -&gt; dict[str, Any]:\n        \"\"\"Access the da.Describe dictionary for the `Table` or `FeatureClass`\"\"\"\n        return Describe_da(self.path)\n\n    @property\n    def workspace(self) -&gt; str:\n        \"\"\"Get the workspace of the `Table` or `FeatureClass`\"\"\"\n        return self.describe.workspace.catalogPath\n\n    @property\n    def name(self) -&gt; str:\n        return self.describe.name\n\n    @property\n    def oid_field_name(self) -&gt; str:\n        return self.describe.OIDFieldName\n\n    @property\n    def subtype_field(self) -&gt; str | None:\n        if not self.subtypes:\n            return None\n        return list(self.subtypes.values()).pop()['SubtypeField']\n\n    @property\n    def fields(self) -&gt; tuple[TableToken | str, ...]:\n        \"\"\"Tuple of all fieldnames in the Table or FeatureClass with `OID@` as first\"\"\"\n        if not self._fields:\n            exclude = (self.oid_field_name)\n            replace = ('OID@',)\n            _fields = ()\n            with self.search_cursor('*') as c:\n                _fields = c.fields\n            self._fields = replace + tuple((f for f in _fields if f not in exclude))\n        return self._fields\n\n    @property\n    def np_dtypes(self):\n        return self.search_cursor(self.fields)._dtype # pyright: ignore[reportPrivateUsage]\n\n    @property\n    def py_types(self) -&gt; dict[str, type]:\n        \"\"\"Get a mapping of fieldnames to python types for the Table\"\"\"\n        return convert_dtypes(self.np_dtypes)\n\n    @property\n    def subtypes(self) -&gt; dict[int, Subtype]:\n        \"\"\"Result of ListSubtypes, mapping of code to Subtype object\"\"\"\n        return ListSubtypes(self.path) # type:ignore\n\n    @property\n    def editor(self) -&gt; Editor:\n        \"\"\"Get an Editor manager for the Table or FeatureClass\n        Will set multiuser_mode to True if the feature can version\n        \"\"\"\n        return Editor(self.workspace, multiuser_mode=self.describe.canVersion)\n\n    @property\n    def attribute_rules(self) -&gt; dict[str, AttributeRule]:\n        \"\"\"Get FeatureClass attribute rules access by name\"\"\"\n        return {rule['name']: AttributeRule(rule) for rule in self.da_describe['attributeRules']}\n\n    # Option Resolvers (kwargs -&gt; Options Object -&gt; Table or FeatureClass Options)\n\n    def _resolve_search_options(self, options: SearchOptions|None, overrides: SearchOptions) -&gt; SearchOptions:\n        \"\"\"Combine all provided SearchOptions into one dictionary\"\"\"\n        return {\n            'sql_clause': self.clause or SQLClause(None, None), \n            **self.search_options, \n            **(options or {}), \n            **overrides\n        }\n\n    def _resolve_insert_options(self, options: InsertOptions|None, overrides: InsertOptions) -&gt; InsertOptions:\n        \"\"\"Combine all provided InsertOptions into one dictionary\"\"\"\n        return {**self.insert_options, **(options or {}), **overrides}\n\n    def _resolve_update_options(self, options: UpdateOptions|None, overrides: UpdateOptions) -&gt; UpdateOptions:\n        \"\"\"Combine all provided UpdateOptions into one dictionary\"\"\"\n        return {\n            'sql_clause': self.clause or SQLClause(None, None), \n            **self.update_options, \n            **(options or {}), \n            **overrides\n        }\n\n    # Cursor Handlers\n\n    def search_cursor(self, field_names: FieldName | Sequence[FieldName],\n                      *,\n                      search_options: SearchOptions|None=None, \n                      **overrides: Unpack[SearchOptions]) -&gt; SearchCursor:\n        \"\"\"Get a `SearchCursor` for the `Table` or `FeatureClass`\n        Supplied search options are resolved by updating the base `Table` or `FeatureClass` Search options in this order:\n\n        `**overrides['kwarg'] -&gt; search_options['kwarg'] -&gt; self.search_options['kwarg']`\n\n        This is implemented using unpacking operations with the lowest importance option set being unpacked first\n\n        `{**self.search_options, **(search_options or {}), **overrides}`\n\n        With direct key word arguments (`**overrides`) shadowing all other supplied options. This allows a Feature Class to\n        be initialized using a base set of options, then a shared SearchOptions set to be applied in some contexts,\n        then a direct keyword override to be supplied while never mutating the base options of the feature class.\n\n        Args:\n            field_names (str | Iterable[str]): The column names to include from the `Table` or `FeatureClass`\n            search_options (SearchOptions|None): A `SeachOptions` instance that will be used to shadow\n                `search_options` set on the `Table` or `FeatureClass`\n            **overrides ( Unpack[SeachOptions] ): Additional keyword arguments for the cursor that shadow \n                both the `seach_options` variable and the `Table` or `FeatureClass` instance `SearchOptions`\n\n        Returns:\n            ( SearchCursor ): A `SearchCursor` for the `Table` or `FeatureClass` instance that has all supplied options\n                resolved and applied\n\n        Example:\n            ```python\n                &gt;&gt;&gt; cleese_search = SearchOptions(where_clause=\"NAME = 'John Cleese'\")\n                &gt;&gt;&gt; idle_search = SearchOptions(where_clause=\"NAME = 'Eric Idle'\")\n                &gt;&gt;&gt; monty = Table or FeatureClass('&lt;path&gt;', search_options=cleese_search)\n                &gt;&gt;&gt; print(list(monty.search_cursor('NAME')))\n                [('John Cleese',)]\n                &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)))\n                [('Eric Idle', )]\n                &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)), where_clause=\"NAME = Graham Chapman\")\n                [('Graham Chapman', )]\n            ```\n        In this example, you can see that the keyword override is the most important. The fact that the other searches are\n        created outside initialization allows you to store common queries in one place and update them for all cursors using \n        them at the same time, while still allowing specific instances of a cursor to override those shared/stored defaults.\n        \"\"\"\n        return SearchCursor(self.path, field_names, **self._resolve_search_options(search_options, overrides))\n\n    def insert_cursor(self, field_names: FieldName | Sequence[FieldName],\n                      *,\n                      insert_options: InsertOptions|None=None, \n                      **overrides: Unpack[InsertOptions]) -&gt; InsertCursor:\n        \"\"\"See `Table.search_cursor` doc for general info. Operation of this method is identical but returns an `InsertCursor`\"\"\"\n        return InsertCursor(self.path, field_names, **self._resolve_insert_options(insert_options, overrides))\n\n    def update_cursor(self, field_names: FieldName | Sequence[FieldName],\n                      *,\n                      update_options: UpdateOptions|None=None, \n                      **overrides: Unpack[UpdateOptions]) -&gt; UpdateCursor:\n        \"\"\"See `Table.search_cursor` doc for general info. Operation of this method is identical but returns an `UpdateCursor`\"\"\"\n        return UpdateCursor(self.path, field_names, **self._resolve_update_options(update_options, overrides))\n\n    if TYPE_CHECKING:\n        GroupIter = Iterator[tuple[Any, ...] | Any]\n        GroupIdent = tuple[Any, ...] | Any\n    def group_by(self, group_fields: Sequence[FieldName] | FieldName, return_fields: Sequence[FieldName] | FieldName ='*') -&gt; Iterator[tuple[GroupIdent, GroupIter]]:\n        \"\"\"Group features by matching field values and yield full records in groups\n\n        Args:\n            group_fields (FieldOpt): The fields to group the data by\n            return_fields (FieldOpt): The fields to include in the output record (`'*'` means all and is default)\n        Yields:\n            ( Iterator[tuple[tuple[FieldName, ...], Iterator[tuple[Any, ...] | Any]]] ): A nested iterator of groups and then rows\n\n        Example:\n            ```python\n            &gt;&gt;&gt; # With a field group, you will be able to unpack the tuple\n            &gt;&gt;&gt; for group, rows in fc.group_by(['GroupField1', 'GroupField2'], ['ValueField1', 'ValueField2', ...]):\n            ...     print(group)\n            ...     for v1, v2 in rows:\n            ...        if v1 &gt; 10:\n            ...            print(v2)\n            (GroupValue1A, GroupValue1B)\n            valueA\n            valueB\n            ...\n            &gt;&gt;&gt; # With a single field, you will have direct access to the field values   \n            &gt;&gt;&gt; for group, district_populations in fc.group_by(['City', 'State'], 'Population'):\n            &gt;&gt;&gt;         print(f\"{group}: {sum(district_populations)}\")\n            (New York, NY): 8260000\n            (Boston, MA): 4941632\n            ...\n            ```\n        \"\"\"\n\n        # Parameter Validations\n        if isinstance(group_fields, str):\n            group_fields = (group_fields,)\n        if return_fields == '*':\n            return_fields = self.fields\n        if isinstance(return_fields, str):\n            return_fields = (return_fields,)\n        if len(group_fields) &lt; 1 or len(return_fields) &lt; 1:\n            raise ValueError(\"Group Fields and Return Fields must be populated\")\n\n        group_fields = list(group_fields)\n        return_fields = list(return_fields)\n        _all_fields = group_fields + return_fields\n        for group in self.distinct(group_fields):\n            group_key = {field : value for field, value in zip(group_fields, group)}\n            where_clause = \" AND \".join(f\"{field} = {norm(value)}\" for field, value in group_key.items())\n            if '@' not in where_clause: # Handle valid clause (no tokens)\n                with self.search_cursor(return_fields, where_clause=where_clause) as group_cur:\n                    yield (extract_singleton(group), (extract_singleton(row) for row in group_cur))\n            else: # Handle token being passed by iterating a cursor and checking values directly\n                for row in filter(lambda row: all(row[k] == group_key[k] for k in group_key), self[set(_all_fields)]):\n                    yield (extract_singleton(group), (row.pop(k) for k in return_fields))\n\n    def distinct(self, distinct_fields: Sequence[FieldName] | FieldName) -&gt; Iterator[tuple[Any, ...]]:\n        \"\"\"Yield rows of distinct values\n\n        Args:\n            distinct_fields (FieldOpt): The field or fields to find distinct values for.\n                Choosing multiple fields will find all distinct instances of those field combinations\n\n        Yields:\n            ( tuple[Any, ...] ): A tuple containing the distinct values (single fields will yield `(value, )` tuples)\n        \"\"\"\n        clause = SQLClause(prefix=f'DISTINCT {format_query_list(distinct_fields)}', postfix=None)\n        try:\n            yield from (value for value in self.search_cursor(distinct_fields, sql_clause=clause))\n        except RuntimeError: # Fallback when DISTINCT is not available or fails with Token input\n            yield from sorted(set(self.get_tuples(distinct_fields)))\n\n    def get_records(self, field_names: Sequence[FieldName] | FieldName, **options: Unpack[SearchOptions]) -&gt; Iterator[RowRecord]:\n        \"\"\"Generate row dicts with in the form `{field: value, ...}` for each row in the cursor\n\n        Args:\n            field_names (str | Iterable[str]): The columns to iterate\n            search_options (SearchOptions): A Search Options object\n            **options (Unpack[SearchOptions]): Additional over\n            search_options (SearchOptions): A Search Options object\n            **options (Unpack[SearchOptions]): Additional over\n        Yields \n            ( dict[str, Any] ): A mapping of fieldnames to field values for each row\n        \"\"\"\n        with self.search_cursor(field_names, **options) as cur:\n            yield from as_dict(cur)\n\n    def get_tuples(self, field_names: Sequence[FieldName] | FieldName, **options: Unpack[SearchOptions]) -&gt; Iterator[tuple[Any, ...]]:\n        \"\"\"Generate tuple rows in the for (val1, val2, ...) for each row in the cursor\n\n        Args:\n            field_names (str | Iterable[str]): The columns to iterate\n            **options (SearchOptions): Additional parameters to pass to the SearchCursor\n        \"\"\"\n        with self.search_cursor(field_names, **options) as cur:\n            yield from cur\n\n    def insert_records(self, records: Iterator[RowRecord] | Sequence[RowRecord], ignore_errors: bool=False) -&gt; tuple[int, ...]:\n        \"\"\"Provide a list of records to insert\n        Args:\n            records (Iterable[RowRecord]): The sequence of records to insert\n            ignore_errors (bool): Ignore per-row errors and continue. Otherwise raise KeyError (default: True)\n\n        Returns:\n            ( tuple[int] ): Returns the OIDs of the newly inserted rows\n\n        Raises:\n            ( KeyError ): If the records have varying keys or the keys are not in the Table or FeatureClass\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_rows = [\n            ...    {'first': 'John', 'last': 'Cleese', 'year': 1939}, \n            ...    {'first': 'Michael', 'last': 'Palin', 'year': 1943}\n            ... ]\n            &gt;&gt;&gt; print(fc.insert_rows(new_rows))\n            (2,3)\n\n            &gt;&gt;&gt; # Insert all shapes from fc into fc2\n            &gt;&gt;&gt; fc2.insert_rows(fc.get_records(['first', 'last', 'year']))\n            (1,2)\n            ```\n        \"\"\"\n        # Always cast records to a list to prevent cursor race conditions, \n        # e.g. feature_class.insert_records(feature_class[where('SUBTYPE == 1')]) \n        # would insert infinite records since the search cursor trails the insert cursor.\n        records = list(records)\n        if not records:\n            return tuple()\n\n        rec_fields: list[str] = list(records[0].keys())\n        def rec_filter(rec: RowRecord) -&gt; bool:\n            if not rec_fields or set(rec.keys()).issubset(rec_fields):\n                return True\n            if ignore_errors:\n                return False\n            raise KeyError(f\"Invalid record found {rec}, does not contain the required fields: {rec_fields}\")\n\n        new_ids: list[int] = []\n        with self.editor, self.insert_cursor(rec_fields) as cur:\n            for rec in filter(rec_filter, records):\n                new_ids.append(cur.insertRow(tuple(rec.get(k) for k in rec_fields)))\n        return tuple(new_ids)\n\n    def delete_identical(self, field_names: Sequence[FieldName] | FieldName) -&gt; dict[int, int]:\n        \"\"\"Delete all records that have matching field values\n\n        Args:\n            field_names (Sequence[FieldName] | FieldName): The fields used to define an identical feature\n\n        Returns:\n            (dict[int, int]): A dictionary of count of identical features deleted per feature\n\n        Note:\n            Insertion order takes precidence unless the Table or FeatureClass is ordered. The first feature found\n            by the cursor will be maintained and all subsequent matches will be removed\n        \"\"\"\n        # All\n        if isinstance(field_names, str):\n            field_names = [field_names]\n\n        unique: dict[int, tuple[Any]] = {}\n        deleted: dict[int, int] = {}\n        with self.editor, self.update_cursor(['OID@'] + list(field_names)) as cur:\n            for row in cur:\n                oid: int = row[0]\n                row = tuple(row[1:])\n                for match_id, match_row in unique.items():\n                    if all(a == b for a, b in zip(row, match_row)):\n                        match = match_id\n                        break\n                else:\n                    match = False\n\n                if not match:\n                    unique[oid] = row\n\n                else:\n                    deleted.setdefault(match, 0)\n                    deleted[match] += 1\n                    cur.deleteRow()\n        return deleted\n\n    def filter(self, func: FilterFunc, invert: bool=False) -&gt; Iterator[RowRecord]:\n        \"\"\"Apply a function filter to rows in the Table or FeatureClass\n\n        Args:\n            func (Callable[[dict[str, Any]], bool]): A callable that takes a \n                row dictionary and returns True or False\n            invert (bool): Invert the function. Only yield rows that return `False`\n\n        Yields:\n            ( dict[str, Any] ): Rows in the Table or FeatureClass that match the filter (or inverted filter)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; def area_filter(row: dict) -&gt; bool:\n            &gt;&gt;&gt;     return row['Area'] &gt;= 10\n\n            &gt;&gt;&gt; for row in fc:\n            &gt;&gt;&gt;     print(row['Area'])\n            1\n            2\n            10\n            &lt;etc&gt;\n\n            &gt;&gt;&gt; for row in fc.filter(area_filter):\n            &gt;&gt;&gt;     print(row['Area'])\n            10\n            11\n            90\n            &lt;etc&gt;\n            ```\n\n        \"\"\"\n        if hasattr(func, 'fields'): # Allow decorated filters for faster iteration (see `filter_fields`)\n            with self.fields_as(*getattr(func, 'fields')):\n                yield from (row for row in self if func(row) == (not invert))\n        else:\n            yield from (row for row in self if func(row) == (not invert))\n\n    # Data Operations\n\n    def write_attribute_rules(self, out_dir: Path|str) -&gt; None:\n        \"\"\"Write attribute rules out to a structured directory\n\n        Note:\n            out_dir -&gt; fc_name -&gt; [rule_name.cfg, rule_name.js]\n        \"\"\"\n        out_dir = Path(out_dir)\n        for rule_name, rule in self.attribute_rules.items():\n            _script: str = rule['scriptExpression']\n            _cfg = {k:v for k,v in rule.items() if k not in ('scriptExpression',)}\n            out_file = out_dir / self.name / rule_name\n            out_file.with_suffix('.js').write_text(_script)\n            out_file.with_suffix('.cfg').write_text(json.dumps(_cfg, indent=2))\n        return\n\n    def copy(self, workspace: str, options: bool=True) -&gt; Self:\n        \"\"\"Copy this `Table` or `FeatureClass` to a new workspace\n\n        Args:\n            workspace (str): The path to the workspace\n            options (bool): Copy the cursor options to the new `Table` or `FeatureClass` (default: `True`)\n\n        Returns:\n            (Table or FeatureClass): A `Table` or `FeatureClass` instance of the copied features\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_fc = fc.copy('workspace2')\n            &gt;&gt;&gt; new_fc == fc\n            False\n            ```\n        \"\"\"\n        name = Path(self.path).relative_to(Path(self.workspace))\n        if Exists(copy_fc := Path(workspace) / name):\n            raise ValueError(f'{name} already exists in {workspace}!')\n        CopyFeatures(self.path, str(copy_fc))\n        fc = self.__class__(str(copy_fc))\n        if options:\n            fc.search_options = self.search_options\n            fc.update_options = self.update_options\n            fc.insert_options = self.insert_options\n            fc.clause = self.clause\n        return fc\n\n    def exists(self) -&gt; bool:\n        \"\"\"Check if the Table or FeatureClass actually exists (check for deletion or initialization with bad path)\"\"\"\n        return Exists(str(self))\n\n    def has_field(self, fieldname: str) -&gt; bool:\n        \"\"\"Check if the field exists in the featureclass or is a valid Token (@[TOKEN])\"\"\"\n        return fieldname in self.fields or fieldname in self.Tokens\n\n    def add_field(self, fieldname: str, field: Field|None=None, **options: Unpack[Field]) -&gt; None:\n        \"\"\"Add a new field to a Table or FeatureClass, if no type is provided, deafault of `VARCHAR(255)` is used\n\n        Args:\n            fieldname (str): The name of the new field (must not start with a number and be alphanum or underscored)\n            field (Field): A Field object that contains the desired field properties\n            **options (**Field): Allow passing keyword arguments for field directly (Overrides field arg)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_field = Field(\n            ...     field_alias='Abbreviated Month',\n            ...     field_type='TEXT',\n            ...     field_length='3',\n            ...     field_domain='Months_ABBR',\n            ... )\n\n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name', 'year']\n\n            &gt;&gt;&gt; fc['month'] = new_field\n            &gt;&gt;&gt; fc2['month'] = new_field # Can re-use a field definition \n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name', 'year', 'month']\n            ```\n        \"\"\"\n        if self.has_field(fieldname):\n            raise ValueError(f'{self.name} already has a field called {fieldname}!')\n\n        # Use provided field or default to 'TEXT' and override with kwargs\n        field = {**(field or Field(field_type='TEXT')), **options}\n\n        # Handle malformed Field arg\n        field['field_type'] = field.get('field_type', 'TEXT')\n\n        _option_kwargs = set(Field.__optional_keys__) | set(Field.__required_keys__)\n        _provided = set(field.keys())\n\n        if not _provided &lt;= _option_kwargs:\n            raise ValueError(f\"Unknown Field properties provided: {_provided - _option_kwargs}\")\n\n        if not valid_field(fieldname):\n            raise ValueError(\n                f\"{fieldname} is invalid, fieldnames must not start with a number \"\n                \"and must only contain alphanumeric characters and underscores\"\n            )\n\n        with EnvManager(workspace=self.workspace):\n            AddField(self.path, fieldname, **field)\n            self._fields = None\n\n    def add_fields(self, fields: dict[str, Field]) -&gt; None:\n        \"\"\"Provide a mapping of fieldnames to Fields\n\n        Args:\n            fields (dict[str, Field]): A mapping of fieldnames to Field objects\n\n        Example:\n            ```python\n            &gt;&gt;&gt; fields = {'f1': Field(...), 'f2': Field(...)}\n            &gt;&gt;&gt; fc.add_fields(fields)\n            &gt;&gt;&gt; fc.fields\n            ['OID@', 'SHAPE@', 'f1', 'f2']\n            ```\n        \"\"\"\n        for fieldname, field in fields.items():\n            self.add_field(fieldname, field)\n\n    def delete_field(self, fieldname: str) -&gt; None:\n        \"\"\"Delete a field from a Table or FeatureClass\n\n        Args:\n            fieldname (str): The name of the field to delete/drop\n\n        Example:\n            ```python\n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name', 'year', 'month']\n\n            &gt;&gt;&gt; del fc['month']\n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name', 'year']\n            &gt;&gt;&gt; fc.delete_field('year')\n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name']\n            ```\n        \"\"\"\n        if fieldname in self.Tokens:\n            raise ValueError(f\"{fieldname} is a Token and cannot be deleted!\")\n        if not self.has_field(fieldname):\n            raise ValueError(f\"{fieldname} does not exist in {self.name}\")\n        with EnvManager(workspace=self.workspace):\n            DeleteField(self.path, fieldname)\n            self._fields = None # Defer new field check to next access\n\n    def delete_fields(self, fieldnames: Sequence[str]) -&gt; None:\n        for fname in fieldnames:\n            self.delete_field(fname)\n\n    # Magic Methods\n\n    if TYPE_CHECKING:\n\n        _OVERLOAD_TYPES = (\n            FieldName | set[FieldName] | list[FieldName] | tuple[FieldName, ...] | \n            FilterFunc | WhereClause | None\n        )\n\n        @overload\n        def __getitem__(self, field: tuple[FieldName, ...]) -&gt; Iterator[tuple[Any, ...]]:\n            \"\"\"Yield tuples of the requested field values\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: list[FieldName]) -&gt; Iterator[list[Any]]:\n            \"\"\"Yield lists of the requested field values\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: set[FieldName]) -&gt; Iterator[RowRecord]:\n            \"\"\"Yield dictionaries of the requested field values\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: FieldName) -&gt; Iterator[Any]:\n            \"\"\"Yield values from the requested field\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: FilterFunc) -&gt; Iterator[RowRecord]:\n            \"\"\"Yield dictionaries of the rows that match the filter function\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: WhereClause) -&gt; Iterator[RowRecord]:\n            \"\"\"Yield values that match the provided WhereClause SQL statement\"\"\"\n            pass\n\n        @overload\n        def __getitem__(self, field: None) -&gt; Iterator[None]:\n            \"\"\"Yield nothing (used as fallback if an indexing argument is None)\"\"\"\n            pass\n\n    def __getitem__(self, field: _OVERLOAD_TYPES) -&gt; Iterator[Any]:\n        \"\"\"Handle all defined overloads using pattern matching syntax\n\n        Args:\n            field (str): Yield values in the specified column (values only)\n            field (list[str]): Yield lists of values for requested columns (requested fields)\n            field (tuple[str]): Yield tuples of values for requested columns (requested fields)\n            field (set[str]): Yield dictionaries of values for requested columns (requested fields)\n            field (FilterFunc): Yield rows that match function (all fields)\n            field (WhereClause): Yield rows that match clause (all fields)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; # Single Field\n            &gt;&gt;&gt; print(list(fc['field']))\n            [val1, val2, val3, ...]\n\n            &gt;&gt;&gt; # Field Tuple\n            &gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n            [(val1, val2), (val1, val2), ...]\n\n            &gt;&gt;&gt; # Field List\n            &gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n            [[val1, val2], [val1, val2], ...]\n\n            &gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n            &gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n            [{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n            &gt;&gt;&gt; # Last two options always return all fields in a mapping\n            &gt;&gt;&gt; # Filter Function (passed to Table.filter())\n            &gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n            &gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # None (Empty Iterator)\n            &gt;&gt;&gt; print(list(fc[None]))\n\n            ```\n        \"\"\"\n        match field:\n            # Field Requests\n            case str():\n                with self.search_cursor(field) as cur:\n                    yield from (val for val, in cur)\n            case tuple():\n                with self.search_cursor(field) as cur:\n                    yield from (row for row in cur)\n            case list():\n                with self.search_cursor(field) as cur:\n                    yield from (list(row) for row in cur)\n            case set():\n                with self.search_cursor(list(field)) as cur:\n                    yield from (row for row in as_dict(cur))\n            case None:\n                yield from () # This allows a side effect None to be used to get nothing\n\n            # Conditional Requests\n            case wc if isinstance(wc, WhereClause):\n                if not wc.validate(self.fields):\n                    raise AttributeError(f'Invalid Where Clause: {wc}, fields not found in {self.name}')\n                with self.search_cursor(self.fields, where_clause=wc.where_clause) as cur:\n                    yield from (row for row in as_dict(cur))\n            case func if callable(func):\n                yield from (row for row in self.filter(func))\n            case _:\n                raise KeyError(\n                    f\"Invalid option: `{field}` \"\n                    \"Must be a WhereClause, filter functon, field, set of fields, list of fields, or tuple of fields\"\n                )\n\n    def __contains__(self, field: str) -&gt; bool:\n        \"\"\"Implementation of contains that checks for a field existing in the `FeatureClass`\n        \"\"\"\n        return field in self.fields\n\n\n    def __iter__(self) -&gt; Iterator[dict[str, Any]] | Iterator[Any]:\n        \"\"\"Iterate all rows in the Table or FeatureClass yielding mappings of field name to field value\n\n        Note:\n            It was decided to yield mappings because without specifying fields, it is up to the user\n            to deal with the data as they see fit. Yielding tuples in an order that's not defined by\n            the user would be confusing, so a mapping makes it clear exactly what they're accessing\n\n        Note:\n            When a single field is specified using the `fields_as` context, values will be yielded\n        \"\"\" \n        with self.search_cursor(self.fields) as cur:\n            if len(self.fields) == 1:\n                yield from (row for row, in cur)\n            else:\n                yield from as_dict(cur)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Iterate all rows and count them. Only count with `self.search_options` queries.\n\n        Note:\n            The `__format__('len')` spec calls this function. So `len(fc)` and `f'{fc:len}'` are the same, \n            with the caveat that the format spec option returns a string\n\n        Warning:\n            This operation will traverse the whole dataset when called! You should not use it in loops:\n            ```python\n            # Bad\n            for i, _ in enumerate(fc):\n                print(f'{i}/{len(fc)}')\n\n            # Good\n            count = len(fc)\n            for i, _ in enumerate(fc):\n                print(f'{i}/{count}')\n            ```\n        \"\"\"\n        return sum(1 for _ in self['OID@'])\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Provide a constructor string e.g. `Table or FeatureClass[Polygon]('path')`\"\"\"\n        return f\"{self.__class__.__name__}('{self.__fspath__()}')\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the `Table` or `FeatureClass` path for use with other arcpy methods\"\"\"\n        return self.__fspath__()\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"Determine if the datasource of two featureclass objects is the same\"\"\"\n        return isinstance(other, self.__class__) and self.__fspath__() == other.__fspath__()\n\n    def __format__(self, format_spec: str) -&gt; str:\n        \"\"\"Implement format specs for string formatting a featureclass.\n\n        Warning:\n            The `{fc:len}` spec should only be used when needed. This spec will call `__len__` when \n            used and will traverse the entire Table or FeatureClass with applied SearchOptions each time it is \n            called. See: `__len__` doc for info on better ways to track counts in loops.\n\n        Args:\n            path|pth  : Table or FeatureClass path\n            len|length: Table or FeatureClass length (with applied SearchQuery)\n            layer|lyr : Linked Table or FeatureClass layer if applicable (else `'None'`)\n            shape|shp : Table or FeatureClass shape type\n            units|unt : Table or FeatureClass linear unit name\n            wkid|code : Table or FeatureClass WKID\n            name|nm   : Table or FeatureClass name\n            fields|fld: Table or FeatureClass fields (comma seperated)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; f'{fc:wkid}'\n            '2236'\n            &gt;&gt;&gt; f'{fc:path}'\n            'C:\\\\&lt;FeaturePath&gt;'\n            &gt;&gt;&gt; f'{fc:len}'\n            '101'\n            &gt;&gt;&gt; f'{fc:shape}'\n            'Polygon'\n            ```\n        \"\"\"\n        match format_spec:\n            case 'path' | 'pth':\n                return self.path\n            case 'len' | 'length':\n                return str(len(self))\n            case 'layer' | 'lyr':\n                return self.layer.longName if self.layer else 'None'\n            case 'name' | 'nm':\n                return self.name\n            case 'fields' | 'flds':\n                return ','.join(self.fields)\n            case _:\n                return str(self)\n\n    def __fspath__(self) -&gt; str:\n        return str(Path(self.path).resolve())\n\n    def __hash__(self) -&gt; int:\n        return hash(self.__fspath__())\n\n    # Handle Fields\n\n    def __delitem__(self, fieldname: str) -&gt; None:\n        self.delete_field(fieldname)\n\n    def __setitem__(self, fieldname: str, field: Field) -&gt; None:\n        self.add_field(fieldname, **field)\n\n    # Context Managers\n\n    @contextmanager\n    def fields_as(self, *fields: FieldName):\n        \"\"\"Override the default fields for the Table or FeatureClass so all non-explicit Iterators will\n        only yield these fields (e.g. `for row in fc: ...`)\n\n        Args:\n            *fields (FieldName): Varargs of the fieldnames to limit all unspecified Iterators to\n\n        Example:\n            ```python\n            &gt;&gt;&gt; with fc.fields_as('OID@', 'NAME'):\n            ...     for row in fc:\n            ...         print(row)\n            {'OID@': 1, 'NAME': 'John'}\n            {'OID@': 2, 'NAME': 'Michael'}\n            ...\n            &gt;&gt;&gt; for row in fc:\n            ...     print(row)\n            {'OID@': 1, 'NAME': 'John', 'AGE': 75, 'ADDRESS': 123 Silly Walk}\n            {'OID@': 2, 'NAME': 'Michael', 'AGE': 70, 'ADDRESS': 42 Dead Parrot Blvd}\n            ...\n            ```\n        \"\"\"\n        # Allow passing a single field as a string `fc.fields_as('OID@')` to maintain\n        # The call format of *Cursor objects\n        _fields = self.fields\n        self._fields = tuple(fields)\n        try:\n            yield self\n        finally:\n            self._fields = _fields\n\n    @contextmanager\n    def options(self,\n                *, \n                strict: bool = False,\n                search_options: SearchOptions|None=None, \n                update_options: UpdateOptions|None=None, \n                insert_options: InsertOptions|None=None, \n                clause: SQLClause|None=None):\n        \"\"\"Enter a context block where the supplied options replace the stored options for the `Table` or `FeatureClass`\n\n        Args:\n            strict (bool): If this is set to `True` the `Table` or `FeatureClass` will not fallback on existing options\n                when set to `False`, provided options override existing options (default: `False`)\n            search_options (SearchOptions): Contextual search overrides\n            update_options (UpdateOptions): Contextual update overrides\n            insert_options (InsertOptions): Contextual insert overrides\n            clause (SQLClause): Contextual `sql_clause` override\n        \"\"\"\n        _src_ops = self.search_options\n        _upd_ops = self.update_options\n        _ins_ops = self.insert_options\n        _clause  = self.clause\n        try:\n            self._search_options = (\n                self._resolve_search_options(_src_ops, search_options or {}) \n                if not strict\n                else search_options or SearchOptions()\n            )\n            self._update_options = (\n                self._resolve_update_options(_upd_ops, update_options or {})\n                if not strict \n                else insert_options or UpdateOptions()\n            )\n            self._insert_options = (\n                self._resolve_insert_options(_ins_ops, insert_options or {})\n                if not strict \n                else insert_options or InsertOptions()\n            )\n            self._clause = (\n                clause or _clause\n                if not strict \n                else SQLClause(None, None)\n            )\n            yield self\n\n        finally:\n            self._search_options = _src_ops\n            self._update_options = _upd_ops\n            self.insert_options = _ins_ops\n            self._clause = _clause\n\n    @contextmanager\n    def where(self, where_clause: str):\n        \"\"\"Apply a where clause to a Table or FeatureClass in a context\n\n        Args:\n            where_clause (str): The where clause to apply to the Table or FeatureClass\n\n        Example:\n            ```python\n            &gt;&gt;&gt; with fc.where(\"first = 'John'\") as f:\n            ...     for f in fc:\n            ...         print(f)\n            {'first': 'John', 'last': 'Cleese', 'year': 1939}\n\n            &gt;&gt;&gt; with fc.where('year &gt; 1939'):\n            ...     print(len(fc))\n            5\n            ... print(len(fc))\n            6\n            ```\n\n        Note:\n            This method of filtering a Table or FeatureClass will always be more performant than using the \n            `.filter` method. If you can achieve the filtering you want with a where clause, do it.\n        \"\"\"\n        with self.options(\n            search_options=SearchOptions(where_clause=where_clause)):\n            yield self\n\n    # Mapping interfaces (These pass common `Layer` operations up to the Table or FeatureClass)\n    def bind_to_layer(self, layer: Layer) -&gt; None:\n        \"\"\"Update the provided layer's datasource to this Table or FeatureClass\n\n        Args:\n            layer (Layer): The layer to update connection properties for\n        \"\"\"\n        layer.updateConnectionProperties(layer.dataSource, self.path) #type:ignore\n\n    def add_to_map(self, map: Map, pos: Literal['AUTO_ARRANGE', 'BOTTOM', 'TOP']='AUTO_ARRANGE') -&gt; None:\n        \"\"\"Add the featureclass to a map\n\n        Note: \n            If the Table or FeatureClass has a layer, the bound layer will be added to the map. \n            Otherwise a default layer will be added. And the new layer will be bound to the Table or FeatureClass\n\n        Args:\n            mp (Map): The map to add the featureclass to\n        \"\"\"\n        if not self.layer:\n            # Create a default layer, bind it, remove, and add back\n            # with addLayer to match behavior with existing bound layer\n            self.layer = map.addDataFromPath(self.path) #type:ignore (Always Layer)\n            map.removeLayer(self.layer) #type:ignore (Incorrect Signature)\n        map.addLayer(self.layer, pos) #type:ignore\n\n    def select(self, method: Literal['NEW','DIFFERENCE','INTERSECT','SYMDIFFERENCE','UNION']='NEW') -&gt; None:\n        \"\"\"If the Table or FeatureClass is bound to a layer, update the layer selection with the active SearchOptions\n\n        Args:\n            method: The method to use to apply the selection\\n\n                `DIFFERENCE`: Selects the features that are not in the current selection but are in the Table or FeatureClass.\\n\n                `INTERSECT`: Selects the features that are in the current selection and the Table or FeatureClass.\\n\n                `NEW`: Creates a new feature selection from the Table or FeatureClass.\\n\n                `SYMDIFFERENCE`: Selects the features that are in the current selection or the Table or FeatureClass but not both.\\n\n                `UNION`: Selects all the features in both the current selection and those in Table or FeatureClass.\\n\n\n        Note:\n            Selection changes require the project file to be saved to take effect. \n        \"\"\"\n        if self.layer:\n            _selected = list(self['OID@'])\n            self.layer.setSelectionSet(_selected, method=method)\n            try: # Try to select the layer in the active map\n                if len(_selected) == 1:\n                    _query = f'{self.oid_field_name} = {_selected.pop()})'\n                if len(_selected) &gt; 1:\n                    _query = f'{self.oid_field_name} IN ({format_query_list(_selected)})'\n                else:\n                    return\n                SelectLayerByAttribute(self.layer.longName, 'NEW_SELECTION', _query)\n            except Exception:\n                return\n\n    def unselect(self) -&gt; None:\n        \"\"\"If the Table or FeatureClass is bound to a layer, Remove layer selection\n\n        Note:\n            Selection changes require the project file to be saved to take effect.\n        \"\"\"\n        if self.layer:\n            self.layer.setSelectionSet(method='NEW')\n            try: # Try to unselect the layer in the active map\n                SelectLayerByAttribute(self.layer.longName, 'CLEAR_SELECTION')\n            except Exception:\n                return\n\n    # Factory Constructors\n    @classmethod\n    def from_table(cls, table: TableLayer,\n                   *,\n                   ignore_selection: bool = False,\n                   ignore_def_query: bool = False,) -&gt; Table:\n        \"\"\"See `from_layer` for documentation, this is an alternative constructor that builds from a mp.Table object\"\"\"\n        return Table.from_layer(table, ignore_selection=ignore_selection, ignore_def_query=ignore_def_query) # type: ignore (this won't break the interface)\n\n    @classmethod\n    def from_layer(cls, layer: Layer,\n                   *,\n                   ignore_selection: bool = False,\n                   ignore_def_query: bool = False,) -&gt; Table:\n        \"\"\"Build a Table or FeatureClass object from a layer applying the layer's current selection to the stored cursors\n\n        Args:\n            layer (Layer): The layer to convert to a Table or FeatureClass\n            ignore_selection (bool): Ignore the layer selection (default: False)\n            ignore_definition_query (bool): Ignore the layer definition query (default: False)\n        Returns:\n            ( Table or FeatureClass ): The Table or FeatureClass object with the layer query applied\n        \"\"\"\n        fc = cls(layer.dataSource)\n\n        selected_ids: set[int] | None = (\n            layer.getSelectionSet() or None\n            if not ignore_selection \n            else None\n        )\n        definition_query: str|None = (\n            layer.definitionQuery or None\n            if not ignore_def_query \n            else None\n        )\n        selection: str|None = (\n            f\"{fc.oid_field_name} IN ({format_query_list(selected_ids)})\" \n            if selected_ids \n            else None\n        )\n\n        if (query_components := list(filter(None, [definition_query, selection]))):\n            where_clause = ' AND '.join(query_components)\n            fc.search_options = SearchOptions(where_clause=where_clause)\n            fc.update_options = UpdateOptions(where_clause=where_clause)\n\n        fc.layer = layer\n        return fc\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.attribute_rules","title":"<code>attribute_rules</code>  <code>property</code>","text":"<p>Get FeatureClass attribute rules access by name</p>"},{"location":"featureclass/#arcpie.featureclass.Table.da_describe","title":"<code>da_describe</code>  <code>property</code>","text":"<p>Access the da.Describe dictionary for the <code>Table</code> or <code>FeatureClass</code></p>"},{"location":"featureclass/#arcpie.featureclass.Table.describe","title":"<code>describe</code>  <code>property</code>","text":"<p>Access the arcpy.Describe object for the <code>Table</code> or <code>FeatureClass</code></p>"},{"location":"featureclass/#arcpie.featureclass.Table.editor","title":"<code>editor</code>  <code>property</code>","text":"<p>Get an Editor manager for the Table or FeatureClass Will set multiuser_mode to True if the feature can version</p>"},{"location":"featureclass/#arcpie.featureclass.Table.fields","title":"<code>fields</code>  <code>property</code>","text":"<p>Tuple of all fieldnames in the Table or FeatureClass with <code>OID@</code> as first</p>"},{"location":"featureclass/#arcpie.featureclass.Table.py_types","title":"<code>py_types</code>  <code>property</code>","text":"<p>Get a mapping of fieldnames to python types for the Table</p>"},{"location":"featureclass/#arcpie.featureclass.Table.subtypes","title":"<code>subtypes</code>  <code>property</code>","text":"<p>Result of ListSubtypes, mapping of code to Subtype object</p>"},{"location":"featureclass/#arcpie.featureclass.Table.workspace","title":"<code>workspace</code>  <code>property</code>","text":"<p>Get the workspace of the <code>Table</code> or <code>FeatureClass</code></p>"},{"location":"featureclass/#arcpie.featureclass.Table.__contains__","title":"<code>__contains__(field)</code>","text":"<p>Implementation of contains that checks for a field existing in the <code>FeatureClass</code></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __contains__(self, field: str) -&gt; bool:\n    \"\"\"Implementation of contains that checks for a field existing in the `FeatureClass`\n    \"\"\"\n    return field in self.fields\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Determine if the datasource of two featureclass objects is the same</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Determine if the datasource of two featureclass objects is the same\"\"\"\n    return isinstance(other, self.__class__) and self.__fspath__() == other.__fspath__()\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.__format__","title":"<code>__format__(format_spec)</code>","text":"<p>Implement format specs for string formatting a featureclass.</p> Warning <p>The <code>{fc:len}</code> spec should only be used when needed. This spec will call <code>__len__</code> when  used and will traverse the entire Table or FeatureClass with applied SearchOptions each time it is  called. See: <code>__len__</code> doc for info on better ways to track counts in loops.</p> <p>Parameters:</p> Name Type Description Default <code>path|pth  </code> <p>Table or FeatureClass path</p> required <code>len|length</code> <p>Table or FeatureClass length (with applied SearchQuery)</p> required <code>layer|lyr </code> <p>Linked Table or FeatureClass layer if applicable (else <code>'None'</code>)</p> required <code>shape|shp </code> <p>Table or FeatureClass shape type</p> required <code>units|unt </code> <p>Table or FeatureClass linear unit name</p> required <code>wkid|code </code> <p>Table or FeatureClass WKID</p> required <code>name|nm   </code> <p>Table or FeatureClass name</p> required <code>fields|fld</code> <p>Table or FeatureClass fields (comma seperated)</p> required Example <pre><code>&gt;&gt;&gt; f'{fc:wkid}'\n'2236'\n&gt;&gt;&gt; f'{fc:path}'\n'C:\\&lt;FeaturePath&gt;'\n&gt;&gt;&gt; f'{fc:len}'\n'101'\n&gt;&gt;&gt; f'{fc:shape}'\n'Polygon'\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __format__(self, format_spec: str) -&gt; str:\n    \"\"\"Implement format specs for string formatting a featureclass.\n\n    Warning:\n        The `{fc:len}` spec should only be used when needed. This spec will call `__len__` when \n        used and will traverse the entire Table or FeatureClass with applied SearchOptions each time it is \n        called. See: `__len__` doc for info on better ways to track counts in loops.\n\n    Args:\n        path|pth  : Table or FeatureClass path\n        len|length: Table or FeatureClass length (with applied SearchQuery)\n        layer|lyr : Linked Table or FeatureClass layer if applicable (else `'None'`)\n        shape|shp : Table or FeatureClass shape type\n        units|unt : Table or FeatureClass linear unit name\n        wkid|code : Table or FeatureClass WKID\n        name|nm   : Table or FeatureClass name\n        fields|fld: Table or FeatureClass fields (comma seperated)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; f'{fc:wkid}'\n        '2236'\n        &gt;&gt;&gt; f'{fc:path}'\n        'C:\\\\&lt;FeaturePath&gt;'\n        &gt;&gt;&gt; f'{fc:len}'\n        '101'\n        &gt;&gt;&gt; f'{fc:shape}'\n        'Polygon'\n        ```\n    \"\"\"\n    match format_spec:\n        case 'path' | 'pth':\n            return self.path\n        case 'len' | 'length':\n            return str(len(self))\n        case 'layer' | 'lyr':\n            return self.layer.longName if self.layer else 'None'\n        case 'name' | 'nm':\n            return self.name\n        case 'fields' | 'flds':\n            return ','.join(self.fields)\n        case _:\n            return str(self)\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.__getitem__","title":"<code>__getitem__(field)</code>","text":"<pre><code>__getitem__(field: tuple[FieldName, ...]) -&gt; Iterator[tuple[Any, ...]]\n</code></pre><pre><code>__getitem__(field: list[FieldName]) -&gt; Iterator[list[Any]]\n</code></pre><pre><code>__getitem__(field: set[FieldName]) -&gt; Iterator[RowRecord]\n</code></pre><pre><code>__getitem__(field: FieldName) -&gt; Iterator[Any]\n</code></pre><pre><code>__getitem__(field: FilterFunc) -&gt; Iterator[RowRecord]\n</code></pre><pre><code>__getitem__(field: WhereClause) -&gt; Iterator[RowRecord]\n</code></pre><pre><code>__getitem__(field: None) -&gt; Iterator[None]\n</code></pre> <p>Handle all defined overloads using pattern matching syntax</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>Yield values in the specified column (values only)</p> required <code>field</code> <code>list[str]</code> <p>Yield lists of values for requested columns (requested fields)</p> required <code>field</code> <code>tuple[str]</code> <p>Yield tuples of values for requested columns (requested fields)</p> required <code>field</code> <code>set[str]</code> <p>Yield dictionaries of values for requested columns (requested fields)</p> required <code>field</code> <code>FilterFunc</code> <p>Yield rows that match function (all fields)</p> required <code>field</code> <code>WhereClause</code> <p>Yield rows that match clause (all fields)</p> required Example <pre><code>&gt;&gt;&gt; # Single Field\n&gt;&gt;&gt; print(list(fc['field']))\n[val1, val2, val3, ...]\n\n&gt;&gt;&gt; # Field Tuple\n&gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n[(val1, val2), (val1, val2), ...]\n\n&gt;&gt;&gt; # Field List\n&gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n[[val1, val2], [val1, val2], ...]\n\n&gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n&gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n[{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n&gt;&gt;&gt; # Last two options always return all fields in a mapping\n&gt;&gt;&gt; # Filter Function (passed to Table.filter())\n&gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n&gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # None (Empty Iterator)\n&gt;&gt;&gt; print(list(fc[None]))\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __getitem__(self, field: _OVERLOAD_TYPES) -&gt; Iterator[Any]:\n    \"\"\"Handle all defined overloads using pattern matching syntax\n\n    Args:\n        field (str): Yield values in the specified column (values only)\n        field (list[str]): Yield lists of values for requested columns (requested fields)\n        field (tuple[str]): Yield tuples of values for requested columns (requested fields)\n        field (set[str]): Yield dictionaries of values for requested columns (requested fields)\n        field (FilterFunc): Yield rows that match function (all fields)\n        field (WhereClause): Yield rows that match clause (all fields)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # Single Field\n        &gt;&gt;&gt; print(list(fc['field']))\n        [val1, val2, val3, ...]\n\n        &gt;&gt;&gt; # Field Tuple\n        &gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n        [(val1, val2), (val1, val2), ...]\n\n        &gt;&gt;&gt; # Field List\n        &gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n        [[val1, val2], [val1, val2], ...]\n\n        &gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n        &gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n        [{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n        &gt;&gt;&gt; # Last two options always return all fields in a mapping\n        &gt;&gt;&gt; # Filter Function (passed to Table.filter())\n        &gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n        &gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # None (Empty Iterator)\n        &gt;&gt;&gt; print(list(fc[None]))\n\n        ```\n    \"\"\"\n    match field:\n        # Field Requests\n        case str():\n            with self.search_cursor(field) as cur:\n                yield from (val for val, in cur)\n        case tuple():\n            with self.search_cursor(field) as cur:\n                yield from (row for row in cur)\n        case list():\n            with self.search_cursor(field) as cur:\n                yield from (list(row) for row in cur)\n        case set():\n            with self.search_cursor(list(field)) as cur:\n                yield from (row for row in as_dict(cur))\n        case None:\n            yield from () # This allows a side effect None to be used to get nothing\n\n        # Conditional Requests\n        case wc if isinstance(wc, WhereClause):\n            if not wc.validate(self.fields):\n                raise AttributeError(f'Invalid Where Clause: {wc}, fields not found in {self.name}')\n            with self.search_cursor(self.fields, where_clause=wc.where_clause) as cur:\n                yield from (row for row in as_dict(cur))\n        case func if callable(func):\n            yield from (row for row in self.filter(func))\n        case _:\n            raise KeyError(\n                f\"Invalid option: `{field}` \"\n                \"Must be a WhereClause, filter functon, field, set of fields, list of fields, or tuple of fields\"\n            )\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate all rows in the Table or FeatureClass yielding mappings of field name to field value</p> Note <p>It was decided to yield mappings because without specifying fields, it is up to the user to deal with the data as they see fit. Yielding tuples in an order that's not defined by the user would be confusing, so a mapping makes it clear exactly what they're accessing</p> Note <p>When a single field is specified using the <code>fields_as</code> context, values will be yielded</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __iter__(self) -&gt; Iterator[dict[str, Any]] | Iterator[Any]:\n    \"\"\"Iterate all rows in the Table or FeatureClass yielding mappings of field name to field value\n\n    Note:\n        It was decided to yield mappings because without specifying fields, it is up to the user\n        to deal with the data as they see fit. Yielding tuples in an order that's not defined by\n        the user would be confusing, so a mapping makes it clear exactly what they're accessing\n\n    Note:\n        When a single field is specified using the `fields_as` context, values will be yielded\n    \"\"\" \n    with self.search_cursor(self.fields) as cur:\n        if len(self.fields) == 1:\n            yield from (row for row, in cur)\n        else:\n            yield from as_dict(cur)\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.__len__","title":"<code>__len__()</code>","text":"<p>Iterate all rows and count them. Only count with <code>self.search_options</code> queries.</p> Note <p>The <code>__format__('len')</code> spec calls this function. So <code>len(fc)</code> and <code>f'{fc:len}'</code> are the same,  with the caveat that the format spec option returns a string</p> Warning <p>This operation will traverse the whole dataset when called! You should not use it in loops: <pre><code># Bad\nfor i, _ in enumerate(fc):\n    print(f'{i}/{len(fc)}')\n\n# Good\ncount = len(fc)\nfor i, _ in enumerate(fc):\n    print(f'{i}/{count}')\n</code></pre></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Iterate all rows and count them. Only count with `self.search_options` queries.\n\n    Note:\n        The `__format__('len')` spec calls this function. So `len(fc)` and `f'{fc:len}'` are the same, \n        with the caveat that the format spec option returns a string\n\n    Warning:\n        This operation will traverse the whole dataset when called! You should not use it in loops:\n        ```python\n        # Bad\n        for i, _ in enumerate(fc):\n            print(f'{i}/{len(fc)}')\n\n        # Good\n        count = len(fc)\n        for i, _ in enumerate(fc):\n            print(f'{i}/{count}')\n        ```\n    \"\"\"\n    return sum(1 for _ in self['OID@'])\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.__repr__","title":"<code>__repr__()</code>","text":"<p>Provide a constructor string e.g. <code>Table or FeatureClass[Polygon]('path')</code></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Provide a constructor string e.g. `Table or FeatureClass[Polygon]('path')`\"\"\"\n    return f\"{self.__class__.__name__}('{self.__fspath__()}')\"\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.__str__","title":"<code>__str__()</code>","text":"<p>Return the <code>Table</code> or <code>FeatureClass</code> path for use with other arcpy methods</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the `Table` or `FeatureClass` path for use with other arcpy methods\"\"\"\n    return self.__fspath__()\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.add_field","title":"<code>add_field(fieldname, field=None, **options)</code>","text":"<p>Add a new field to a Table or FeatureClass, if no type is provided, deafault of <code>VARCHAR(255)</code> is used</p> <p>Parameters:</p> Name Type Description Default <code>fieldname</code> <code>str</code> <p>The name of the new field (must not start with a number and be alphanum or underscored)</p> required <code>field</code> <code>Field</code> <p>A Field object that contains the desired field properties</p> <code>None</code> <code>**options</code> <code>**Field</code> <p>Allow passing keyword arguments for field directly (Overrides field arg)</p> <code>{}</code> Example <pre><code>&gt;&gt;&gt; new_field = Field(\n...     field_alias='Abbreviated Month',\n...     field_type='TEXT',\n...     field_length='3',\n...     field_domain='Months_ABBR',\n... )\n\n&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name', 'year']\n\n&gt;&gt;&gt; fc['month'] = new_field\n&gt;&gt;&gt; fc2['month'] = new_field # Can re-use a field definition \n&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name', 'year', 'month']\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def add_field(self, fieldname: str, field: Field|None=None, **options: Unpack[Field]) -&gt; None:\n    \"\"\"Add a new field to a Table or FeatureClass, if no type is provided, deafault of `VARCHAR(255)` is used\n\n    Args:\n        fieldname (str): The name of the new field (must not start with a number and be alphanum or underscored)\n        field (Field): A Field object that contains the desired field properties\n        **options (**Field): Allow passing keyword arguments for field directly (Overrides field arg)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_field = Field(\n        ...     field_alias='Abbreviated Month',\n        ...     field_type='TEXT',\n        ...     field_length='3',\n        ...     field_domain='Months_ABBR',\n        ... )\n\n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name', 'year']\n\n        &gt;&gt;&gt; fc['month'] = new_field\n        &gt;&gt;&gt; fc2['month'] = new_field # Can re-use a field definition \n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name', 'year', 'month']\n        ```\n    \"\"\"\n    if self.has_field(fieldname):\n        raise ValueError(f'{self.name} already has a field called {fieldname}!')\n\n    # Use provided field or default to 'TEXT' and override with kwargs\n    field = {**(field or Field(field_type='TEXT')), **options}\n\n    # Handle malformed Field arg\n    field['field_type'] = field.get('field_type', 'TEXT')\n\n    _option_kwargs = set(Field.__optional_keys__) | set(Field.__required_keys__)\n    _provided = set(field.keys())\n\n    if not _provided &lt;= _option_kwargs:\n        raise ValueError(f\"Unknown Field properties provided: {_provided - _option_kwargs}\")\n\n    if not valid_field(fieldname):\n        raise ValueError(\n            f\"{fieldname} is invalid, fieldnames must not start with a number \"\n            \"and must only contain alphanumeric characters and underscores\"\n        )\n\n    with EnvManager(workspace=self.workspace):\n        AddField(self.path, fieldname, **field)\n        self._fields = None\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.add_fields","title":"<code>add_fields(fields)</code>","text":"<p>Provide a mapping of fieldnames to Fields</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, Field]</code> <p>A mapping of fieldnames to Field objects</p> required Example <pre><code>&gt;&gt;&gt; fields = {'f1': Field(...), 'f2': Field(...)}\n&gt;&gt;&gt; fc.add_fields(fields)\n&gt;&gt;&gt; fc.fields\n['OID@', 'SHAPE@', 'f1', 'f2']\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def add_fields(self, fields: dict[str, Field]) -&gt; None:\n    \"\"\"Provide a mapping of fieldnames to Fields\n\n    Args:\n        fields (dict[str, Field]): A mapping of fieldnames to Field objects\n\n    Example:\n        ```python\n        &gt;&gt;&gt; fields = {'f1': Field(...), 'f2': Field(...)}\n        &gt;&gt;&gt; fc.add_fields(fields)\n        &gt;&gt;&gt; fc.fields\n        ['OID@', 'SHAPE@', 'f1', 'f2']\n        ```\n    \"\"\"\n    for fieldname, field in fields.items():\n        self.add_field(fieldname, field)\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.add_to_map","title":"<code>add_to_map(map, pos='AUTO_ARRANGE')</code>","text":"<p>Add the featureclass to a map</p> Note <p>If the Table or FeatureClass has a layer, the bound layer will be added to the map.  Otherwise a default layer will be added. And the new layer will be bound to the Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>mp</code> <code>Map</code> <p>The map to add the featureclass to</p> required Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def add_to_map(self, map: Map, pos: Literal['AUTO_ARRANGE', 'BOTTOM', 'TOP']='AUTO_ARRANGE') -&gt; None:\n    \"\"\"Add the featureclass to a map\n\n    Note: \n        If the Table or FeatureClass has a layer, the bound layer will be added to the map. \n        Otherwise a default layer will be added. And the new layer will be bound to the Table or FeatureClass\n\n    Args:\n        mp (Map): The map to add the featureclass to\n    \"\"\"\n    if not self.layer:\n        # Create a default layer, bind it, remove, and add back\n        # with addLayer to match behavior with existing bound layer\n        self.layer = map.addDataFromPath(self.path) #type:ignore (Always Layer)\n        map.removeLayer(self.layer) #type:ignore (Incorrect Signature)\n    map.addLayer(self.layer, pos) #type:ignore\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.bind_to_layer","title":"<code>bind_to_layer(layer)</code>","text":"<p>Update the provided layer's datasource to this Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer to update connection properties for</p> required Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def bind_to_layer(self, layer: Layer) -&gt; None:\n    \"\"\"Update the provided layer's datasource to this Table or FeatureClass\n\n    Args:\n        layer (Layer): The layer to update connection properties for\n    \"\"\"\n    layer.updateConnectionProperties(layer.dataSource, self.path) #type:ignore\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.copy","title":"<code>copy(workspace, options=True)</code>","text":"<p>Copy this <code>Table</code> or <code>FeatureClass</code> to a new workspace</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The path to the workspace</p> required <code>options</code> <code>bool</code> <p>Copy the cursor options to the new <code>Table</code> or <code>FeatureClass</code> (default: <code>True</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>Table or FeatureClass</code> <p>A <code>Table</code> or <code>FeatureClass</code> instance of the copied features</p> Example <pre><code>&gt;&gt;&gt; new_fc = fc.copy('workspace2')\n&gt;&gt;&gt; new_fc == fc\nFalse\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def copy(self, workspace: str, options: bool=True) -&gt; Self:\n    \"\"\"Copy this `Table` or `FeatureClass` to a new workspace\n\n    Args:\n        workspace (str): The path to the workspace\n        options (bool): Copy the cursor options to the new `Table` or `FeatureClass` (default: `True`)\n\n    Returns:\n        (Table or FeatureClass): A `Table` or `FeatureClass` instance of the copied features\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_fc = fc.copy('workspace2')\n        &gt;&gt;&gt; new_fc == fc\n        False\n        ```\n    \"\"\"\n    name = Path(self.path).relative_to(Path(self.workspace))\n    if Exists(copy_fc := Path(workspace) / name):\n        raise ValueError(f'{name} already exists in {workspace}!')\n    CopyFeatures(self.path, str(copy_fc))\n    fc = self.__class__(str(copy_fc))\n    if options:\n        fc.search_options = self.search_options\n        fc.update_options = self.update_options\n        fc.insert_options = self.insert_options\n        fc.clause = self.clause\n    return fc\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.delete_field","title":"<code>delete_field(fieldname)</code>","text":"<p>Delete a field from a Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>fieldname</code> <code>str</code> <p>The name of the field to delete/drop</p> required Example <pre><code>&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name', 'year', 'month']\n\n&gt;&gt;&gt; del fc['month']\n&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name', 'year']\n&gt;&gt;&gt; fc.delete_field('year')\n&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name']\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def delete_field(self, fieldname: str) -&gt; None:\n    \"\"\"Delete a field from a Table or FeatureClass\n\n    Args:\n        fieldname (str): The name of the field to delete/drop\n\n    Example:\n        ```python\n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name', 'year', 'month']\n\n        &gt;&gt;&gt; del fc['month']\n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name', 'year']\n        &gt;&gt;&gt; fc.delete_field('year')\n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name']\n        ```\n    \"\"\"\n    if fieldname in self.Tokens:\n        raise ValueError(f\"{fieldname} is a Token and cannot be deleted!\")\n    if not self.has_field(fieldname):\n        raise ValueError(f\"{fieldname} does not exist in {self.name}\")\n    with EnvManager(workspace=self.workspace):\n        DeleteField(self.path, fieldname)\n        self._fields = None # Defer new field check to next access\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.delete_identical","title":"<code>delete_identical(field_names)</code>","text":"<p>Delete all records that have matching field values</p> <p>Parameters:</p> Name Type Description Default <code>field_names</code> <code>Sequence[FieldName] | FieldName</code> <p>The fields used to define an identical feature</p> required <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>A dictionary of count of identical features deleted per feature</p> Note <p>Insertion order takes precidence unless the Table or FeatureClass is ordered. The first feature found by the cursor will be maintained and all subsequent matches will be removed</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def delete_identical(self, field_names: Sequence[FieldName] | FieldName) -&gt; dict[int, int]:\n    \"\"\"Delete all records that have matching field values\n\n    Args:\n        field_names (Sequence[FieldName] | FieldName): The fields used to define an identical feature\n\n    Returns:\n        (dict[int, int]): A dictionary of count of identical features deleted per feature\n\n    Note:\n        Insertion order takes precidence unless the Table or FeatureClass is ordered. The first feature found\n        by the cursor will be maintained and all subsequent matches will be removed\n    \"\"\"\n    # All\n    if isinstance(field_names, str):\n        field_names = [field_names]\n\n    unique: dict[int, tuple[Any]] = {}\n    deleted: dict[int, int] = {}\n    with self.editor, self.update_cursor(['OID@'] + list(field_names)) as cur:\n        for row in cur:\n            oid: int = row[0]\n            row = tuple(row[1:])\n            for match_id, match_row in unique.items():\n                if all(a == b for a, b in zip(row, match_row)):\n                    match = match_id\n                    break\n            else:\n                match = False\n\n            if not match:\n                unique[oid] = row\n\n            else:\n                deleted.setdefault(match, 0)\n                deleted[match] += 1\n                cur.deleteRow()\n    return deleted\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.distinct","title":"<code>distinct(distinct_fields)</code>","text":"<p>Yield rows of distinct values</p> <p>Parameters:</p> Name Type Description Default <code>distinct_fields</code> <code>FieldOpt</code> <p>The field or fields to find distinct values for. Choosing multiple fields will find all distinct instances of those field combinations</p> required <p>Yields:</p> Type Description <code> tuple[Any, ...] </code> <p>A tuple containing the distinct values (single fields will yield <code>(value, )</code> tuples)</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def distinct(self, distinct_fields: Sequence[FieldName] | FieldName) -&gt; Iterator[tuple[Any, ...]]:\n    \"\"\"Yield rows of distinct values\n\n    Args:\n        distinct_fields (FieldOpt): The field or fields to find distinct values for.\n            Choosing multiple fields will find all distinct instances of those field combinations\n\n    Yields:\n        ( tuple[Any, ...] ): A tuple containing the distinct values (single fields will yield `(value, )` tuples)\n    \"\"\"\n    clause = SQLClause(prefix=f'DISTINCT {format_query_list(distinct_fields)}', postfix=None)\n    try:\n        yield from (value for value in self.search_cursor(distinct_fields, sql_clause=clause))\n    except RuntimeError: # Fallback when DISTINCT is not available or fails with Token input\n        yield from sorted(set(self.get_tuples(distinct_fields)))\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.exists","title":"<code>exists()</code>","text":"<p>Check if the Table or FeatureClass actually exists (check for deletion or initialization with bad path)</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Check if the Table or FeatureClass actually exists (check for deletion or initialization with bad path)\"\"\"\n    return Exists(str(self))\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.fields_as","title":"<code>fields_as(*fields)</code>","text":"<p>Override the default fields for the Table or FeatureClass so all non-explicit Iterators will only yield these fields (e.g. <code>for row in fc: ...</code>)</p> <p>Parameters:</p> Name Type Description Default <code>*fields</code> <code>FieldName</code> <p>Varargs of the fieldnames to limit all unspecified Iterators to</p> <code>()</code> Example <pre><code>&gt;&gt;&gt; with fc.fields_as('OID@', 'NAME'):\n...     for row in fc:\n...         print(row)\n{'OID@': 1, 'NAME': 'John'}\n{'OID@': 2, 'NAME': 'Michael'}\n...\n&gt;&gt;&gt; for row in fc:\n...     print(row)\n{'OID@': 1, 'NAME': 'John', 'AGE': 75, 'ADDRESS': 123 Silly Walk}\n{'OID@': 2, 'NAME': 'Michael', 'AGE': 70, 'ADDRESS': 42 Dead Parrot Blvd}\n...\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef fields_as(self, *fields: FieldName):\n    \"\"\"Override the default fields for the Table or FeatureClass so all non-explicit Iterators will\n    only yield these fields (e.g. `for row in fc: ...`)\n\n    Args:\n        *fields (FieldName): Varargs of the fieldnames to limit all unspecified Iterators to\n\n    Example:\n        ```python\n        &gt;&gt;&gt; with fc.fields_as('OID@', 'NAME'):\n        ...     for row in fc:\n        ...         print(row)\n        {'OID@': 1, 'NAME': 'John'}\n        {'OID@': 2, 'NAME': 'Michael'}\n        ...\n        &gt;&gt;&gt; for row in fc:\n        ...     print(row)\n        {'OID@': 1, 'NAME': 'John', 'AGE': 75, 'ADDRESS': 123 Silly Walk}\n        {'OID@': 2, 'NAME': 'Michael', 'AGE': 70, 'ADDRESS': 42 Dead Parrot Blvd}\n        ...\n        ```\n    \"\"\"\n    # Allow passing a single field as a string `fc.fields_as('OID@')` to maintain\n    # The call format of *Cursor objects\n    _fields = self.fields\n    self._fields = tuple(fields)\n    try:\n        yield self\n    finally:\n        self._fields = _fields\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.filter","title":"<code>filter(func, invert=False)</code>","text":"<p>Apply a function filter to rows in the Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[dict[str, Any]], bool]</code> <p>A callable that takes a  row dictionary and returns True or False</p> required <code>invert</code> <code>bool</code> <p>Invert the function. Only yield rows that return <code>False</code></p> <code>False</code> <p>Yields:</p> Type Description <code> dict[str, Any] </code> <p>Rows in the Table or FeatureClass that match the filter (or inverted filter)</p> Example <pre><code>&gt;&gt;&gt; def area_filter(row: dict) -&gt; bool:\n&gt;&gt;&gt;     return row['Area'] &gt;= 10\n\n&gt;&gt;&gt; for row in fc:\n&gt;&gt;&gt;     print(row['Area'])\n1\n2\n10\n&lt;etc&gt;\n\n&gt;&gt;&gt; for row in fc.filter(area_filter):\n&gt;&gt;&gt;     print(row['Area'])\n10\n11\n90\n&lt;etc&gt;\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def filter(self, func: FilterFunc, invert: bool=False) -&gt; Iterator[RowRecord]:\n    \"\"\"Apply a function filter to rows in the Table or FeatureClass\n\n    Args:\n        func (Callable[[dict[str, Any]], bool]): A callable that takes a \n            row dictionary and returns True or False\n        invert (bool): Invert the function. Only yield rows that return `False`\n\n    Yields:\n        ( dict[str, Any] ): Rows in the Table or FeatureClass that match the filter (or inverted filter)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; def area_filter(row: dict) -&gt; bool:\n        &gt;&gt;&gt;     return row['Area'] &gt;= 10\n\n        &gt;&gt;&gt; for row in fc:\n        &gt;&gt;&gt;     print(row['Area'])\n        1\n        2\n        10\n        &lt;etc&gt;\n\n        &gt;&gt;&gt; for row in fc.filter(area_filter):\n        &gt;&gt;&gt;     print(row['Area'])\n        10\n        11\n        90\n        &lt;etc&gt;\n        ```\n\n    \"\"\"\n    if hasattr(func, 'fields'): # Allow decorated filters for faster iteration (see `filter_fields`)\n        with self.fields_as(*getattr(func, 'fields')):\n            yield from (row for row in self if func(row) == (not invert))\n    else:\n        yield from (row for row in self if func(row) == (not invert))\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.from_layer","title":"<code>from_layer(layer, *, ignore_selection=False, ignore_def_query=False)</code>  <code>classmethod</code>","text":"<p>Build a Table or FeatureClass object from a layer applying the layer's current selection to the stored cursors</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer to convert to a Table or FeatureClass</p> required <code>ignore_selection</code> <code>bool</code> <p>Ignore the layer selection (default: False)</p> <code>False</code> <code>ignore_definition_query</code> <code>bool</code> <p>Ignore the layer definition query (default: False)</p> required <p>Returns:     ( Table or FeatureClass ): The Table or FeatureClass object with the layer query applied</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@classmethod\ndef from_layer(cls, layer: Layer,\n               *,\n               ignore_selection: bool = False,\n               ignore_def_query: bool = False,) -&gt; Table:\n    \"\"\"Build a Table or FeatureClass object from a layer applying the layer's current selection to the stored cursors\n\n    Args:\n        layer (Layer): The layer to convert to a Table or FeatureClass\n        ignore_selection (bool): Ignore the layer selection (default: False)\n        ignore_definition_query (bool): Ignore the layer definition query (default: False)\n    Returns:\n        ( Table or FeatureClass ): The Table or FeatureClass object with the layer query applied\n    \"\"\"\n    fc = cls(layer.dataSource)\n\n    selected_ids: set[int] | None = (\n        layer.getSelectionSet() or None\n        if not ignore_selection \n        else None\n    )\n    definition_query: str|None = (\n        layer.definitionQuery or None\n        if not ignore_def_query \n        else None\n    )\n    selection: str|None = (\n        f\"{fc.oid_field_name} IN ({format_query_list(selected_ids)})\" \n        if selected_ids \n        else None\n    )\n\n    if (query_components := list(filter(None, [definition_query, selection]))):\n        where_clause = ' AND '.join(query_components)\n        fc.search_options = SearchOptions(where_clause=where_clause)\n        fc.update_options = UpdateOptions(where_clause=where_clause)\n\n    fc.layer = layer\n    return fc\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.from_table","title":"<code>from_table(table, *, ignore_selection=False, ignore_def_query=False)</code>  <code>classmethod</code>","text":"<p>See <code>from_layer</code> for documentation, this is an alternative constructor that builds from a mp.Table object</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@classmethod\ndef from_table(cls, table: TableLayer,\n               *,\n               ignore_selection: bool = False,\n               ignore_def_query: bool = False,) -&gt; Table:\n    \"\"\"See `from_layer` for documentation, this is an alternative constructor that builds from a mp.Table object\"\"\"\n    return Table.from_layer(table, ignore_selection=ignore_selection, ignore_def_query=ignore_def_query) # type: ignore (this won't break the interface)\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.get_records","title":"<code>get_records(field_names, **options)</code>","text":"<p>Generate row dicts with in the form <code>{field: value, ...}</code> for each row in the cursor</p> <p>Parameters:</p> Name Type Description Default <code>field_names</code> <code>str | Iterable[str]</code> <p>The columns to iterate</p> required <code>search_options</code> <code>SearchOptions</code> <p>A Search Options object</p> required <code>**options</code> <code>Unpack[SearchOptions]</code> <p>Additional over</p> <code>{}</code> <code>search_options</code> <code>SearchOptions</code> <p>A Search Options object</p> required <code>**options</code> <code>Unpack[SearchOptions]</code> <p>Additional over</p> <code>{}</code> <p>Yields      ( dict[str, Any] ): A mapping of fieldnames to field values for each row</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def get_records(self, field_names: Sequence[FieldName] | FieldName, **options: Unpack[SearchOptions]) -&gt; Iterator[RowRecord]:\n    \"\"\"Generate row dicts with in the form `{field: value, ...}` for each row in the cursor\n\n    Args:\n        field_names (str | Iterable[str]): The columns to iterate\n        search_options (SearchOptions): A Search Options object\n        **options (Unpack[SearchOptions]): Additional over\n        search_options (SearchOptions): A Search Options object\n        **options (Unpack[SearchOptions]): Additional over\n    Yields \n        ( dict[str, Any] ): A mapping of fieldnames to field values for each row\n    \"\"\"\n    with self.search_cursor(field_names, **options) as cur:\n        yield from as_dict(cur)\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.get_tuples","title":"<code>get_tuples(field_names, **options)</code>","text":"<p>Generate tuple rows in the for (val1, val2, ...) for each row in the cursor</p> <p>Parameters:</p> Name Type Description Default <code>field_names</code> <code>str | Iterable[str]</code> <p>The columns to iterate</p> required <code>**options</code> <code>SearchOptions</code> <p>Additional parameters to pass to the SearchCursor</p> <code>{}</code> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def get_tuples(self, field_names: Sequence[FieldName] | FieldName, **options: Unpack[SearchOptions]) -&gt; Iterator[tuple[Any, ...]]:\n    \"\"\"Generate tuple rows in the for (val1, val2, ...) for each row in the cursor\n\n    Args:\n        field_names (str | Iterable[str]): The columns to iterate\n        **options (SearchOptions): Additional parameters to pass to the SearchCursor\n    \"\"\"\n    with self.search_cursor(field_names, **options) as cur:\n        yield from cur\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.group_by","title":"<code>group_by(group_fields, return_fields='*')</code>","text":"<p>Group features by matching field values and yield full records in groups</p> <p>Parameters:</p> Name Type Description Default <code>group_fields</code> <code>FieldOpt</code> <p>The fields to group the data by</p> required <code>return_fields</code> <code>FieldOpt</code> <p>The fields to include in the output record (<code>'*'</code> means all and is default)</p> <code>'*'</code> <p>Yields:     ( Iterator[tuple[tuple[FieldName, ...], Iterator[tuple[Any, ...] | Any]]] ): A nested iterator of groups and then rows</p> Example <pre><code>&gt;&gt;&gt; # With a field group, you will be able to unpack the tuple\n&gt;&gt;&gt; for group, rows in fc.group_by(['GroupField1', 'GroupField2'], ['ValueField1', 'ValueField2', ...]):\n...     print(group)\n...     for v1, v2 in rows:\n...        if v1 &gt; 10:\n...            print(v2)\n(GroupValue1A, GroupValue1B)\nvalueA\nvalueB\n...\n&gt;&gt;&gt; # With a single field, you will have direct access to the field values   \n&gt;&gt;&gt; for group, district_populations in fc.group_by(['City', 'State'], 'Population'):\n&gt;&gt;&gt;         print(f\"{group}: {sum(district_populations)}\")\n(New York, NY): 8260000\n(Boston, MA): 4941632\n...\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def group_by(self, group_fields: Sequence[FieldName] | FieldName, return_fields: Sequence[FieldName] | FieldName ='*') -&gt; Iterator[tuple[GroupIdent, GroupIter]]:\n    \"\"\"Group features by matching field values and yield full records in groups\n\n    Args:\n        group_fields (FieldOpt): The fields to group the data by\n        return_fields (FieldOpt): The fields to include in the output record (`'*'` means all and is default)\n    Yields:\n        ( Iterator[tuple[tuple[FieldName, ...], Iterator[tuple[Any, ...] | Any]]] ): A nested iterator of groups and then rows\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # With a field group, you will be able to unpack the tuple\n        &gt;&gt;&gt; for group, rows in fc.group_by(['GroupField1', 'GroupField2'], ['ValueField1', 'ValueField2', ...]):\n        ...     print(group)\n        ...     for v1, v2 in rows:\n        ...        if v1 &gt; 10:\n        ...            print(v2)\n        (GroupValue1A, GroupValue1B)\n        valueA\n        valueB\n        ...\n        &gt;&gt;&gt; # With a single field, you will have direct access to the field values   \n        &gt;&gt;&gt; for group, district_populations in fc.group_by(['City', 'State'], 'Population'):\n        &gt;&gt;&gt;         print(f\"{group}: {sum(district_populations)}\")\n        (New York, NY): 8260000\n        (Boston, MA): 4941632\n        ...\n        ```\n    \"\"\"\n\n    # Parameter Validations\n    if isinstance(group_fields, str):\n        group_fields = (group_fields,)\n    if return_fields == '*':\n        return_fields = self.fields\n    if isinstance(return_fields, str):\n        return_fields = (return_fields,)\n    if len(group_fields) &lt; 1 or len(return_fields) &lt; 1:\n        raise ValueError(\"Group Fields and Return Fields must be populated\")\n\n    group_fields = list(group_fields)\n    return_fields = list(return_fields)\n    _all_fields = group_fields + return_fields\n    for group in self.distinct(group_fields):\n        group_key = {field : value for field, value in zip(group_fields, group)}\n        where_clause = \" AND \".join(f\"{field} = {norm(value)}\" for field, value in group_key.items())\n        if '@' not in where_clause: # Handle valid clause (no tokens)\n            with self.search_cursor(return_fields, where_clause=where_clause) as group_cur:\n                yield (extract_singleton(group), (extract_singleton(row) for row in group_cur))\n        else: # Handle token being passed by iterating a cursor and checking values directly\n            for row in filter(lambda row: all(row[k] == group_key[k] for k in group_key), self[set(_all_fields)]):\n                yield (extract_singleton(group), (row.pop(k) for k in return_fields))\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.has_field","title":"<code>has_field(fieldname)</code>","text":"<p>Check if the field exists in the featureclass or is a valid Token (@[TOKEN])</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def has_field(self, fieldname: str) -&gt; bool:\n    \"\"\"Check if the field exists in the featureclass or is a valid Token (@[TOKEN])\"\"\"\n    return fieldname in self.fields or fieldname in self.Tokens\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.insert_cursor","title":"<code>insert_cursor(field_names, *, insert_options=None, **overrides)</code>","text":"<p>See <code>Table.search_cursor</code> doc for general info. Operation of this method is identical but returns an <code>InsertCursor</code></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def insert_cursor(self, field_names: FieldName | Sequence[FieldName],\n                  *,\n                  insert_options: InsertOptions|None=None, \n                  **overrides: Unpack[InsertOptions]) -&gt; InsertCursor:\n    \"\"\"See `Table.search_cursor` doc for general info. Operation of this method is identical but returns an `InsertCursor`\"\"\"\n    return InsertCursor(self.path, field_names, **self._resolve_insert_options(insert_options, overrides))\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.insert_records","title":"<code>insert_records(records, ignore_errors=False)</code>","text":"<p>Provide a list of records to insert Args:     records (Iterable[RowRecord]): The sequence of records to insert     ignore_errors (bool): Ignore per-row errors and continue. Otherwise raise KeyError (default: True)</p> <p>Returns:</p> Type Description <code> tuple[int] </code> <p>Returns the OIDs of the newly inserted rows</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the records have varying keys or the keys are not in the Table or FeatureClass</p> Example <pre><code>&gt;&gt;&gt; new_rows = [\n...    {'first': 'John', 'last': 'Cleese', 'year': 1939}, \n...    {'first': 'Michael', 'last': 'Palin', 'year': 1943}\n... ]\n&gt;&gt;&gt; print(fc.insert_rows(new_rows))\n(2,3)\n\n&gt;&gt;&gt; # Insert all shapes from fc into fc2\n&gt;&gt;&gt; fc2.insert_rows(fc.get_records(['first', 'last', 'year']))\n(1,2)\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def insert_records(self, records: Iterator[RowRecord] | Sequence[RowRecord], ignore_errors: bool=False) -&gt; tuple[int, ...]:\n    \"\"\"Provide a list of records to insert\n    Args:\n        records (Iterable[RowRecord]): The sequence of records to insert\n        ignore_errors (bool): Ignore per-row errors and continue. Otherwise raise KeyError (default: True)\n\n    Returns:\n        ( tuple[int] ): Returns the OIDs of the newly inserted rows\n\n    Raises:\n        ( KeyError ): If the records have varying keys or the keys are not in the Table or FeatureClass\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_rows = [\n        ...    {'first': 'John', 'last': 'Cleese', 'year': 1939}, \n        ...    {'first': 'Michael', 'last': 'Palin', 'year': 1943}\n        ... ]\n        &gt;&gt;&gt; print(fc.insert_rows(new_rows))\n        (2,3)\n\n        &gt;&gt;&gt; # Insert all shapes from fc into fc2\n        &gt;&gt;&gt; fc2.insert_rows(fc.get_records(['first', 'last', 'year']))\n        (1,2)\n        ```\n    \"\"\"\n    # Always cast records to a list to prevent cursor race conditions, \n    # e.g. feature_class.insert_records(feature_class[where('SUBTYPE == 1')]) \n    # would insert infinite records since the search cursor trails the insert cursor.\n    records = list(records)\n    if not records:\n        return tuple()\n\n    rec_fields: list[str] = list(records[0].keys())\n    def rec_filter(rec: RowRecord) -&gt; bool:\n        if not rec_fields or set(rec.keys()).issubset(rec_fields):\n            return True\n        if ignore_errors:\n            return False\n        raise KeyError(f\"Invalid record found {rec}, does not contain the required fields: {rec_fields}\")\n\n    new_ids: list[int] = []\n    with self.editor, self.insert_cursor(rec_fields) as cur:\n        for rec in filter(rec_filter, records):\n            new_ids.append(cur.insertRow(tuple(rec.get(k) for k in rec_fields)))\n    return tuple(new_ids)\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.options","title":"<code>options(*, strict=False, search_options=None, update_options=None, insert_options=None, clause=None)</code>","text":"<p>Enter a context block where the supplied options replace the stored options for the <code>Table</code> or <code>FeatureClass</code></p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If this is set to <code>True</code> the <code>Table</code> or <code>FeatureClass</code> will not fallback on existing options when set to <code>False</code>, provided options override existing options (default: <code>False</code>)</p> <code>False</code> <code>search_options</code> <code>SearchOptions</code> <p>Contextual search overrides</p> <code>None</code> <code>update_options</code> <code>UpdateOptions</code> <p>Contextual update overrides</p> <code>None</code> <code>insert_options</code> <code>InsertOptions</code> <p>Contextual insert overrides</p> <code>None</code> <code>clause</code> <code>SQLClause</code> <p>Contextual <code>sql_clause</code> override</p> <code>None</code> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef options(self,\n            *, \n            strict: bool = False,\n            search_options: SearchOptions|None=None, \n            update_options: UpdateOptions|None=None, \n            insert_options: InsertOptions|None=None, \n            clause: SQLClause|None=None):\n    \"\"\"Enter a context block where the supplied options replace the stored options for the `Table` or `FeatureClass`\n\n    Args:\n        strict (bool): If this is set to `True` the `Table` or `FeatureClass` will not fallback on existing options\n            when set to `False`, provided options override existing options (default: `False`)\n        search_options (SearchOptions): Contextual search overrides\n        update_options (UpdateOptions): Contextual update overrides\n        insert_options (InsertOptions): Contextual insert overrides\n        clause (SQLClause): Contextual `sql_clause` override\n    \"\"\"\n    _src_ops = self.search_options\n    _upd_ops = self.update_options\n    _ins_ops = self.insert_options\n    _clause  = self.clause\n    try:\n        self._search_options = (\n            self._resolve_search_options(_src_ops, search_options or {}) \n            if not strict\n            else search_options or SearchOptions()\n        )\n        self._update_options = (\n            self._resolve_update_options(_upd_ops, update_options or {})\n            if not strict \n            else insert_options or UpdateOptions()\n        )\n        self._insert_options = (\n            self._resolve_insert_options(_ins_ops, insert_options or {})\n            if not strict \n            else insert_options or InsertOptions()\n        )\n        self._clause = (\n            clause or _clause\n            if not strict \n            else SQLClause(None, None)\n        )\n        yield self\n\n    finally:\n        self._search_options = _src_ops\n        self._update_options = _upd_ops\n        self.insert_options = _ins_ops\n        self._clause = _clause\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.search_cursor","title":"<code>search_cursor(field_names, *, search_options=None, **overrides)</code>","text":"<p>Get a <code>SearchCursor</code> for the <code>Table</code> or <code>FeatureClass</code> Supplied search options are resolved by updating the base <code>Table</code> or <code>FeatureClass</code> Search options in this order:</p> <p><code>**overrides['kwarg'] -&gt; search_options['kwarg'] -&gt; self.search_options['kwarg']</code></p> <p>This is implemented using unpacking operations with the lowest importance option set being unpacked first</p> <p><code>{**self.search_options, **(search_options or {}), **overrides}</code></p> <p>With direct key word arguments (<code>**overrides</code>) shadowing all other supplied options. This allows a Feature Class to be initialized using a base set of options, then a shared SearchOptions set to be applied in some contexts, then a direct keyword override to be supplied while never mutating the base options of the feature class.</p> <p>Parameters:</p> Name Type Description Default <code>field_names</code> <code>str | Iterable[str]</code> <p>The column names to include from the <code>Table</code> or <code>FeatureClass</code></p> required <code>search_options</code> <code>SearchOptions | None</code> <p>A <code>SeachOptions</code> instance that will be used to shadow <code>search_options</code> set on the <code>Table</code> or <code>FeatureClass</code></p> <code>None</code> <code>**overrides</code> <code>Unpack[SeachOptions]</code> <p>Additional keyword arguments for the cursor that shadow  both the <code>seach_options</code> variable and the <code>Table</code> or <code>FeatureClass</code> instance <code>SearchOptions</code></p> <code>{}</code> <p>Returns:</p> Type Description <code> SearchCursor </code> <p>A <code>SearchCursor</code> for the <code>Table</code> or <code>FeatureClass</code> instance that has all supplied options resolved and applied</p> Example <pre><code>    &gt;&gt;&gt; cleese_search = SearchOptions(where_clause=\"NAME = 'John Cleese'\")\n    &gt;&gt;&gt; idle_search = SearchOptions(where_clause=\"NAME = 'Eric Idle'\")\n    &gt;&gt;&gt; monty = Table or FeatureClass('&lt;path&gt;', search_options=cleese_search)\n    &gt;&gt;&gt; print(list(monty.search_cursor('NAME')))\n    [('John Cleese',)]\n    &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)))\n    [('Eric Idle', )]\n    &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)), where_clause=\"NAME = Graham Chapman\")\n    [('Graham Chapman', )]\n</code></pre> <p>In this example, you can see that the keyword override is the most important. The fact that the other searches are created outside initialization allows you to store common queries in one place and update them for all cursors using  them at the same time, while still allowing specific instances of a cursor to override those shared/stored defaults.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def search_cursor(self, field_names: FieldName | Sequence[FieldName],\n                  *,\n                  search_options: SearchOptions|None=None, \n                  **overrides: Unpack[SearchOptions]) -&gt; SearchCursor:\n    \"\"\"Get a `SearchCursor` for the `Table` or `FeatureClass`\n    Supplied search options are resolved by updating the base `Table` or `FeatureClass` Search options in this order:\n\n    `**overrides['kwarg'] -&gt; search_options['kwarg'] -&gt; self.search_options['kwarg']`\n\n    This is implemented using unpacking operations with the lowest importance option set being unpacked first\n\n    `{**self.search_options, **(search_options or {}), **overrides}`\n\n    With direct key word arguments (`**overrides`) shadowing all other supplied options. This allows a Feature Class to\n    be initialized using a base set of options, then a shared SearchOptions set to be applied in some contexts,\n    then a direct keyword override to be supplied while never mutating the base options of the feature class.\n\n    Args:\n        field_names (str | Iterable[str]): The column names to include from the `Table` or `FeatureClass`\n        search_options (SearchOptions|None): A `SeachOptions` instance that will be used to shadow\n            `search_options` set on the `Table` or `FeatureClass`\n        **overrides ( Unpack[SeachOptions] ): Additional keyword arguments for the cursor that shadow \n            both the `seach_options` variable and the `Table` or `FeatureClass` instance `SearchOptions`\n\n    Returns:\n        ( SearchCursor ): A `SearchCursor` for the `Table` or `FeatureClass` instance that has all supplied options\n            resolved and applied\n\n    Example:\n        ```python\n            &gt;&gt;&gt; cleese_search = SearchOptions(where_clause=\"NAME = 'John Cleese'\")\n            &gt;&gt;&gt; idle_search = SearchOptions(where_clause=\"NAME = 'Eric Idle'\")\n            &gt;&gt;&gt; monty = Table or FeatureClass('&lt;path&gt;', search_options=cleese_search)\n            &gt;&gt;&gt; print(list(monty.search_cursor('NAME')))\n            [('John Cleese',)]\n            &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)))\n            [('Eric Idle', )]\n            &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)), where_clause=\"NAME = Graham Chapman\")\n            [('Graham Chapman', )]\n        ```\n    In this example, you can see that the keyword override is the most important. The fact that the other searches are\n    created outside initialization allows you to store common queries in one place and update them for all cursors using \n    them at the same time, while still allowing specific instances of a cursor to override those shared/stored defaults.\n    \"\"\"\n    return SearchCursor(self.path, field_names, **self._resolve_search_options(search_options, overrides))\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.select","title":"<code>select(method='NEW')</code>","text":"<p>If the Table or FeatureClass is bound to a layer, update the layer selection with the active SearchOptions</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['NEW', 'DIFFERENCE', 'INTERSECT', 'SYMDIFFERENCE', 'UNION']</code> <p>The method to use to apply the selection</p> <p><code>DIFFERENCE</code>: Selects the features that are not in the current selection but are in the Table or FeatureClass.</p> <p><code>INTERSECT</code>: Selects the features that are in the current selection and the Table or FeatureClass.</p> <p><code>NEW</code>: Creates a new feature selection from the Table or FeatureClass.</p> <p><code>SYMDIFFERENCE</code>: Selects the features that are in the current selection or the Table or FeatureClass but not both.</p> <p><code>UNION</code>: Selects all the features in both the current selection and those in Table or FeatureClass.</p> <code>'NEW'</code> Note <p>Selection changes require the project file to be saved to take effect.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def select(self, method: Literal['NEW','DIFFERENCE','INTERSECT','SYMDIFFERENCE','UNION']='NEW') -&gt; None:\n    \"\"\"If the Table or FeatureClass is bound to a layer, update the layer selection with the active SearchOptions\n\n    Args:\n        method: The method to use to apply the selection\\n\n            `DIFFERENCE`: Selects the features that are not in the current selection but are in the Table or FeatureClass.\\n\n            `INTERSECT`: Selects the features that are in the current selection and the Table or FeatureClass.\\n\n            `NEW`: Creates a new feature selection from the Table or FeatureClass.\\n\n            `SYMDIFFERENCE`: Selects the features that are in the current selection or the Table or FeatureClass but not both.\\n\n            `UNION`: Selects all the features in both the current selection and those in Table or FeatureClass.\\n\n\n    Note:\n        Selection changes require the project file to be saved to take effect. \n    \"\"\"\n    if self.layer:\n        _selected = list(self['OID@'])\n        self.layer.setSelectionSet(_selected, method=method)\n        try: # Try to select the layer in the active map\n            if len(_selected) == 1:\n                _query = f'{self.oid_field_name} = {_selected.pop()})'\n            if len(_selected) &gt; 1:\n                _query = f'{self.oid_field_name} IN ({format_query_list(_selected)})'\n            else:\n                return\n            SelectLayerByAttribute(self.layer.longName, 'NEW_SELECTION', _query)\n        except Exception:\n            return\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.unselect","title":"<code>unselect()</code>","text":"<p>If the Table or FeatureClass is bound to a layer, Remove layer selection</p> Note <p>Selection changes require the project file to be saved to take effect.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def unselect(self) -&gt; None:\n    \"\"\"If the Table or FeatureClass is bound to a layer, Remove layer selection\n\n    Note:\n        Selection changes require the project file to be saved to take effect.\n    \"\"\"\n    if self.layer:\n        self.layer.setSelectionSet(method='NEW')\n        try: # Try to unselect the layer in the active map\n            SelectLayerByAttribute(self.layer.longName, 'CLEAR_SELECTION')\n        except Exception:\n            return\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.update_cursor","title":"<code>update_cursor(field_names, *, update_options=None, **overrides)</code>","text":"<p>See <code>Table.search_cursor</code> doc for general info. Operation of this method is identical but returns an <code>UpdateCursor</code></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def update_cursor(self, field_names: FieldName | Sequence[FieldName],\n                  *,\n                  update_options: UpdateOptions|None=None, \n                  **overrides: Unpack[UpdateOptions]) -&gt; UpdateCursor:\n    \"\"\"See `Table.search_cursor` doc for general info. Operation of this method is identical but returns an `UpdateCursor`\"\"\"\n    return UpdateCursor(self.path, field_names, **self._resolve_update_options(update_options, overrides))\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.where","title":"<code>where(where_clause)</code>","text":"<p>Apply a where clause to a Table or FeatureClass in a context</p> <p>Parameters:</p> Name Type Description Default <code>where_clause</code> <code>str</code> <p>The where clause to apply to the Table or FeatureClass</p> required Example <pre><code>&gt;&gt;&gt; with fc.where(\"first = 'John'\") as f:\n...     for f in fc:\n...         print(f)\n{'first': 'John', 'last': 'Cleese', 'year': 1939}\n\n&gt;&gt;&gt; with fc.where('year &gt; 1939'):\n...     print(len(fc))\n5\n... print(len(fc))\n6\n</code></pre> Note <p>This method of filtering a Table or FeatureClass will always be more performant than using the  <code>.filter</code> method. If you can achieve the filtering you want with a where clause, do it.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef where(self, where_clause: str):\n    \"\"\"Apply a where clause to a Table or FeatureClass in a context\n\n    Args:\n        where_clause (str): The where clause to apply to the Table or FeatureClass\n\n    Example:\n        ```python\n        &gt;&gt;&gt; with fc.where(\"first = 'John'\") as f:\n        ...     for f in fc:\n        ...         print(f)\n        {'first': 'John', 'last': 'Cleese', 'year': 1939}\n\n        &gt;&gt;&gt; with fc.where('year &gt; 1939'):\n        ...     print(len(fc))\n        5\n        ... print(len(fc))\n        6\n        ```\n\n    Note:\n        This method of filtering a Table or FeatureClass will always be more performant than using the \n        `.filter` method. If you can achieve the filtering you want with a where clause, do it.\n    \"\"\"\n    with self.options(\n        search_options=SearchOptions(where_clause=where_clause)):\n        yield self\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.Table.write_attribute_rules","title":"<code>write_attribute_rules(out_dir)</code>","text":"<p>Write attribute rules out to a structured directory</p> Note <p>out_dir -&gt; fc_name -&gt; [rule_name.cfg, rule_name.js]</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def write_attribute_rules(self, out_dir: Path|str) -&gt; None:\n    \"\"\"Write attribute rules out to a structured directory\n\n    Note:\n        out_dir -&gt; fc_name -&gt; [rule_name.cfg, rule_name.js]\n    \"\"\"\n    out_dir = Path(out_dir)\n    for rule_name, rule in self.attribute_rules.items():\n        _script: str = rule['scriptExpression']\n        _cfg = {k:v for k,v in rule.items() if k not in ('scriptExpression',)}\n        out_file = out_dir / self.name / rule_name\n        out_file.with_suffix('.js').write_text(_script)\n        out_file.with_suffix('.cfg').write_text(json.dumps(_cfg, indent=2))\n    return\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.count","title":"<code>count(featureclass)</code>","text":"<p>Get the record count of a FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>featureclass</code> <code>FeatureClass | Iterator</code> <p>The FeatureClass or Iterator/view to count</p> required Example <pre><code>&gt;&gt;&gt; fc = FeatureClass[PointGeometry]('MyFC')\n&gt;&gt;&gt; count(fc)\n1000\n&gt;&gt;&gt; count(fc[where('1=0')])\n0\n&gt;&gt;&gt; boundary = next(FeatureClass[Polygon]('Boundaries').shapes)\n&gt;&gt;&gt; count(fc[boundary])\n325\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def count(featureclass: FeatureClass[Any] | Iterator[Any]) -&gt; int:\n    \"\"\"Get the record count of a FeatureClass\n\n    Args:\n        featureclass (FeatureClass | Iterator): The FeatureClass or Iterator/view to count\n\n    Example:\n        ```python\n        &gt;&gt;&gt; fc = FeatureClass[PointGeometry]('MyFC')\n        &gt;&gt;&gt; count(fc)\n        1000\n        &gt;&gt;&gt; count(fc[where('1=0')])\n        0\n        &gt;&gt;&gt; boundary = next(FeatureClass[Polygon]('Boundaries').shapes)\n        &gt;&gt;&gt; count(fc[boundary])\n        325\n        ```\n    \"\"\"\n    # The __len__() method of FeatureClass only iterates\n    # object ID values so this is a small optimisation we can do\n    if isinstance(featureclass, FeatureClass):\n        return len(featureclass)\n\n    return sum(1 for _ in featureclass)\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.extract_singleton","title":"<code>extract_singleton(vals)</code>","text":"<p>Helper function to allow passing single values to arguments that expect a tuple</p> <p>Parameters:</p> Name Type Description Default <code>vals</code> <code>Sequence[Any] | Any</code> <p>The values to normalize based on item count</p> required <p>Returns:</p> Type Description <code> Sequence[Any] | Any  </code> <p>The normalized sequence</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def extract_singleton(vals: Sequence[Any] | Any) -&gt; Any | Sequence[Any]:\n    \"\"\"Helper function to allow passing single values to arguments that expect a tuple\n\n    Args:\n        vals (Sequence[Any] | Any): The values to normalize based on item count\n\n    Returns:\n        ( Sequence[Any] | Any  ): The normalized sequence\n    \"\"\"\n    # String sequences are returned directly\n    if isinstance(vals, str):\n        return vals\n\n    # Singleton sequences are flattened to the first value\n    if len(vals) == 1:\n        return vals[0]\n\n    # Default to returning the arg\n    return vals\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.filter_fields","title":"<code>filter_fields(*fields)</code>","text":"<p>Decorator for filter functions that limits fields checked by the SearchCursor</p> <p>Parameters:</p> Name Type Description Default <code>*fields</code> <code>FieldName</code> <p>Varargs for the fields to limit the filter to</p> <code>()</code> <p>Returns:</p> Type Description <code>FilterFunc</code> <p>A filter function with a <code>fields</code> attribute added</p> <p>Used with FeatureClass.filter to limit columns</p> Note <p>Iterating filtered rows using a decorated filter will limit available columns inside the  context of the filter. This should only be used if you need to improve performance of a  filter and don't care about the fields not included in the <code>filter_fields</code> decorator:</p> <p>Example:     <pre><code>&gt;&gt;&gt; @filter_fields('Name', 'Age')\n&gt;&gt;&gt; def age_over_21(row):\n...     return row['Age'] &gt; 21\n...\n&gt;&gt;&gt; for row in feature_class[age_over_21]:\n...     print(row)\n...\n{'Name': 'John', 'Age': 23}\n{'Name': 'Terry', 'Age': 42}\n...\n&gt;&gt;&gt; for row in feature_class:\n...     print(row)\n...\n{'Name': 'John', 'LastName': 'Cleese', 'Age': 23}\n{'Name': 'Graham', 'LastName': 'Chapman', 'Age': 18}\n{'Name': 'Terry', 'LastName': 'Gilliam', 'Age': 42}\n...\n</code></pre></p> Note <p>You can achieve field filtering using the <code>FeatureClass.fields_as</code> context manager as well.  This method adds a level of indentation and can be more extensible:</p> <p>Example:     <pre><code>&gt;&gt;&gt; def age_over_21(row):\n...     return row['Age'] &gt; 21\n...\n&gt;&gt;&gt; with feature_class.fields_as('Name', 'Age'):\n...     for row in feature_class[age_over_21]:\n...         print(row)\n...\n{'Name': 'John', 'Age': 23}\n{'Name': 'Terry', 'Age': 42}\n</code></pre> Since the inspected fields live in the same code block as the filter that uses them, you can  easily add the fields in one place. This method is preferred for data manipulation operations  while counting operations can use the decorated filter to cut down on boilerplate.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def filter_fields(*fields: FieldName):\n    \"\"\"Decorator for filter functions that limits fields checked by the SearchCursor\n\n    Args:\n        *fields (FieldName): Varargs for the fields to limit the filter to\n\n    Returns:\n        (FilterFunc): A filter function with a `fields` attribute added\n        Used with FeatureClass.filter to limit columns\n\n    Note:\n        Iterating filtered rows using a decorated filter will limit available columns inside the \n        context of the filter. This should only be used if you need to improve performance of a \n        filter and don't care about the fields not included in the `filter_fields` decorator:\n\n        Example:\n            ```python\n            &gt;&gt;&gt; @filter_fields('Name', 'Age')\n            &gt;&gt;&gt; def age_over_21(row):\n            ...     return row['Age'] &gt; 21\n            ...\n            &gt;&gt;&gt; for row in feature_class[age_over_21]:\n            ...     print(row)\n            ...\n            {'Name': 'John', 'Age': 23}\n            {'Name': 'Terry', 'Age': 42}\n            ...\n            &gt;&gt;&gt; for row in feature_class:\n            ...     print(row)\n            ...\n            {'Name': 'John', 'LastName': 'Cleese', 'Age': 23}\n            {'Name': 'Graham', 'LastName': 'Chapman', 'Age': 18}\n            {'Name': 'Terry', 'LastName': 'Gilliam', 'Age': 42}\n            ...\n            ```\n\n    Note:\n        You can achieve field filtering using the `FeatureClass.fields_as` context manager as well. \n        This method adds a level of indentation and can be more extensible:\n\n        Example:\n            ```python\n            &gt;&gt;&gt; def age_over_21(row):\n            ...     return row['Age'] &gt; 21\n            ...\n            &gt;&gt;&gt; with feature_class.fields_as('Name', 'Age'):\n            ...     for row in feature_class[age_over_21]:\n            ...         print(row)\n            ...\n            {'Name': 'John', 'Age': 23}\n            {'Name': 'Terry', 'Age': 42}\n            ```\n        Since the inspected fields live in the same code block as the filter that uses them, you can \n        easily add the fields in one place. This method is preferred for data manipulation operations \n        while counting operations can use the decorated filter to cut down on boilerplate.\n    \"\"\"\n    def _filter_wrapper(func: FilterFunc):\n        setattr(func, 'fields', fields)\n        return func\n    return _filter_wrapper\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.format_query_list","title":"<code>format_query_list(vals)</code>","text":"<p>Format a list of values into a SQL list</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def format_query_list(vals: Iterable[Any]) -&gt; str:\n    \"\"\"Format a list of values into a SQL list\"\"\"\n    if isinstance(vals, (str , int)):\n        return f\"{vals}\"\n    return ','.join([f\"{val}\" for val in vals])\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.norm","title":"<code>norm(val)</code>","text":"<p>Normalize a value for SQL query (wrap strings in single quotes)</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def norm(val: Any) -&gt; str:\n    \"\"\"Normalize a value for SQL query (wrap strings in single quotes)\"\"\"\n    if isinstance(val, str):\n        return f\"'{val}'\"\n    return val\n</code></pre>"},{"location":"featureclass/#arcpie.featureclass.valid_field","title":"<code>valid_field(fieldname)</code>","text":"<p>Validate a fieldname</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def valid_field(fieldname: FieldName) -&gt; bool:\n    \"\"\"Validate a fieldname\"\"\"\n    return not (\n            # Has characters\n            len(fieldname) == 0\n            # Is under 160 characters\n            or len(fieldname) &gt; 160\n            # Doesn't start with a number\n            or fieldname[0] in digits \n            # Only has alphanum and underscore\n            or not set(fieldname).issubset(ascii_letters + digits + '_')\n            # Doesn't have reserved prefix\n            or any(fieldname.startswith(reserved) for reserved in ('gdb_', 'sde_', 'delta_'))\n        )\n</code></pre>"},{"location":"network/","title":"network","text":""},{"location":"network/#arcpie.network.FeatureGraph","title":"<code>FeatureGraph</code>","text":"Source code in <code>src/arcpie/network.py</code> <pre><code>class FeatureGraph:\n    def __init__(self, edges: FeatureClass[Polyline], nodes: FeatureClass[PointGeometry], tolerance: float=0.0,\n                 *,\n                 node_attributes: Sequence[str] | None=None,\n                 edge_attributes: Sequence[str] | None=None) -&gt; None:\n        self.node_features = nodes\n        self.edge_features = edges\n        self.node_attributes = node_attributes or tuple()\n        self.edge_attributes = edge_attributes or tuple()\n        self.tolerance = tolerance\n        self._graph = self.build_graph()\n        self.user_nodes: list[tuple[int, PointGeometry]] = []\n\n    @property\n    def graph(self) -&gt; nx.Graph:\n        return self._graph\n\n    @property\n    def nodes(self) -&gt; Iterator[tuple[int, dict[str, Any]]]:\n        return self.graph.nodes.data()\n\n    def refresh(self) -&gt; None:\n        self.user_nodes = []\n        self._graph = self.build_graph()\n\n    def build_graph(self) -&gt; nx.Graph:\n        \"\"\"Build a graph from the provided features\n        Structure of the Graph will be:\n\n        `node:oid[attrs] &lt;-(edge:[attrs])-&gt; node:oid[attrs]`\n\n        e.g.\n\n        `45: {'name': 'bill'} &lt;-{'length': 1200.4, 'link_name': 'direct'}-&gt; 46: {'name': 'sue'}`\n\n        Returns:\n            (nx.Graph): A networkx Graph with all points connected by the provided edges\n\n        \"\"\"\n\n        # Initialize an undirected graph\n        g = nx.Graph()\n\n        # Add all points as nodes (with specified attributes)\n        for oid, node, *node_attrs in self.node_features[('OID@', 'SHAPE@', *self.node_attributes)]:\n            user_attrs: dict[str, Any] = dict(zip(self.node_attributes, node_attrs))\n            system_attrs: dict[str, Any] = {'OID@': oid, 'SHAPE@': node}\n            # Merge user and system attrs then unpack into **attr\n            g.add_node(oid, **{**user_attrs, **system_attrs})\n\n        # Connect all nodes using edges (with specified attributes)\n        for oid, edge, *edge_attrs in self.edge_features[('OID@', 'SHAPE@', *self.edge_attributes)]:\n            edge: Polyline\n            fp = PointGeometry(edge.firstPoint)\n            lp = PointGeometry(edge.lastPoint)\n\n            # Buffer anything with a specified non-zero tolerance\n            if self.tolerance:\n                fp = fp.buffer(self.tolerance)\n                lp = lp.buffer(self.tolerance)\n\n            # Get all nodes that Intersect the endpoints of the edge\n            with self.node_features.spatial_filter(fp.union(lp)):\n                to_add: list[int] = list(self.node_features['OID@'])\n\n            # Generate all unique connections for the edge and add them to the graph with the edge attrs\n            # avoid connecting nodes to themselves\n            for cxn in {tuple(sorted([a, b])) for a in to_add for b in to_add if a != b}:\n                user_attrs: dict[str, Any] = dict(zip(self.edge_attributes, edge_attrs))\n                system_attrs: dict[str, Any] = {'length': edge.length, 'OID@': oid, 'SHAPE@': edge}\n                # Merge user and system attrs then unpack into **attr\n                g.add_edge(cxn[0], cxn[1], **{**user_attrs, **system_attrs})\n        return g        \n\n    @overload\n    def __contains__(self, node: int) -&gt; bool: ...\n    @overload\n    def __contains__(self, node: PointGeometry) -&gt; bool: ...\n\n    def __contains__(self, node: int | PointGeometry) -&gt; bool:\n        if not isinstance(node, PointGeometry):\n            return node in self.graph\n        for _, data in self.nodes:\n            shape: PointGeometry = data['SHAPE@']\n            if shape == node:\n                return True\n        return False\n\n    def index_of(self, node: PointGeometry) -&gt; int:\n        for oid, data in self.nodes:\n            oid: int\n            shape: PointGeometry = data['SHAPE@']\n            if node == shape:\n                return oid\n\n        raise IndexError(f'Node: {node} not found in graph!')\n\n    def shortest_path(self, from_node: int|PointGeometry, to_node: int|PointGeometry) -&gt; Iterator[Polyline]:\n        \"\"\"Return the line geometries that make up the shortest path between the provided nodes\n\n        Args:\n            from_node (int|PointGeometry): The starting node in the graph\n            to_node (int|PointGeometry): The ending node in the graph\n\n        Returns:\n            (Iterator[Polyline]): An iterator of Polyline geometries that make up the shortest path \n        \"\"\"\n        if isinstance(from_node, PointGeometry):\n            from_node = self.index_of(from_node)\n\n        if isinstance(to_node, PointGeometry):\n            to_node = self.index_of(to_node)\n\n        route: list[int] = nx.shortest_path(self.graph, from_node, to_node, weight='length')\n\n        for i in range(len(route)-1):\n            yield self.graph.get_edge_data(route[i], route[i+1])['SHAPE@']\n\n    def add_node(self, node: PointGeometry, **data: Any) -&gt; int:\n        \"\"\"Adds a node to the graph\n\n        Note:\n            User added nodes will be assigned negative ids to prevent collision with system nodes from the base featureclass.\n            These nodes will also be removed if the graph is refreshed, this method is primarily for checking a geometry against a \n            network as a one off.\n\n        Args:\n            node (PointGeometry): The node to add\n            **data (Any): User defined attributes to add to the node\n\n        Returns:\n            (int): The new index of the node (negative indexed)\n        \"\"\"\n        new_index = -1*(len(self.user_nodes)+1)\n        user_attrs = data\n        system_attrs: dict[str, Any] = {'OID@': new_index, 'SHAPE@': node}\n        self.graph.add_node(new_index, **{**user_attrs, **system_attrs})\n        self.user_nodes.append((new_index, node))\n\n        # Buffer anything with a specified non-zero tolerance\n        if self.tolerance:\n            node_buff = node.buffer(self.tolerance)\n        else:\n            node_buff = node\n\n        with self.edge_features.spatial_filter(node_buff):\n            connecting_edges = tuple(self.edge_features[('OID@', 'SHAPE@', *self.edge_attributes)])\n\n        for oid, edge_shape, *edge_attrs in connecting_edges:\n            oid: int\n            edge_shape: Polyline\n\n            fp = PointGeometry(edge_shape.firstPoint)\n            lp = PointGeometry(edge_shape.lastPoint)\n\n            # Buffer anything with a specified non-zero tolerance\n            if self.tolerance:\n                fp = fp.buffer(self.tolerance)\n                lp = lp.buffer(self.tolerance)\n\n            with self.node_features.spatial_filter(fp.union(lp)):\n                cxns = list(self.node_features['OID@'])\n\n            user_attrs = dict(zip(self.edge_attributes, edge_attrs))\n            system_attrs: dict[str, Any] = {'length': edge_shape.length, 'OID@': oid, 'SHAPE@': edge_shape}\n            self.graph.add_edges_from([(new_index, n) for n in cxns], **{**user_attrs, **system_attrs})\n        return new_index\n</code></pre>"},{"location":"network/#arcpie.network.FeatureGraph.add_node","title":"<code>add_node(node, **data)</code>","text":"<p>Adds a node to the graph</p> Note <p>User added nodes will be assigned negative ids to prevent collision with system nodes from the base featureclass. These nodes will also be removed if the graph is refreshed, this method is primarily for checking a geometry against a  network as a one off.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>PointGeometry</code> <p>The node to add</p> required <code>**data</code> <code>Any</code> <p>User defined attributes to add to the node</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>The new index of the node (negative indexed)</p> Source code in <code>src/arcpie/network.py</code> <pre><code>def add_node(self, node: PointGeometry, **data: Any) -&gt; int:\n    \"\"\"Adds a node to the graph\n\n    Note:\n        User added nodes will be assigned negative ids to prevent collision with system nodes from the base featureclass.\n        These nodes will also be removed if the graph is refreshed, this method is primarily for checking a geometry against a \n        network as a one off.\n\n    Args:\n        node (PointGeometry): The node to add\n        **data (Any): User defined attributes to add to the node\n\n    Returns:\n        (int): The new index of the node (negative indexed)\n    \"\"\"\n    new_index = -1*(len(self.user_nodes)+1)\n    user_attrs = data\n    system_attrs: dict[str, Any] = {'OID@': new_index, 'SHAPE@': node}\n    self.graph.add_node(new_index, **{**user_attrs, **system_attrs})\n    self.user_nodes.append((new_index, node))\n\n    # Buffer anything with a specified non-zero tolerance\n    if self.tolerance:\n        node_buff = node.buffer(self.tolerance)\n    else:\n        node_buff = node\n\n    with self.edge_features.spatial_filter(node_buff):\n        connecting_edges = tuple(self.edge_features[('OID@', 'SHAPE@', *self.edge_attributes)])\n\n    for oid, edge_shape, *edge_attrs in connecting_edges:\n        oid: int\n        edge_shape: Polyline\n\n        fp = PointGeometry(edge_shape.firstPoint)\n        lp = PointGeometry(edge_shape.lastPoint)\n\n        # Buffer anything with a specified non-zero tolerance\n        if self.tolerance:\n            fp = fp.buffer(self.tolerance)\n            lp = lp.buffer(self.tolerance)\n\n        with self.node_features.spatial_filter(fp.union(lp)):\n            cxns = list(self.node_features['OID@'])\n\n        user_attrs = dict(zip(self.edge_attributes, edge_attrs))\n        system_attrs: dict[str, Any] = {'length': edge_shape.length, 'OID@': oid, 'SHAPE@': edge_shape}\n        self.graph.add_edges_from([(new_index, n) for n in cxns], **{**user_attrs, **system_attrs})\n    return new_index\n</code></pre>"},{"location":"network/#arcpie.network.FeatureGraph.build_graph","title":"<code>build_graph()</code>","text":"<p>Build a graph from the provided features Structure of the Graph will be:</p> <p><code>node:oid[attrs] &lt;-(edge:[attrs])-&gt; node:oid[attrs]</code></p> <p>e.g.</p> <p><code>45: {'name': 'bill'} &lt;-{'length': 1200.4, 'link_name': 'direct'}-&gt; 46: {'name': 'sue'}</code></p> <p>Returns:</p> Type Description <code>Graph</code> <p>A networkx Graph with all points connected by the provided edges</p> Source code in <code>src/arcpie/network.py</code> <pre><code>def build_graph(self) -&gt; nx.Graph:\n    \"\"\"Build a graph from the provided features\n    Structure of the Graph will be:\n\n    `node:oid[attrs] &lt;-(edge:[attrs])-&gt; node:oid[attrs]`\n\n    e.g.\n\n    `45: {'name': 'bill'} &lt;-{'length': 1200.4, 'link_name': 'direct'}-&gt; 46: {'name': 'sue'}`\n\n    Returns:\n        (nx.Graph): A networkx Graph with all points connected by the provided edges\n\n    \"\"\"\n\n    # Initialize an undirected graph\n    g = nx.Graph()\n\n    # Add all points as nodes (with specified attributes)\n    for oid, node, *node_attrs in self.node_features[('OID@', 'SHAPE@', *self.node_attributes)]:\n        user_attrs: dict[str, Any] = dict(zip(self.node_attributes, node_attrs))\n        system_attrs: dict[str, Any] = {'OID@': oid, 'SHAPE@': node}\n        # Merge user and system attrs then unpack into **attr\n        g.add_node(oid, **{**user_attrs, **system_attrs})\n\n    # Connect all nodes using edges (with specified attributes)\n    for oid, edge, *edge_attrs in self.edge_features[('OID@', 'SHAPE@', *self.edge_attributes)]:\n        edge: Polyline\n        fp = PointGeometry(edge.firstPoint)\n        lp = PointGeometry(edge.lastPoint)\n\n        # Buffer anything with a specified non-zero tolerance\n        if self.tolerance:\n            fp = fp.buffer(self.tolerance)\n            lp = lp.buffer(self.tolerance)\n\n        # Get all nodes that Intersect the endpoints of the edge\n        with self.node_features.spatial_filter(fp.union(lp)):\n            to_add: list[int] = list(self.node_features['OID@'])\n\n        # Generate all unique connections for the edge and add them to the graph with the edge attrs\n        # avoid connecting nodes to themselves\n        for cxn in {tuple(sorted([a, b])) for a in to_add for b in to_add if a != b}:\n            user_attrs: dict[str, Any] = dict(zip(self.edge_attributes, edge_attrs))\n            system_attrs: dict[str, Any] = {'length': edge.length, 'OID@': oid, 'SHAPE@': edge}\n            # Merge user and system attrs then unpack into **attr\n            g.add_edge(cxn[0], cxn[1], **{**user_attrs, **system_attrs})\n    return g        \n</code></pre>"},{"location":"network/#arcpie.network.FeatureGraph.shortest_path","title":"<code>shortest_path(from_node, to_node)</code>","text":"<p>Return the line geometries that make up the shortest path between the provided nodes</p> <p>Parameters:</p> Name Type Description Default <code>from_node</code> <code>int | PointGeometry</code> <p>The starting node in the graph</p> required <code>to_node</code> <code>int | PointGeometry</code> <p>The ending node in the graph</p> required <p>Returns:</p> Type Description <code>Iterator[Polyline]</code> <p>An iterator of Polyline geometries that make up the shortest path</p> Source code in <code>src/arcpie/network.py</code> <pre><code>def shortest_path(self, from_node: int|PointGeometry, to_node: int|PointGeometry) -&gt; Iterator[Polyline]:\n    \"\"\"Return the line geometries that make up the shortest path between the provided nodes\n\n    Args:\n        from_node (int|PointGeometry): The starting node in the graph\n        to_node (int|PointGeometry): The ending node in the graph\n\n    Returns:\n        (Iterator[Polyline]): An iterator of Polyline geometries that make up the shortest path \n    \"\"\"\n    if isinstance(from_node, PointGeometry):\n        from_node = self.index_of(from_node)\n\n    if isinstance(to_node, PointGeometry):\n        to_node = self.index_of(to_node)\n\n    route: list[int] = nx.shortest_path(self.graph, from_node, to_node, weight='length')\n\n    for i in range(len(route)-1):\n        yield self.graph.get_edge_data(route[i], route[i+1])['SHAPE@']\n</code></pre>"},{"location":"project/","title":"project","text":""},{"location":"project/#arcpie.project.BookmarkMapSeries","title":"<code>BookmarkMapSeries</code>","text":"<p>               Bases: <code>MappingWrapper[BookmarkMapSeries]</code>, <code>BookmarkMapSeries</code></p> <p>Wrapper around an arcpy.mp BookmarkMapSeries object that provides an ergonomic interface</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class BookmarkMapSeries(MappingWrapper[_BookmarkMapSeries], _BookmarkMapSeries):\n    \"\"\"Wrapper around an arcpy.mp BookmarkMapSeries object that provides an ergonomic interface\"\"\"\n\n    def __iter__(self) -&gt; Iterator[BookmarkMapSeries]:\n        _orig_page = self.currentPageNumber\n        for page in range(1, self.pageCount):\n            self.currentPageNumber = page\n            yield self\n        if _orig_page:\n            self.currentPageNumber = _orig_page\n\n    def __getitem__(self, page: int|str|_Bookmark) -&gt; BookmarkMapSeries:\n        \"\"\"Allow indexing the BookmarkMapSeries by name, index, or Bookmark object\"\"\"\n        match page:\n            case _Bookmark():\n                self.currentBookmark = page\n            case str():\n                self.currentPageNumber = self.getPageNumberFromName(page)\n            case int():\n                self.currentPageNumber = page\n        return self\n\n    def __len__(self) -&gt; int:\n        return len(self.bookmarks)\n</code></pre>"},{"location":"project/#arcpie.project.BookmarkMapSeries.__getitem__","title":"<code>__getitem__(page)</code>","text":"<p>Allow indexing the BookmarkMapSeries by name, index, or Bookmark object</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def __getitem__(self, page: int|str|_Bookmark) -&gt; BookmarkMapSeries:\n    \"\"\"Allow indexing the BookmarkMapSeries by name, index, or Bookmark object\"\"\"\n    match page:\n        case _Bookmark():\n            self.currentBookmark = page\n        case str():\n            self.currentPageNumber = self.getPageNumberFromName(page)\n        case int():\n            self.currentPageNumber = page\n    return self\n</code></pre>"},{"location":"project/#arcpie.project.Layer","title":"<code>Layer</code>","text":"<p>               Bases: <code>MappingWrapper[Layer]</code>, <code>Layer</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Layer(MappingWrapper[_Layer], _Layer):\n    @property\n    def feature_class(self) -&gt; FeatureClass[Any]:\n        \"\"\"Get a `arcpie.FeatureClass` object that is initialized using the layer and its current state\"\"\"\n        return FeatureClass[Any].from_layer(self)\n\n    @property\n    def symbology(self) -&gt; Any:\n        \"\"\"Get the base symbology object for the layer\"\"\"\n        return self._obj.symbology\n\n    @property\n    def lyrx(self) -&gt; dict[str, Any]:\n        \"\"\"Get a dictionary representation of the layer that can be saved to an lyrx file using `json.dumps`\n\n        Note:\n            GroupLayer objects will return a lyrx template with all sub-layers included\n        \"\"\"\n        if self.isWebLayer:\n            return {} # Web layers have no valid CIM\n        _def = json.loads(json.dumps(self.cim, cls=CimJsonEncoder))\n        if self.isGroupLayer and isinstance(self.parent, Map) and isinstance(self.cim, CIMGroupLayer):\n            _children: list[Layer] = [self.parent.layers.get(uri) for uri in self.cim_dict['layers']]\n            _lyrx: dict[str, Any] = {\n                'type': 'CIMLayerDocument',\n                'layers': [self.URI],\n                'layerDefinitions': [self.cim_dict] + [child.cim_dict for child in _children]\n            }\n        elif self.isFeatureLayer:\n            _lyrx: dict[str, Any] = { # Base required keys for lyrx file\n                'type': 'CIMLayerDocument',\n                'layers': [self.URI],\n                'layerDefinitions': [_def],\n            }\n        else:\n            _lyrx = {}\n        return _lyrx\n\n    @property\n    def cim(self) -&gt; LayerCimTypes:\n        \"\"\"Get the raw CIM V3 definition of the Layer, see `arcpy.cim` for more info\"\"\"\n        return self.getDefinition('V3')  # pyright: ignore[reportReturnType]\n\n    @property\n    def cim_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Get a dictionary representation of the layer CIM instead of a CIM object\"\"\"\n        return json.loads(json.dumps(self.cim, cls=CimJsonEncoder))\n</code></pre>"},{"location":"project/#arcpie.project.Layer.cim","title":"<code>cim</code>  <code>property</code>","text":"<p>Get the raw CIM V3 definition of the Layer, see <code>arcpy.cim</code> for more info</p>"},{"location":"project/#arcpie.project.Layer.cim_dict","title":"<code>cim_dict</code>  <code>property</code>","text":"<p>Get a dictionary representation of the layer CIM instead of a CIM object</p>"},{"location":"project/#arcpie.project.Layer.feature_class","title":"<code>feature_class</code>  <code>property</code>","text":"<p>Get a <code>arcpie.FeatureClass</code> object that is initialized using the layer and its current state</p>"},{"location":"project/#arcpie.project.Layer.lyrx","title":"<code>lyrx</code>  <code>property</code>","text":"<p>Get a dictionary representation of the layer that can be saved to an lyrx file using <code>json.dumps</code></p> Note <p>GroupLayer objects will return a lyrx template with all sub-layers included</p>"},{"location":"project/#arcpie.project.Layer.symbology","title":"<code>symbology</code>  <code>property</code>","text":"<p>Get the base symbology object for the layer</p>"},{"location":"project/#arcpie.project.Layout","title":"<code>Layout</code>","text":"<p>               Bases: <code>MappingWrapper[Layout]</code>, <code>Layout</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Layout(MappingWrapper[_Layout], _Layout):\n\n    @property\n    def mapseries(self) -&gt; MapSeries | BookmarkMapSeries| None:\n        \"\"\"Get the Layout MapSeries/BookmarkMapSeries if it exists\"\"\"\n        if not self.mapSeries:\n            return None\n        if isinstance(self.mapSeries, _MapSeries):\n            return MapSeries(self.mapSeries, self)\n        return BookmarkMapSeries(self.mapSeries, self)\n\n    def to_pdf(self, **settings: Unpack[PDFSetting]) -&gt; bytes:\n        \"\"\"Get the bytes for a pdf export of the Layout\n\n        Args:\n            **settings (PDFSetting): Optional settings for the export (default: `PDFDefault`)\n\n        Returns:\n            (BufferedReader): Byte stream of the printed PDF\n\n        Example:\n            ```python\n                # Get the layout object from a project file\n                lyt = prj.layouts['Layout_1']\n\n                # Create a pdf then write the output of to_pdf to it\n                pdf = Path('pdf_path').write_bytes(lyt.to_pdf())\n            ```   \n        \"\"\"\n        with NamedTemporaryFile() as tmp:\n            _settings = PDFDefault.copy()\n            for arg in _settings:\n                if val := settings.get(arg):\n                    _settings[arg] = val\n            pdf = self.exportToPDF(tmp.name, **_settings)\n            return Path(pdf).read_bytes()\n</code></pre>"},{"location":"project/#arcpie.project.Layout.mapseries","title":"<code>mapseries</code>  <code>property</code>","text":"<p>Get the Layout MapSeries/BookmarkMapSeries if it exists</p>"},{"location":"project/#arcpie.project.Layout.to_pdf","title":"<code>to_pdf(**settings)</code>","text":"<p>Get the bytes for a pdf export of the Layout</p> <p>Parameters:</p> Name Type Description Default <code>**settings</code> <code>PDFSetting</code> <p>Optional settings for the export (default: <code>PDFDefault</code>)</p> <code>{}</code> <p>Returns:</p> Type Description <code>BufferedReader</code> <p>Byte stream of the printed PDF</p> Example <pre><code>    # Get the layout object from a project file\n    lyt = prj.layouts['Layout_1']\n\n    # Create a pdf then write the output of to_pdf to it\n    pdf = Path('pdf_path').write_bytes(lyt.to_pdf())\n</code></pre> Source code in <code>src/arcpie/project.py</code> <pre><code>def to_pdf(self, **settings: Unpack[PDFSetting]) -&gt; bytes:\n    \"\"\"Get the bytes for a pdf export of the Layout\n\n    Args:\n        **settings (PDFSetting): Optional settings for the export (default: `PDFDefault`)\n\n    Returns:\n        (BufferedReader): Byte stream of the printed PDF\n\n    Example:\n        ```python\n            # Get the layout object from a project file\n            lyt = prj.layouts['Layout_1']\n\n            # Create a pdf then write the output of to_pdf to it\n            pdf = Path('pdf_path').write_bytes(lyt.to_pdf())\n        ```   \n    \"\"\"\n    with NamedTemporaryFile() as tmp:\n        _settings = PDFDefault.copy()\n        for arg in _settings:\n            if val := settings.get(arg):\n                _settings[arg] = val\n        pdf = self.exportToPDF(tmp.name, **_settings)\n        return Path(pdf).read_bytes()\n</code></pre>"},{"location":"project/#arcpie.project.Manager","title":"<code>Manager</code>","text":"<p>               Bases: <code>Generic[_MappingObject]</code></p> <p>Base access interfaces for all manager classes. Specific interfaces are defined in the subclass</p> <p>Index itentifiers are URI -&gt; longName -&gt; name depending on what is available in the managed class</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Manager(Generic[_MappingObject]):\n    \"\"\"Base access interfaces for all manager classes. Specific interfaces are defined in the subclass\n\n    Index itentifiers are URI -&gt; longName -&gt; name depending on what is available in the managed class\n    \"\"\"\n\n    def __init__(self, objs: Iterable[_MappingObject]) -&gt; None:\n        self._objects: dict[str, _MappingObject] = {\n            name_of(o): o \n            for o in objs\n        }\n\n    @property\n    def objects(self) -&gt; list[_MappingObject]:\n        \"\"\"Get a list of all managed objects\"\"\"\n        return list(self._objects.values())\n\n    @property\n    def names(self) -&gt; list[str]:\n        \"\"\"Get the names of all managed objects (skips URIs)\"\"\"\n        return [name_of(o, skip_uri=True) for o in self.objects]\n\n    @property\n    def uris(self) -&gt; list[str]:\n        \"\"\"Get URIs/CIMPATH for all managed objects\n\n        Note:\n            Default to a Python id() call if no URI is present\n        \"\"\"\n        return [name_of(o, uri_only=True) for o in self.objects]\n\n    @overload\n    def __getitem__(self, name: str) -&gt; _MappingObject: ...\n    @overload\n    def __getitem__(self, name: int) -&gt; _MappingObject: ...\n    @overload\n    def __getitem__(self, name: Wildcard) -&gt; list[_MappingObject]: ...\n    @overload\n    def __getitem__(self, name: re.Pattern[str]) -&gt; list[_MappingObject]: ...\n    @overload\n    def __getitem__(self, name: slice) -&gt; list[_MappingObject]: ...\n\n    def __getitem__(self, name: str|Wildcard|re.Pattern[str]|int|slice) -&gt; _MappingObject|list[_MappingObject]:\n        \"\"\"Access objects using a regex pattern (re.compile), wildcard (*STRING*), index, slice, name, or URI\"\"\"\n        if isinstance(name, str) and '*' in name:\n            name = Wildcard(name) # Allow passing a wildcard directly (lose type inference)\n        match name:\n            case int() | slice():\n                return self.objects[name] # Will raise IndexError\n            case re.Pattern():\n                return [o for o in self.objects if name.match(name_of(o, skip_uri=True))]\n            case Wildcard():\n                return [o for o in self.objects if all(part in name_of(o, skip_uri=True) for part in name.split('*'))]\n            case str(name) if name in self._objects:\n                return self._objects[name]\n            case str(name) if name in self.names:\n                for o in self.objects:\n                    if name_of(o, skip_uri=True) == name:\n                        return o\n            case _ :\n                pass # Fallthrough to raise a KeyError\n\n        raise KeyError(f'{name} not found in objects: ({self.names})')\n\n    @overload\n    def get(self, name: str) -&gt; _MappingObject: ...\n    @overload\n    def get(self, name: Wildcard) -&gt; list[_MappingObject]: ...\n    @overload\n    def get(self, name: str, default: _Default) -&gt; _MappingObject | _Default: ...\n    @overload\n    def get(self, name: Wildcard, default: _Default) -&gt; list[_MappingObject] | _Default: ...\n    def get(self, name: str|Wildcard, default: _Default|None=None) -&gt; _MappingObject|list[_MappingObject]|_Default|None:\n        \"\"\"Get a value from the Project with a safe default value\"\"\"\n        try:\n            return self[name]\n        except KeyError:\n            return default\n\n    def __contains__(self, name: str|_MappingObject) -&gt; bool:\n        \"\"\"Check to see if a URI/name is present in the Manager\"\"\"\n        match name:\n            case str():\n                return True if self.get(name) else False\n            case _:\n                return any(o == name for o in self.objects)\n\n    def __iter__(self) -&gt; Iterator[_MappingObject]:\n        return iter(self._objects.values())\n\n    def __len__(self) -&gt; int:\n        return len(self._objects)\n</code></pre>"},{"location":"project/#arcpie.project.Manager.names","title":"<code>names</code>  <code>property</code>","text":"<p>Get the names of all managed objects (skips URIs)</p>"},{"location":"project/#arcpie.project.Manager.objects","title":"<code>objects</code>  <code>property</code>","text":"<p>Get a list of all managed objects</p>"},{"location":"project/#arcpie.project.Manager.uris","title":"<code>uris</code>  <code>property</code>","text":"<p>Get URIs/CIMPATH for all managed objects</p> Note <p>Default to a Python id() call if no URI is present</p>"},{"location":"project/#arcpie.project.Manager.__contains__","title":"<code>__contains__(name)</code>","text":"<p>Check to see if a URI/name is present in the Manager</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def __contains__(self, name: str|_MappingObject) -&gt; bool:\n    \"\"\"Check to see if a URI/name is present in the Manager\"\"\"\n    match name:\n        case str():\n            return True if self.get(name) else False\n        case _:\n            return any(o == name for o in self.objects)\n</code></pre>"},{"location":"project/#arcpie.project.Manager.__getitem__","title":"<code>__getitem__(name)</code>","text":"<pre><code>__getitem__(name: str) -&gt; _MappingObject\n</code></pre><pre><code>__getitem__(name: int) -&gt; _MappingObject\n</code></pre><pre><code>__getitem__(name: Wildcard) -&gt; list[_MappingObject]\n</code></pre><pre><code>__getitem__(name: re.Pattern[str]) -&gt; list[_MappingObject]\n</code></pre><pre><code>__getitem__(name: slice) -&gt; list[_MappingObject]\n</code></pre> <p>Access objects using a regex pattern (re.compile), wildcard (STRING), index, slice, name, or URI</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def __getitem__(self, name: str|Wildcard|re.Pattern[str]|int|slice) -&gt; _MappingObject|list[_MappingObject]:\n    \"\"\"Access objects using a regex pattern (re.compile), wildcard (*STRING*), index, slice, name, or URI\"\"\"\n    if isinstance(name, str) and '*' in name:\n        name = Wildcard(name) # Allow passing a wildcard directly (lose type inference)\n    match name:\n        case int() | slice():\n            return self.objects[name] # Will raise IndexError\n        case re.Pattern():\n            return [o for o in self.objects if name.match(name_of(o, skip_uri=True))]\n        case Wildcard():\n            return [o for o in self.objects if all(part in name_of(o, skip_uri=True) for part in name.split('*'))]\n        case str(name) if name in self._objects:\n            return self._objects[name]\n        case str(name) if name in self.names:\n            for o in self.objects:\n                if name_of(o, skip_uri=True) == name:\n                    return o\n        case _ :\n            pass # Fallthrough to raise a KeyError\n\n    raise KeyError(f'{name} not found in objects: ({self.names})')\n</code></pre>"},{"location":"project/#arcpie.project.Manager.get","title":"<code>get(name, default=None)</code>","text":"<pre><code>get(name: str) -&gt; _MappingObject\n</code></pre><pre><code>get(name: Wildcard) -&gt; list[_MappingObject]\n</code></pre><pre><code>get(name: str, default: _Default) -&gt; _MappingObject | _Default\n</code></pre><pre><code>get(name: Wildcard, default: _Default) -&gt; list[_MappingObject] | _Default\n</code></pre> <p>Get a value from the Project with a safe default value</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def get(self, name: str|Wildcard, default: _Default|None=None) -&gt; _MappingObject|list[_MappingObject]|_Default|None:\n    \"\"\"Get a value from the Project with a safe default value\"\"\"\n    try:\n        return self[name]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"project/#arcpie.project.Map","title":"<code>Map</code>","text":"<p>               Bases: <code>Map</code>, <code>MappingWrapper[Map]</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Map(_Map, MappingWrapper[_Map]):\n    @property\n    def layers(self) -&gt; LayerManager:\n        \"\"\"Get a LayerManager for all layers in the Map\"\"\"\n        return LayerManager(Layer(l, self) for l in self.listLayers())\n\n    @property\n    def tables(self) -&gt; TableManager:\n        \"\"\"Get a TableManager for all tables in the Map\"\"\"\n        return TableManager(Table(t, self) for t in self.listTables())\n\n    @property\n    def bookmarks(self) -&gt; BookmarkManager:\n        \"\"\"Get a BookmarkManager for all bookmarks in the Map\"\"\"\n        return BookmarkManager(Bookmark(b, self) for b in self.listBookmarks())\n\n    @property\n    def elevation_surfaces(self) -&gt; ElevationSurfaceManager:\n        \"\"\"Get an ElevationSurfaceManager for all elevation surfaces in the Map\"\"\"\n        return ElevationSurfaceManager(ElevationSurface(es, self) for es in self.listElevationSurfaces())\n</code></pre>"},{"location":"project/#arcpie.project.Map.bookmarks","title":"<code>bookmarks</code>  <code>property</code>","text":"<p>Get a BookmarkManager for all bookmarks in the Map</p>"},{"location":"project/#arcpie.project.Map.elevation_surfaces","title":"<code>elevation_surfaces</code>  <code>property</code>","text":"<p>Get an ElevationSurfaceManager for all elevation surfaces in the Map</p>"},{"location":"project/#arcpie.project.Map.layers","title":"<code>layers</code>  <code>property</code>","text":"<p>Get a LayerManager for all layers in the Map</p>"},{"location":"project/#arcpie.project.Map.tables","title":"<code>tables</code>  <code>property</code>","text":"<p>Get a TableManager for all tables in the Map</p>"},{"location":"project/#arcpie.project.MapSeries","title":"<code>MapSeries</code>","text":"<p>               Bases: <code>MappingWrapper[MapSeries]</code>, <code>MapSeries</code></p> <p>Wrapper around an arcpy.mp MapSeries object that provides an ergonomic interface</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class MapSeries(MappingWrapper[_MapSeries], _MapSeries):\n    \"\"\"Wrapper around an arcpy.mp MapSeries object that provides an ergonomic interface\"\"\"\n    @property\n    def layer(self) -&gt; Layer:\n        \"\"\"Get the mapseries target layer\"\"\"\n        return Layer(self.indexLayer, self.map)\n\n    @property # Passthrough\n    def feature_class(self) -&gt; FeatureClass[Any]:\n        \"\"\"Get the FeatureClass of the parent layer\"\"\"\n        return self.layer.feature_class\n\n    @property\n    def map(self) -&gt; Map:\n        \"\"\"Get the map object that is being seriesed\"\"\"\n        return Map(self.mapFrame.map, self.parent.parent) #type: ignore (if a MapSeries is initialized this will be a map)\n\n    @property\n    def pageRow(self): # type: ignore (prevent access to uninitialized pageRow raising RuntimeError)\n        \"\"\"Get a Row object for the active mapseries page\"\"\"\n        try:\n            return self._obj.pageRow\n        except RuntimeError:\n            return None\n\n    @property\n    def page_field(self) -&gt; str:\n        \"\"\"Get fieldname used as pagename\"\"\"\n        return self.pageNameField.name\n\n    @cached_property\n    def page_field_names(self) -&gt; list[str]:\n        \"\"\"Get all fieldnames for the mapseriesed features\"\"\"\n        return [f for f in self.feature_class.fields if not f.startswith('@')]\n\n    @property\n    def valid_pages(self) -&gt; list[str]:\n        \"\"\"Get all valid page names for the MapSeries\"\"\"\n        return list(self.feature_class[self.page_field])\n\n    @property\n    def page_values(self) -&gt; dict[str, Any]:\n        \"\"\"Get a mapping of values for the current page\"\"\"\n        if not self.pageRow:\n            return {} # pageRow is unset with no active page\n\n        # Need to access a private `_asdict` method of Row because getValue is broken\n        return {f: self.pageRow._asdict().get(f) for f in self.page_field_names}\n\n    @property\n    def current_page_name(self) -&gt; str:\n        \"\"\"Get the name of the active mapseries page\"\"\"\n        return self.page_values.get(self.page_field, 'No Page')\n\n    def to_pdf(self, **settings: Unpack[MapSeriesPDFSetting]) -&gt; bytes:\n        \"\"\"Export the MapSeries to a PDF, See Layer.to_pdf for more info\n\n        Args:\n            **settings (Unpack[MapSeriesPDFSetting]): Passthrough kwargs for layout.exportToPDF\n\n        Note:\n            By default, printing a mapseries will print all pages to a single file. To only print\n            the active page:\n            ```python\n            &gt;&gt;&gt; ms.to_pdf(page_range_type='CURRENT')\n            ```\n        \"\"\"\n        _settings = MapseriesPDFDefault.copy()\n        _settings.update(settings)\n        with NamedTemporaryFile() as tmp:\n            return Path(self.exportToPDF(tmp.name, **_settings)).read_bytes()\n\n    def __iter__(self) -&gt; Iterator[MapSeries]:\n        _orig_page = self.currentPageNumber\n        for page in range(1, self.pageCount):\n            self.currentPageNumber = page\n            yield self\n        if _orig_page:\n            self.currentPageNumber = _orig_page\n\n    def __getitem__(self, page: int|str) -&gt; MapSeries:\n        \"\"\"Allow indexing a mapseries by a page name or a page index/number\"\"\"\n        match page:\n            case str():\n                if page not in self.valid_pages:\n                    raise KeyError(f\"{page} is not a valid page name!\")\n                self.currentPageNumber = self.getPageNumberFromName(page)\n            case int():\n                if page not in range(1, self.pageCount):\n                    raise IndexError(f\"{self} only has {self.pageCount} pages, {page} out of range\")\n                self.currentPageNumber = page\n        return self\n\n    def __len__(self) -&gt; int:\n        return self.pageCount\n\n    def __repr__(self) -&gt; str:\n        return f'MapSeries&lt;{self.layer.name} @ {self.current_page_name}&gt;'\n</code></pre>"},{"location":"project/#arcpie.project.MapSeries.current_page_name","title":"<code>current_page_name</code>  <code>property</code>","text":"<p>Get the name of the active mapseries page</p>"},{"location":"project/#arcpie.project.MapSeries.feature_class","title":"<code>feature_class</code>  <code>property</code>","text":"<p>Get the FeatureClass of the parent layer</p>"},{"location":"project/#arcpie.project.MapSeries.layer","title":"<code>layer</code>  <code>property</code>","text":"<p>Get the mapseries target layer</p>"},{"location":"project/#arcpie.project.MapSeries.map","title":"<code>map</code>  <code>property</code>","text":"<p>Get the map object that is being seriesed</p>"},{"location":"project/#arcpie.project.MapSeries.pageRow","title":"<code>pageRow</code>  <code>property</code>","text":"<p>Get a Row object for the active mapseries page</p>"},{"location":"project/#arcpie.project.MapSeries.page_field","title":"<code>page_field</code>  <code>property</code>","text":"<p>Get fieldname used as pagename</p>"},{"location":"project/#arcpie.project.MapSeries.page_field_names","title":"<code>page_field_names</code>  <code>cached</code> <code>property</code>","text":"<p>Get all fieldnames for the mapseriesed features</p>"},{"location":"project/#arcpie.project.MapSeries.page_values","title":"<code>page_values</code>  <code>property</code>","text":"<p>Get a mapping of values for the current page</p>"},{"location":"project/#arcpie.project.MapSeries.valid_pages","title":"<code>valid_pages</code>  <code>property</code>","text":"<p>Get all valid page names for the MapSeries</p>"},{"location":"project/#arcpie.project.MapSeries.__getitem__","title":"<code>__getitem__(page)</code>","text":"<p>Allow indexing a mapseries by a page name or a page index/number</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def __getitem__(self, page: int|str) -&gt; MapSeries:\n    \"\"\"Allow indexing a mapseries by a page name or a page index/number\"\"\"\n    match page:\n        case str():\n            if page not in self.valid_pages:\n                raise KeyError(f\"{page} is not a valid page name!\")\n            self.currentPageNumber = self.getPageNumberFromName(page)\n        case int():\n            if page not in range(1, self.pageCount):\n                raise IndexError(f\"{self} only has {self.pageCount} pages, {page} out of range\")\n            self.currentPageNumber = page\n    return self\n</code></pre>"},{"location":"project/#arcpie.project.MapSeries.to_pdf","title":"<code>to_pdf(**settings)</code>","text":"<p>Export the MapSeries to a PDF, See Layer.to_pdf for more info</p> <p>Parameters:</p> Name Type Description Default <code>**settings</code> <code>Unpack[MapSeriesPDFSetting]</code> <p>Passthrough kwargs for layout.exportToPDF</p> <code>{}</code> Note <p>By default, printing a mapseries will print all pages to a single file. To only print the active page: <pre><code>&gt;&gt;&gt; ms.to_pdf(page_range_type='CURRENT')\n</code></pre></p> Source code in <code>src/arcpie/project.py</code> <pre><code>def to_pdf(self, **settings: Unpack[MapSeriesPDFSetting]) -&gt; bytes:\n    \"\"\"Export the MapSeries to a PDF, See Layer.to_pdf for more info\n\n    Args:\n        **settings (Unpack[MapSeriesPDFSetting]): Passthrough kwargs for layout.exportToPDF\n\n    Note:\n        By default, printing a mapseries will print all pages to a single file. To only print\n        the active page:\n        ```python\n        &gt;&gt;&gt; ms.to_pdf(page_range_type='CURRENT')\n        ```\n    \"\"\"\n    _settings = MapseriesPDFDefault.copy()\n    _settings.update(settings)\n    with NamedTemporaryFile() as tmp:\n        return Path(self.exportToPDF(tmp.name, **_settings)).read_bytes()\n</code></pre>"},{"location":"project/#arcpie.project.MappingWrapper","title":"<code>MappingWrapper</code>","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Internal wrapper class for wrapping existing objects with new functionality</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class MappingWrapper(Generic[_T]):\n    \"\"\"Internal wrapper class for wrapping existing objects with new functionality\"\"\"\n    def __init__(self, obj: _T, parent: _MappingObject|Project|None=None) -&gt; None:\n        self._obj = obj\n        self._parent = parent\n\n    @property\n    def parent(self):\n        \"\"\"The parent object for the wrapper\n\n        `Project -&gt; Map -&gt; Layer`\\n\n        `Project -&gt; Layout -&gt; Map -&gt; MapSeries`\\n\n        `Project -&gt; Report`\n\n        The general parent/child relationships are based on how you would access the object in ArcPro.\n        Projects have maps, maps have layers, layouts have mapseries etc.\n        \"\"\"\n        return self._parent\n\n    def __getattr__(self, attr: str) -&gt; Any:\n        return getattr(self._obj, attr)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self._obj.__class__.__name__}({name_of(self._obj, skip_uri=True)})\"\n\n    def __eq__(self, other: MappingWrapper[Any] | object) -&gt; bool:\n        if hasattr(other, '_obj'):\n            return self._obj is getattr(other, '_obj', None)\n        else:\n            return super().__eq__(other)\n</code></pre>"},{"location":"project/#arcpie.project.MappingWrapper.parent","title":"<code>parent</code>  <code>property</code>","text":"<p>The parent object for the wrapper</p> <p><code>Project -&gt; Map -&gt; Layer</code></p> <p><code>Project -&gt; Layout -&gt; Map -&gt; MapSeries</code></p> <p><code>Project -&gt; Report</code></p> <p>The general parent/child relationships are based on how you would access the object in ArcPro. Projects have maps, maps have layers, layouts have mapseries etc.</p>"},{"location":"project/#arcpie.project.Project","title":"<code>Project</code>","text":"<p>Wrapper for an ArcGISProject (.aprx)</p> Usage <pre><code>&gt;&gt;&gt; prj = Project('&lt;path/to/aprx&gt;')\n&gt;&gt;&gt; lay = prj.layouts.get('My Layout')\n&gt;&gt;&gt; Path('My Layout.pdf').write_bytes(prj.layouts.get('My Layout').to_pdf())\n4593490 # Bytes written\n&gt;&gt;&gt; for map in prj.maps:\n...     print(f'{map.name} has {len(map.layers)} layers')\nMy Map has 5 layers\nMy Map 2 has 15 layers\nOther Map has 56 layers\n</code></pre> Source code in <code>src/arcpie/project.py</code> <pre><code>class Project:\n    \"\"\"Wrapper for an ArcGISProject (.aprx)\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; prj = Project('&lt;path/to/aprx&gt;')\n        &gt;&gt;&gt; lay = prj.layouts.get('My Layout')\n        &gt;&gt;&gt; Path('My Layout.pdf').write_bytes(prj.layouts.get('My Layout').to_pdf())\n        4593490 # Bytes written\n        &gt;&gt;&gt; for map in prj.maps:\n        ...     print(f'{map.name} has {len(map.layers)} layers')\n        My Map has 5 layers\n        My Map 2 has 15 layers\n        Other Map has 56 layers\n        ```\n    \"\"\"\n    def __init__(self, aprx_path: str|Path|Literal['CURRRENT']='CURRENT') -&gt; None:\n        self._path = str(aprx_path)\n\n    def __repr__(self) -&gt; str:\n        return f\"Project({Path(self.aprx.filePath).stem}.aprx)\"\n\n    @cached_property\n    def name(self) -&gt; str:\n        \"\"\"Get the file name of the wrapped aprx minus the file extension\"\"\"\n        return Path(self.aprx.filePath).stem\n\n    @cached_property\n    def aprx(self) -&gt; ArcGISProject:\n        \"\"\"Get the base ArcGISProject for the Project\"\"\"\n        return ArcGISProject(self._path)\n\n    @cached_property\n    def maps(self) -&gt; MapManager:\n        \"\"\"Get a MapManager for the Project maps\"\"\"\n        return MapManager(Map(m, self) for m in self.aprx.listMaps())\n\n    @cached_property\n    def layouts(self) -&gt; LayoutManager:\n        \"\"\"Get a LayoutManager for the Project layouts\"\"\"\n        return LayoutManager(Layout(l, self) for l in self.aprx.listLayouts())\n\n    @cached_property\n    def reports(self) -&gt; ReportManager:\n        \"\"\"Get a ReportManager for the Project reports\"\"\"\n        return ReportManager(Report(r, self) for r in self.aprx.listReports())\n\n    @cached_property\n    def broken_layers(self) -&gt; LayerManager:\n        \"\"\"Get a LayerManager for all layers in the project with broken datasources\"\"\"\n        return LayerManager(Layer(l, self) for l in self.aprx.listBrokenDataSources() if isinstance(l, _Layer))\n\n    @cached_property\n    def broken_tables(self) -&gt; TableManager:\n        \"\"\"Get a TableManager for all tables in the project with broken datasources\"\"\"\n        return TableManager(Table(t, self) for t in self.aprx.listBrokenDataSources() if isinstance(t, _Table))\n\n    def refresh(self, *, managers: Sequence[str]|None=None) -&gt; None:\n        \"\"\"Clear cached object managers\n\n        Args:\n            managers (Sequence[str]|None): Optionally limit cache clearing to certain managers (attribute name)\n        \"\"\"\n        for prop in list(self.__dict__):\n            if prop.startswith('_') or managers and prop not in managers:\n                continue # Skip private instance attributes and non-requested\n            self.__dict__.pop(prop, None)\n</code></pre>"},{"location":"project/#arcpie.project.Project.aprx","title":"<code>aprx</code>  <code>cached</code> <code>property</code>","text":"<p>Get the base ArcGISProject for the Project</p>"},{"location":"project/#arcpie.project.Project.broken_layers","title":"<code>broken_layers</code>  <code>cached</code> <code>property</code>","text":"<p>Get a LayerManager for all layers in the project with broken datasources</p>"},{"location":"project/#arcpie.project.Project.broken_tables","title":"<code>broken_tables</code>  <code>cached</code> <code>property</code>","text":"<p>Get a TableManager for all tables in the project with broken datasources</p>"},{"location":"project/#arcpie.project.Project.layouts","title":"<code>layouts</code>  <code>cached</code> <code>property</code>","text":"<p>Get a LayoutManager for the Project layouts</p>"},{"location":"project/#arcpie.project.Project.maps","title":"<code>maps</code>  <code>cached</code> <code>property</code>","text":"<p>Get a MapManager for the Project maps</p>"},{"location":"project/#arcpie.project.Project.name","title":"<code>name</code>  <code>cached</code> <code>property</code>","text":"<p>Get the file name of the wrapped aprx minus the file extension</p>"},{"location":"project/#arcpie.project.Project.reports","title":"<code>reports</code>  <code>cached</code> <code>property</code>","text":"<p>Get a ReportManager for the Project reports</p>"},{"location":"project/#arcpie.project.Project.refresh","title":"<code>refresh(*, managers=None)</code>","text":"<p>Clear cached object managers</p> <p>Parameters:</p> Name Type Description Default <code>managers</code> <code>Sequence[str] | None</code> <p>Optionally limit cache clearing to certain managers (attribute name)</p> <code>None</code> Source code in <code>src/arcpie/project.py</code> <pre><code>def refresh(self, *, managers: Sequence[str]|None=None) -&gt; None:\n    \"\"\"Clear cached object managers\n\n    Args:\n        managers (Sequence[str]|None): Optionally limit cache clearing to certain managers (attribute name)\n    \"\"\"\n    for prop in list(self.__dict__):\n        if prop.startswith('_') or managers and prop not in managers:\n            continue # Skip private instance attributes and non-requested\n        self.__dict__.pop(prop, None)\n</code></pre>"},{"location":"project/#arcpie.project.Table","title":"<code>Table</code>","text":"<p>               Bases: <code>MappingWrapper[Table]</code>, <code>Table</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Table(MappingWrapper[_Table], _Table):\n    @property\n    def table(self) -&gt; DataTable:\n        \"\"\"Get an `arcpie.Table` object from the TableLayer\"\"\"\n        return DataTable.from_table(self)\n</code></pre>"},{"location":"project/#arcpie.project.Table.table","title":"<code>table</code>  <code>property</code>","text":"<p>Get an <code>arcpie.Table</code> object from the TableLayer</p>"},{"location":"project/#arcpie.project.Wildcard","title":"<code>Wildcard</code>","text":"<p>               Bases: <code>UserString</code></p> <p>Clarify that the string passed to a Manager index is a wildcard so the type checker knows you're getting a Sequence back</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Wildcard(UserString): \n    \"\"\"Clarify that the string passed to a Manager index is a wildcard so the type checker knows you're getting a Sequence back\"\"\"\n    pass\n</code></pre>"},{"location":"project/#arcpie.project.name_of","title":"<code>name_of(o, skip_uri=False, uri_only=False)</code>","text":"<p>Handle the naming hierarchy of mapping objects URI -&gt; longName -&gt; name</p> <p>Allow setting flags to get specific names</p> Note <p>If a URI is requested and no <code>URI</code> attribute is available in object,  <code>'obj.name: NO URI(id(obj))'</code> will be returned, e.g. <code>'my_bookmark: NO URI(1239012093)'</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>def name_of(o: Any, skip_uri: bool=False, uri_only: bool=False) -&gt; str:\n    \"\"\"Handle the naming hierarchy of mapping objects URI -&gt; longName -&gt; name\n\n    Allow setting flags to get specific names\n\n    Note:\n        If a URI is requested and no `URI` attribute is available in object, \n        `'obj.name: NO URI(id(obj))'` will be returned, e.g. `'my_bookmark: NO URI(1239012093)'`\n    \"\"\"\n    _uri: str|None = getattr(o, 'URI', None) if not skip_uri else None\n    _long_name: str|None = getattr(o, 'longName', None) # longName will identify Grouped Layers\n    _name: str|None = getattr(o, 'name', None)\n    _id: str = str(id(o)) # Fallback to a locally unique id (should never happen)\n    if uri_only:\n        return _uri or f\"{_name}: NO URI({id(o)})\"\n    return _uri or _long_name or _name or _id\n</code></pre>"},{"location":"toolbox/","title":"toolbox","text":""},{"location":"toolbox/#arcpie.toolbox.Parameters","title":"<code>Parameters</code>","text":"<p>               Bases: <code>list[Parameter]</code></p> <p>Wrap a list of parameters and override the index to allow indexing by name</p> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class Parameters(list[Parameter]):\n    \"\"\"Wrap a list of parameters and override the index to allow indexing by name\"\"\"\n    @overload\n    def __getitem__(self, key: SupportsIndex, /) -&gt; Parameter: ...\n    @overload\n    def __getitem__(self, key: slice, /) -&gt; list[Parameter]: ...\n    @overload\n    def __getitem__(self, key: str, /) -&gt; Parameter: ...\n    def __getitem__(self, key: SupportsIndex|slice|str, /) -&gt; Parameter | list[Parameter]:\n        if isinstance(key, str):\n            _matches = [p for p in self if p.name == key]\n            if not _matches:\n                raise KeyError(key)\n            if len(_matches) == 1:\n                return _matches.pop()\n            raise KeyError(f'{key} is used for multiple parameters')\n        return self[key]\n</code></pre>"},{"location":"toolbox/#arcpie.toolbox.ToolABC","title":"<code>ToolABC</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class ToolABC(ABC):\n    def __init__(self) -&gt; None:\n        self.label: str\n        self.description: str\n        self.category: str\n        self._project: ArcGISProject|None = None\n\n    @property\n    def project(self) -&gt; ArcGISProject | None:\n        \"\"\"Get the current project that the tool is running in if it exists (otherwise: None)\"\"\"\n        if self._project is None:\n            try:\n                self._project = ArcGISProject('CURRENT')\n            except Exception:\n                pass\n        return self._project\n\n    def getParameterInfo(self) -&gt; Parameters | list[Parameter]: return Parameters()\n    def isLicensed(self) -&gt; bool: return True\n    def updateParameters(self, parameters: Parameters | list[Parameter]) -&gt; None: ...\n    def updateMessages(self, parameters: Parameters | list[Parameter]) -&gt; None: ...\n    def execute(self, parameters: Parameters | list[Parameter], messages: list[Any]) -&gt; None: ...\n    def postExecute(self, parameters: Parameters | list[Parameter]) -&gt; None: ...\n</code></pre>"},{"location":"toolbox/#arcpie.toolbox.ToolABC.project","title":"<code>project</code>  <code>property</code>","text":"<p>Get the current project that the tool is running in if it exists (otherwise: None)</p>"},{"location":"utils/","title":"utils","text":"<p>Module for internal utility functions to share between modules</p>"},{"location":"utils/#arcpie.utils.export_project_lyrx","title":"<code>export_project_lyrx(project, out_dir, *, indent=4, sort=False, skip_errors=False)</code>","text":"<p>Pull all layers from a project file and output them in a directory as lyrx files</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>The <code>arcpie.Project</code> instance to export</p> required <code>out_dir</code> <code>Path | str</code> <p>The target directory for the layer files</p> required <code>indent</code> <code>int</code> <p>Indentation level of the ouput files (default: 4)</p> <code>4</code> <code>sort</code> <code>bool</code> <p>Sort the output file by key name (default: False)</p> <code>False</code> <code>skip_errors</code> <code>bool</code> <p>Skip any layers that fail to be converted to LYRX (default: False)</p> <code>False</code> <p>Raises:</p> Type Description <code>JSONDecodeError</code> <p>If the <code>skip_errors</code> flag is not set, otherwise the error is printed</p> Usage <pre><code>&gt;&gt;&gt; export_project_lyrx(arcpie.Project('&lt;path/to/aprx&gt;'), '&lt;path/to/output_dir&gt;')\n</code></pre> Note <p>Output structure will match the structure of the project: <code>Map -&gt; Group -&gt; Layer</code> Where each level is a directory. Group Layers will have a directory entry with individual files for each layer they contain, as well as a single layerfile that contains all their  child layers.</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def export_project_lyrx(project: Project, out_dir: Path, *, indent: int=4, sort: bool=False, skip_errors: bool=False) -&gt; None:\n    \"\"\"Pull all layers from a project file and output them in a directory as lyrx files\n\n    Args:\n        project (Project): The `arcpie.Project` instance to export\n        out_dir (Path|str): The target directory for the layer files\n        indent (int): Indentation level of the ouput files (default: 4)\n        sort (bool): Sort the output file by key name (default: False)\n        skip_errors (bool): Skip any layers that fail to be converted to LYRX (default: False)\n\n    Raises:\n        (JSONDecodeError) : If the `skip_errors` flag is not set, otherwise the error is printed\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; export_project_lyrx(arcpie.Project('&lt;path/to/aprx&gt;'), '&lt;path/to/output_dir&gt;')\n        ```\n\n    Note:\n        Output structure will match the structure of the project:\n        `Map -&gt; Group -&gt; Layer`\n        Where each level is a directory. Group Layers will have a directory entry with individual\n        files for each layer they contain, as well as a single layerfile that contains all their \n        child layers.\n    \"\"\"\n    out_dir = Path(out_dir)\n    for map in project.maps:\n        map_dir = out_dir / map.name\n        for layer in map.layers:\n            out_file = (map_dir / layer.longName).with_suffix('.lyrx')\n            out_file.parent.mkdir(parents=True, exist_ok=True)\n            try:\n                out_file.write_text(json.dumps(layer.lyrx, indent=indent, sort_keys=sort), encoding='utf-8')\n            except json.JSONDecodeError as e:\n                if not skip_errors:\n                    raise e\n                print(f'Failed to write {map.name}-&gt;{layer.longName}: {e}')\n</code></pre>"},{"location":"utils/#arcpie.utils.get_subtype_count","title":"<code>get_subtype_count(fc, drop_empty=False)</code>","text":"<p>Get the subtype counts for a Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>Table | FeatureClass</code> <p>The Table/FeatureClass you want subtype counts for</p> required <code>drop_empty</code> <code>bool</code> <p>Drop any counts that have no features from the output dictionary (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>A mapping of subtype name to subtype count</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def get_subtype_count(fc: Table | FeatureClass[Any], drop_empty: bool=False) -&gt; dict[str, int]:\n    \"\"\"Get the subtype counts for a Table or FeatureClass\n\n    Args:\n        fc (Table | FeatureClass): The Table/FeatureClass you want subtype counts for\n        drop_empty (bool): Drop any counts that have no features from the output dictionary (default: False)\n\n    Returns:\n        (dict[str, int]): A mapping of subtype name to subtype count\n    \"\"\"\n    return {\n        subtype['Name']: cnt\n        for code, subtype in fc.subtypes.items() \n        if fc.subtype_field # has Subtypes\n        and (\n            (cnt := count(fc[where(f'{fc.subtype_field} = {code}')])) # Get count\n            or drop_empty # Drop Empty counts?\n        )\n    }\n</code></pre>"},{"location":"utils/#arcpie.utils.get_subtype_counts","title":"<code>get_subtype_counts(gdb, *, drop_empty=False)</code>","text":"<p>Get a mapping of subtype counts for all featureclasses that have subtypes in the provided Dataset</p> <p>Parameters:</p> Name Type Description Default <code>gdb</code> <code>Dataset</code> <p>The Dataset instance to get subtype counts for</p> required <code>drop_empty</code> <code>bool</code> <p>Drop any counts that have no features from the output dictionary (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, dict[str, int]]</code> <p>A mapping of FeatureClass -&gt; SubtypeName -&gt; SubtypeCount</p> Usage <pre><code>&gt;&gt;&gt; get_subtype_counts(Dataset('&lt;path/to/gdb&gt;', drop_empty=True))\n{\n    'FC1': \n        {\n            'Default': 10\n            'Subtype 1': 6\n            ...\n        },\n    ...\n}\n</code></pre> Source code in <code>src/arcpie/utils.py</code> <pre><code>def get_subtype_counts(gdb: Dataset, *, drop_empty: bool=False) -&gt; dict[str, dict[str, int]]:\n    \"\"\"Get a mapping of subtype counts for all featureclasses that have subtypes in the provided Dataset\n\n    Args:\n        gdb (Dataset): The Dataset instance to get subtype counts for\n        drop_empty (bool): Drop any counts that have no features from the output dictionary (default: False)\n\n    Returns:\n        (dict[str, dict[str, int]]): A mapping of FeatureClass -&gt; SubtypeName -&gt; SubtypeCount\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; get_subtype_counts(Dataset('&lt;path/to/gdb&gt;', drop_empty=True))\n        {\n            'FC1': \n                {\n                    'Default': 10\n                    'Subtype 1': 6\n                    ...\n                },\n            ...\n        }\n        ```  \n    \"\"\"\n    feats: list[Table] = [*gdb.feature_classes.values(), *gdb.tables.values()]\n    return {\n        fc.name: counts\n        for fc in feats\n        if (counts := get_subtype_count(fc))\n        or not drop_empty\n    }\n</code></pre>"},{"location":"utils/#arcpie.utils.nat","title":"<code>nat(val)</code>","text":"<p>Natural sort key for use in string sorting</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>str</code> <p>A value that you want the natural sort key for</p> required <p>Returns:</p> Type Description <code>tuple[tuple[int, ...], tuple[str, ...]</code> <p>A tuple containing all numeric and </p> <code>tuple[str, ...]</code> <p>string components in order of appearance. Best used as a sort key</p> Usage <pre><code>&gt;&gt;&gt; pages = ['P-1.3', 'P-2.11', ...]\n&gt;&gt;&gt; pages.sort(key=nat)\n&gt;&gt;&gt; print(pages)\n['P-1.1', 'P-1.2', ...]\n</code></pre> Source code in <code>src/arcpie/utils.py</code> <pre><code>def nat(val: str) -&gt; tuple[tuple[int, ...], tuple[str, ...]]:\n    \"\"\"Natural sort key for use in string sorting\n\n    Args:\n        val (str): A value that you want the natural sort key for\n\n    Returns:\n        (tuple[tuple[int, ...], tuple[str, ...]): A tuple containing all numeric and \n        string components in order of appearance. Best used as a sort key\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; pages = ['P-1.3', 'P-2.11', ...]\n        &gt;&gt;&gt; pages.sort(key=nat)\n        &gt;&gt;&gt; print(pages)\n        ['P-1.1', 'P-1.2', ...]\n        ```\n    \"\"\"\n    _digits: list[int] = []\n    _alpha: list[str] = []\n    _digit_chars: list[str] = []\n    for s in val:\n       if s.isdigit():\n          _digit_chars.append(s)\n       else:\n          _alpha.append(s)\n          if _digit_chars:\n             _digits.append(int(''.join(_digit_chars)))\n             _digit_chars = []\n    if _digit_chars:\n       _digits.append(int(''.join(_digit_chars)))\n    return tuple(_digits), tuple(_alpha)\n</code></pre>"}]}