{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"arcpie","text":"<p>A simple interface for working with arcpy Featureclasses</p>"},{"location":"#the-old","title":"The Old","text":"<pre><code>import arcpy\n\nfc1 = r'C:\\Data\\db.gdb\\FC1'\nfc2 = r'C:\\Data\\db.gdb\\FC2'\nl1 = arcpy.management.MakeFeatureLayer(fc1, 'memory/fc1', 'size &gt; 10')\nl2 = arcpy.management.MakeFeatureLayer(fc2, 'memory/fc2')\narcpy.management.SelectLayerByLocation(l2, fc1)\nprint(arcpy.management.getCount(l2)[0])\n</code></pre>"},{"location":"#the-new","title":"The New","text":"<pre><code>from arcpie import FeatureClass, count\n\nfc1 = FeatureClass[Polyline](r'C:\\Data\\db.gdb\\FC1')\nfc2 = FeatureClass[PointGeometry](r'C:\\Data\\db.gdb\\FC2')\n\nwith fc1.where('length &gt; 10'):\n    print(count(fc2[fc1.footprint()])\n\ndef under(dist: int) -&gt; Callable:\n    def _inner(row: dict[str, Any]) -&gt; bool:\n        return row['SHAPE@'].length &lt; dist\n    return _inner\n\nfor row in fc1[under(10)]:\n    print(row)\n\nfor oid, shape in fc1[('OID@', 'SHAPE@')]:\n    print(f'{fc1.name} {oid} is {shape.length} {fc1.unit_name} long'\n\nref = SpatialReference(4326)\nwith fc1.projection_as(ref):\n    for oid, shape in fc1[('OID@', 'SHAPE@')]:\n        print(f'{fc1.name} {oid} is {shape.length} {ref.linearUnitName} long' \n</code></pre>"},{"location":"examples/1_getting-started/","title":"Getting Started (Coming Soon)","text":""},{"location":"examples/2_feature-interaction/","title":"Basics","text":"<p>arcpie is designed to be an easy drop in alongside arcpy proper that aligns interaction with geospatial objects closer to the  Python model.</p> <p>Here's a simple example of summing up the total length of road in a city: <pre><code>from arcpy import Polyline, Polygon\nfrom arcpie import FeatureClass\n\nroads = FeatureClass[Polyline]('Roads')\ncities = FeatureClass[Polygon]('Cities')\n\nfor city_name, city_boundary in cities[('Name', 'SHAPE@')]:\n    with roads.spatial_filter(city_boundary): # Apply a spatial filter\n        road_length = sum(\n            road.intersect(city, 2).length # Clip road to city limits\n            for road in roads.shapes # Iterate the road shapes\n        )\n    print(f'{city_name} has {road_length} {roads.units} of road')\n</code></pre></p> <p>Here we accomplish quite a bit with a single simple comprehension and a flat feature iterator! Here's that same code written using base arcpy:</p> <pre><code>from arcpy.da import SearchCursor\n\nwith SearchCursor('Cities', ['Name', 'SHAPE@']) as city_cur:\n    for city_name, city_boundary in city_cur: # Iterate cities\n        road_length = 0.0 # Initialize road length\n        road_units = None\n        with SearchCursor('Roads', ['SHAPE@'], spatial_filter=city_boundary) as road_cur: # Iterate Roads\n            for road, in road_cur:\n                if road_units is None:\n                    road_units = road.spatialReference.linearUnitName\n                road_length += road.intersect(city_boundary, 2).length # Clip and add\n\n        print(f'{city_name} has {road_length} {road_units} of road')\n</code></pre> <p>Lets see what else we can do with that <code>FeatureClass</code> object:</p> <pre><code>from arcpie import FeatureClass, RowRecord, FilterFunc, count\n\n# Create a dynamic filter function that counts the number of\n# lines in a text field\ndef line_count(field: str, line_count: int):\n    def _inner(func: FilterFunc) -&gt; bool:\n        return len(row[field].splitlines()) == lines\n    return _inner\n\nnotes = FeatureClass('FieldNotes')\n\nprint(count(notes[line_count('COMMENTS', 5)]))\n# prints 50\n\nprint(count(notes[line_count('COMMENTS', 2)]))\n# prints 245\n</code></pre> <p>Here we used a function index that allows you to define a condition for row iteration. The <code>arcpie.count()</code> function is just an alias for <code>sum(1 for _ in Iterator)</code> since all FeatureClass indexes are iterators and do not have a known length until they are exhausted.</p>"},{"location":"modules/cursor/","title":"cursor","text":"<p>Cursor Helper module</p> <p>Classes:</p> Name Description <code>Field</code> <p>Field Representation</p> <code>InsertOptions</code> <p>Optional parameters for InsertCursors</p> <code>SQLClause</code> <p>Wrapper for Cursor sql_clause attribute,</p> <code>SearchOptions</code> <p>Optional parameters for SearchCursors</p> <code>UpdateOptions</code> <p>Optional parameters for UpdateCursors</p> <code>WhereClause</code> <p>Wraps a string clause to signal to FeatureClass/Table indexes that a Where Clause is being passed</p> <p>Functions:</p> Name Description <code>convert_field</code> <p>Convert an arcpy Field object to a Field argument dictionary</p> <code>get_field_type</code> <p>Convert a field type flag from a describe arcpy.Field to arguments for AddField</p> <p>Attributes:</p> Name Type Description <code>EditToken</code> <code>FeatureToken</code> <code>FeatureTokens</code> <code>tuple[FeatureToken, ...]</code> <code>FieldType</code> <code>GeneralToken</code> <code>GeometryType</code> <code>ShapeToken</code> <code>TableToken</code> <code>TableTokens</code> <code>tuple[TableToken, ...]</code>"},{"location":"modules/cursor/#arcpie.cursor.EditToken","title":"<code>EditToken = Literal['CREATED@', 'CREATOR@', 'EDITED@', 'EDITOR@']</code>  <code>module-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.FeatureToken","title":"<code>FeatureToken = Literal[TableToken | ShapeToken]</code>  <code>module-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.FeatureTokens","title":"<code>FeatureTokens = FeatureToken.__args__</code>  <code>module-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.FieldType","title":"<code>FieldType = Literal['SHORT', 'LONG', 'BIGINTEGER', 'FLOAT', 'DOUBLE', 'TEXT', 'DATE', 'DATEHIGHPRECISION', 'DATEONLY', 'TIMEONLY', 'TIMESTAMPOFFSET', 'BLOB', 'GUID', 'RASTER']</code>  <code>module-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.GeneralToken","title":"<code>GeneralToken = Literal['ANNO@', 'GLOBALID@', 'OID@', 'SUBTYPE@']</code>  <code>module-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.GeometryType","title":"<code>GeometryType = Geometry | Polygon | PointGeometry | Polyline | Multipoint | Multipatch</code>  <code>module-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.ShapeToken","title":"<code>ShapeToken = Literal['SHAPE@', 'SHAPE@XY', 'SHAPE@XYZ', 'SHAPE@TRUECENTROID', 'SHAPE@X', 'SHAPE@Y', 'SHAPE@Z', 'SHAPE@M', 'SHAPE@JSON', 'SHAPE@WKB', 'SHAPE@WKT', 'SHAPE@AREA', 'SHAPE@LENGTH']</code>  <code>module-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.TableToken","title":"<code>TableToken = Literal[GeneralToken | EditToken]</code>  <code>module-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.TableTokens","title":"<code>TableTokens = TableToken.__args__</code>  <code>module-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.Field","title":"<code>Field</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Field Representation</p> <p>Attributes:</p> Name Type Description <code>field_type</code> <code>FieldType</code> <p>The type of the field (required)</p> <code>field_precision</code> <code>int</code> <p>The precision (digits) of numeric fields (default: database determined)</p> <code>field_scale</code> <code>int</code> <p>The number of decimal places for floating point fields (default: database determined)</p> <code>field_length</code> <code>int</code> <p>The maximum character count for <code>TEXT</code> fields (default: 255)</p> <code>field_alias</code> <code>str</code> <p>Human readable alias for fields with confusing internal names (optional)</p> <code>field_is_nullable</code> <code>bool</code> <p>Allow null values (default: <code>True</code>)</p> <code>field_is_required</code> <code>bool</code> <p>Field requires a value to be set (default: False)</p> <code>field_domain</code> <code>str</code> <p>Existing Domain name to bind to field (optional)</p> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class Field(TypedDict, total=False):\n    \"\"\"Field Representation\n\n    Attributes:\n        field_type (FieldType): The type of the field (required)\n        field_precision (int): The precision (digits) of numeric fields (default: database determined)\n        field_scale (int): The number of decimal places for floating point fields (default: database determined)\n        field_length (int): The maximum character count for `TEXT` fields (default: 255)\n        field_alias (str): Human readable alias for fields with confusing internal names (optional)\n        field_is_nullable (bool): Allow null values (default: `True`)\n        field_is_required (bool): Field requires a value to be set (default: False)\n        field_domain (str): Existing Domain name to bind to field (optional)\n    \"\"\"\n    field_type: FieldType\n    field_precision: int\n    field_scale: int\n    field_length: int\n    field_alias: str\n    field_is_nullable: Literal['NULLABLE', 'NON_NULLABLE']\n    field_is_required: Literal['REQUIRED', 'NON_REQUIRED']\n    field_domain: str\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.Field.field_alias","title":"<code>field_alias</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.Field.field_domain","title":"<code>field_domain</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.Field.field_is_nullable","title":"<code>field_is_nullable</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.Field.field_is_required","title":"<code>field_is_required</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.Field.field_length","title":"<code>field_length</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.Field.field_precision","title":"<code>field_precision</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.Field.field_scale","title":"<code>field_scale</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.Field.field_type","title":"<code>field_type</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.InsertOptions","title":"<code>InsertOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Optional parameters for InsertCursors</p> <p>Attributes:</p> Name Type Description <code>datum_transformation</code> <code>str | None</code> <code>explicit</code> <code>bool</code> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class InsertOptions(TypedDict, total=False):\n    \"\"\"Optional parameters for InsertCursors\"\"\"\n    datum_transformation: str | None\n    explicit: bool\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.InsertOptions.datum_transformation","title":"<code>datum_transformation</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.InsertOptions.explicit","title":"<code>explicit</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SQLClause","title":"<code>SQLClause</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Wrapper for Cursor sql_clause attribute,</p> <p>Attributes:</p> Name Type Description <code>prefix</code> <code>str</code> <p>The SQL prefix to be prepended to the <code>FROM</code> part of the statment</p> <code>postfix</code> <code>str</code> <p>The SQL postfix that will be appended to the <code>WHERE</code> clause</p> Format <pre><code>SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}\n</code></pre> Usage <pre><code>&gt;&gt;&gt; five_longest = SQLClause(prefix='TOP 5', postfix='ORDER BY LENGTH DESC')\n&gt;&gt;&gt; fc_result = feature_class.get_tuples(('NAME', 'LENGTH'), sql_clause=five_longest))\n&gt;&gt;&gt; print(list(fc_result))\n[('foo', 1001), ('bar', 999), ('baz', 567), ('buzz', 345), ('bang', 233)]\n</code></pre> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class SQLClause(NamedTuple):\n    \"\"\"Wrapper for Cursor sql_clause attribute,\n\n    Attributes:\n        prefix (str): The SQL prefix to be prepended to the `FROM` part of the statment\n        postfix (str): The SQL postfix that will be appended to the `WHERE` clause\n\n    Format:\n        ```sql\n        SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}\n        ```\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; five_longest = SQLClause(prefix='TOP 5', postfix='ORDER BY LENGTH DESC')\n        &gt;&gt;&gt; fc_result = feature_class.get_tuples(('NAME', 'LENGTH'), sql_clause=five_longest))\n        &gt;&gt;&gt; print(list(fc_result))\n        [('foo', 1001), ('bar', 999), ('baz', 567), ('buzz', 345), ('bang', 233)]\n        ```\n    \"\"\"\n    prefix: str|None\n    postfix: str|None\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.SQLClause.postfix","title":"<code>postfix</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SQLClause.prefix","title":"<code>prefix</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SearchOptions","title":"<code>SearchOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Optional parameters for SearchCursors</p> <p>Attributes:</p> Name Type Description <code>where_clause</code> <code>str</code> <p>A SQL query that is inserted after the SQL <code>WHERE</code> (<code>SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}...</code>)</p> <code>spatial_reference</code> <code>str | int | SpatialReference</code> <p>Perform an on the fly projection of the yielded geometry to this reference</p> <code>explode_to_points</code> <code>bool</code> <p>Return a row per vertex in each feature (e.g. <code>[SHAPE, 'eric', 'idle'] -&gt; [Point, 'eric', 'idle'], [Point, 'eric', 'idle'], ...</code>)</p> <code>sql_clause</code> <code>SQLClause</code> <p>A tuple of SQL queries that is inserted after the SQL  <code>SELECT</code> and <code>WHERE</code> clauses (<code>SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}...</code>)</p> <code>datum_transformation</code> <code>str</code> <p>The transformation to use during projection if there is a datum difference between the feature projection and the  target SpatialReference (you can use <code>arcpy.ListTransformations</code> to find valid transformations)</p> <code>spatial_filter</code> <code>Geometry</code> <p>A shape that will be used to test each feature against using the specified <code>spatial_relationship</code> (<code>'INTERSECTS'</code>) by default.</p> <code>spatial_relationship</code> <code>SpatialRelationship</code> <p>The type of relationship with the <code>spatial_filter</code> to test for in each row. Only rows with shapes that match this relationship will be yielded.</p> <code>search_order</code> <code>SearchOrder</code> <p>Run the <code>where_clause {sql_clause}</code> (<code>'ATTRIBUTEFIRST'</code> default) or <code>spatial_filter</code> (<code>'SPATIALFIRST'</code>) first. This can be used to optimize a cursor. If you have a complex <code>where_clause</code>, consider switching to <code>'SPATIALFIRST'</code> to cut down on the number of records that the <code>where_clause</code> runs for. These two operations are done as seperate SQL operations and <code>JOINED</code> in the result</p> <p>Returns:</p> Type Description <code> dict </code> <p>A dictionary with the populated keys</p> Usage <pre><code>&gt;&gt;&gt; options = SearchOptions(where_clause='OBJECTID &gt; 10')\n&gt;&gt;&gt; not_first_ten = feature_class.get_tuples(['NAME', 'LENGTH'], **options)\n&gt;&gt;&gt; print(list(not_first_ten))\n[('cleese', 777), ('idle', 222), ('gilliam', 111), ...]\n</code></pre> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class SearchOptions(TypedDict, total=False):\n    \"\"\"Optional parameters for SearchCursors\n\n    Attributes:\n        where_clause (str): A SQL query that is inserted after the SQL `WHERE` (`SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}...`)\n        spatial_reference (str | int | SpatialReference): Perform an on the fly projection of the yielded geometry to this reference\n        explode_to_points (bool): Return a row per vertex in each feature (e.g. `[SHAPE, 'eric', 'idle'] -&gt; [Point, 'eric', 'idle'], [Point, 'eric', 'idle'], ...`)\n        sql_clause (SQLClause): A tuple of SQL queries that is inserted after the SQL \n            `SELECT` and `WHERE` clauses (`SELECT {prefix} {fields} FROM {table} WHERE {where_clause} {postfix}...`)\n        datum_transformation (str): The transformation to use during projection if there is a datum difference between the feature projection and the \n            target SpatialReference (you can use `arcpy.ListTransformations` to find valid transformations)\n        spatial_filter (Geometry): A shape that will be used to test each feature against using the specified `spatial_relationship` (`'INTERSECTS'`)\n            by default.\n        spatial_relationship (SpatialRelationship): The type of relationship with the `spatial_filter` to test for in each row. Only rows with shapes\n            that match this relationship will be yielded.\n        search_order (SearchOrder): Run the `where_clause {sql_clause}` (`'ATTRIBUTEFIRST'` default) or `spatial_filter` (`'SPATIALFIRST'`) first.\n            This can be used to optimize a cursor. If you have a complex `where_clause`, consider switching to `'SPATIALFIRST'` to cut down on the number\n            of records that the `where_clause` runs for. These two operations are done as seperate SQL operations and `JOINED` in the result\n\n    Returns:\n        ( dict ): A dictionary with the populated keys\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; options = SearchOptions(where_clause='OBJECTID &gt; 10')\n        &gt;&gt;&gt; not_first_ten = feature_class.get_tuples(['NAME', 'LENGTH'], **options)\n        &gt;&gt;&gt; print(list(not_first_ten))\n        [('cleese', 777), ('idle', 222), ('gilliam', 111), ...]\n        ```\n    \"\"\"\n    where_clause: str\n    spatial_reference: str | int | SpatialReference\n    explode_to_points: bool\n    sql_clause: SQLClause\n    datum_transformation: str\n    spatial_filter: GeometryType | Extent\n    spatial_relationship: SpatialRelationship\n    search_order: SearchOrder\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.SearchOptions.datum_transformation","title":"<code>datum_transformation</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SearchOptions.explode_to_points","title":"<code>explode_to_points</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SearchOptions.search_order","title":"<code>search_order</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SearchOptions.spatial_filter","title":"<code>spatial_filter</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SearchOptions.spatial_reference","title":"<code>spatial_reference</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SearchOptions.spatial_relationship","title":"<code>spatial_relationship</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SearchOptions.sql_clause","title":"<code>sql_clause</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.SearchOptions.where_clause","title":"<code>where_clause</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions","title":"<code>UpdateOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Optional parameters for UpdateCursors</p> <p>Attributes:</p> Name Type Description <code>datum_transformation</code> <code>str | None</code> <code>explicit</code> <code>bool</code> <code>explode_to_points</code> <code>bool</code> <code>search_order</code> <code>SearchOrder</code> <code>spatial_filter</code> <code>GeometryType | Extent</code> <code>spatial_reference</code> <code>str | int | SpatialReference</code> <code>spatial_relationship</code> <code>SpatialRelationship</code> <code>sql_clause</code> <code>SQLClause</code> <code>where_clause</code> <code>str</code> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class UpdateOptions(TypedDict, total=False):\n    \"\"\"Optional parameters for UpdateCursors\"\"\"\n    where_clause: str\n    spatial_reference: str | int | SpatialReference\n    explode_to_points: bool\n    sql_clause: SQLClause\n    #skip_nulls: bool\n    #null_value: dict[str, Any]\n    datum_transformation: str | None\n    explicit: bool\n    spatial_filter: GeometryType | Extent\n    spatial_relationship: SpatialRelationship\n    search_order: SearchOrder\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions.datum_transformation","title":"<code>datum_transformation</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions.explicit","title":"<code>explicit</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions.explode_to_points","title":"<code>explode_to_points</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions.search_order","title":"<code>search_order</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions.spatial_filter","title":"<code>spatial_filter</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions.spatial_reference","title":"<code>spatial_reference</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions.spatial_relationship","title":"<code>spatial_relationship</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions.sql_clause","title":"<code>sql_clause</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.UpdateOptions.where_clause","title":"<code>where_clause</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.WhereClause","title":"<code>WhereClause</code>","text":"<p>Wraps a string clause to signal to FeatureClass/Table indexes that a Where Clause is being passed</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Object for storing and validating where clauses</p> <code>__repr__</code> <code>get_fields</code> <p>Sanitize a where clause by removing whitespace</p> <code>validate</code> <p>Check to see if the clause fields are in the fields list</p> <p>Attributes:</p> Name Type Description <code>fields</code> <code>skip_validation</code> <code>where_clause</code> Source code in <code>src/arcpie/cursor.py</code> <pre><code>class WhereClause:\n    \"\"\"Wraps a string clause to signal to FeatureClass/Table indexes that a Where Clause is being passed\"\"\"\n\n    def __init__(self, where_clause: str, skip_validation: bool=False) -&gt; None:\n        \"\"\"Object for storing and validating where clauses\n\n        Args:\n            where_clause (str): The where clause that you want to pass to a FeatureClass\n            skip_validation (bool): Skip the validation step (default: False)\n        \"\"\"\n        if '@' in where_clause:\n            raise AttributeError(\n                '`@` Parameters/Tokens not supported in WhereClauses, Please use full fieldname'\n            )\n        self.where_clause = where_clause\n        self.fields = self.get_fields(where_clause)\n        self.skip_validation = skip_validation\n\n    def __repr__(self) -&gt; str:\n        return self.where_clause\n\n    def get_fields(self, clause: str) -&gt; Sequence[str]:\n        \"\"\"Sanitize a where clause by removing whitespace\"\"\"\n\n        #    -0-     1    2      3      -4-      5    6\n        # '&lt;FIELD&gt; &lt;OP&gt; &lt;VAL&gt; &lt;AND/OR&gt; &lt;FIELD&gt; &lt;OP&gt; &lt;VAL&gt; ...'\n        # A properly structured WhereClause should have a field\n        # as every 4th token split on spaces\n\n        # CAVEAT: Parens and whitespace\n        # This comprehension drops individual parens, replaces ', ' with ','\n        # and finds all field components\n\n        # TODO: This needs thorough testing\n        return [\n            fld.strip().replace('(', '').replace(')', '')\n            for fld in [\n                tok for tok in\n                clause.replace(', ', ',').split()\n                if tok not in '()'\n            ][::4]\n        ]\n\n    def validate(self, fields: Sequence[str]) -&gt; bool:\n        \"\"\"Check to see if the clause fields are in the fields list\n\n        Args:\n            fields (Sequence[str]): The fields to check against\n        \"\"\"\n        return self.skip_validation or set(self.fields) &lt;= set(fields)\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.WhereClause.fields","title":"<code>fields = self.get_fields(where_clause)</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.WhereClause.skip_validation","title":"<code>skip_validation = skip_validation</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.WhereClause.where_clause","title":"<code>where_clause = where_clause</code>  <code>instance-attribute</code>","text":""},{"location":"modules/cursor/#arcpie.cursor.WhereClause.__init__","title":"<code>__init__(where_clause, skip_validation=False)</code>","text":"<p>Object for storing and validating where clauses</p> <p>Parameters:</p> Name Type Description Default <code>where_clause</code> <code>str</code> <p>The where clause that you want to pass to a FeatureClass</p> required <code>skip_validation</code> <code>bool</code> <p>Skip the validation step (default: False)</p> <code>False</code> Source code in <code>src/arcpie/cursor.py</code> <pre><code>def __init__(self, where_clause: str, skip_validation: bool=False) -&gt; None:\n    \"\"\"Object for storing and validating where clauses\n\n    Args:\n        where_clause (str): The where clause that you want to pass to a FeatureClass\n        skip_validation (bool): Skip the validation step (default: False)\n    \"\"\"\n    if '@' in where_clause:\n        raise AttributeError(\n            '`@` Parameters/Tokens not supported in WhereClauses, Please use full fieldname'\n        )\n    self.where_clause = where_clause\n    self.fields = self.get_fields(where_clause)\n    self.skip_validation = skip_validation\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.WhereClause.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>src/arcpie/cursor.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return self.where_clause\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.WhereClause.get_fields","title":"<code>get_fields(clause)</code>","text":"<p>Sanitize a where clause by removing whitespace</p> Source code in <code>src/arcpie/cursor.py</code> <pre><code>def get_fields(self, clause: str) -&gt; Sequence[str]:\n    \"\"\"Sanitize a where clause by removing whitespace\"\"\"\n\n    #    -0-     1    2      3      -4-      5    6\n    # '&lt;FIELD&gt; &lt;OP&gt; &lt;VAL&gt; &lt;AND/OR&gt; &lt;FIELD&gt; &lt;OP&gt; &lt;VAL&gt; ...'\n    # A properly structured WhereClause should have a field\n    # as every 4th token split on spaces\n\n    # CAVEAT: Parens and whitespace\n    # This comprehension drops individual parens, replaces ', ' with ','\n    # and finds all field components\n\n    # TODO: This needs thorough testing\n    return [\n        fld.strip().replace('(', '').replace(')', '')\n        for fld in [\n            tok for tok in\n            clause.replace(', ', ',').split()\n            if tok not in '()'\n        ][::4]\n    ]\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.WhereClause.validate","title":"<code>validate(fields)</code>","text":"<p>Check to see if the clause fields are in the fields list</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>Sequence[str]</code> <p>The fields to check against</p> required Source code in <code>src/arcpie/cursor.py</code> <pre><code>def validate(self, fields: Sequence[str]) -&gt; bool:\n    \"\"\"Check to see if the clause fields are in the fields list\n\n    Args:\n        fields (Sequence[str]): The fields to check against\n    \"\"\"\n    return self.skip_validation or set(self.fields) &lt;= set(fields)\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.convert_field","title":"<code>convert_field(arc_field)</code>","text":"<p>Convert an arcpy Field object to a Field argument dictionary</p> <p>Parameters:</p> Name Type Description Default <code>arc_field</code> <code>Field</code> <p>The Field object returned by Describe().fields</p> required <p>Returns:</p> Type Description <code>Field</code> <p>A Field argument dictionary that can be used to construct a new field</p> Source code in <code>src/arcpie/cursor.py</code> <pre><code>def convert_field(arc_field: ArcField) -&gt; Field:\n    \"\"\"Convert an arcpy Field object to a Field argument dictionary\n\n    Args:\n        arc_field (arcpy.Field): The Field object returned by Describe().fields\n\n    Returns:\n        (Field): A Field argument dictionary that can be used to construct a new field\n    \"\"\"\n    return Field(\n        field_type=get_field_type(arc_field.type),\n        field_precision=arc_field.precision,\n        field_scale=arc_field.scale,\n        field_length=arc_field.length,\n        field_alias=arc_field.aliasName,\n        field_is_nullable='NULLABLE' if arc_field.isNullable else 'NON_NULLABLE',\n        field_is_required='REQUIRED' if arc_field.required else 'NON_REQUIRED',\n        field_domain=arc_field.domain,\n    )\n</code></pre>"},{"location":"modules/cursor/#arcpie.cursor.get_field_type","title":"<code>get_field_type(arc_field_type, *, strict=False)</code>","text":"<p>Convert a field type flag from a describe arcpy.Field to arguments for AddField</p> <p>Parameters:</p> Name Type Description Default <code>arc_field_type</code> <code>FieldType</code> <p>The field type as reported by arcpy.Describe(...).fields</p> required <code>strict</code> <code>bool</code> <p>Raise a ValueError if this is set to True, otherwise assume <code>TEXT</code></p> <code>False</code> <p>Returns:</p> Type Description <code>FieldType</code> <p>(FieldType)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>strict</code> flag is set and the input type is unmapped</p> Source code in <code>src/arcpie/cursor.py</code> <pre><code>def get_field_type(arc_field_type: ArcFieldType, *, strict: bool=False) -&gt; FieldType:\n    \"\"\"Convert a field type flag from a describe arcpy.Field to arguments for AddField\n\n    Args:\n        arc_field_type (ArcFieldType): The field type as reported by arcpy.Describe(...).fields\n        strict (bool): Raise a ValueError if this is set to True, otherwise assume `TEXT`\n\n    Returns:\n        (FieldType)\n\n    Raises:\n        (ValueError): If `strict` flag is set and the input type is unmapped\n    \"\"\"\n    match arc_field_type:\n        case 'BigInteger':\n            return 'BIGINTEGER'\n        case 'Blob':\n            return 'BLOB'\n        case 'Date':\n            return 'DATE'\n        case 'DateOnly':\n            return 'DATEONLY'\n        case 'Double':\n            return 'DOUBLE'\n        case 'Geometry': # No Passthrough\n            return 'BLOB'\n        case 'GlobalID': # No Passthrough\n            return 'GUID'\n        case 'GUID':\n            return 'GUID'\n        case 'Integer':\n            return 'LONG'\n        case 'OID':\n            return 'BIGINTEGER'\n        case 'Raster':\n            return 'RASTER'\n        case 'Single':\n            return 'FLOAT'\n        case 'SmallInteger':\n            return 'SHORT'\n        case 'String':\n            return 'TEXT'\n        case 'TimeOnly':\n            return 'TIMEONLY'\n        case 'TimestampOffset':\n            return 'TIMESTAMPOFFSET'\n        case _:\n            if strict:\n                raise ValueError()\n            return 'TEXT' \n</code></pre>"},{"location":"modules/database/","title":"database","text":"<p>Classes:</p> Name Description <code>Dataset</code> <p>A Container for managing workspace connections.</p> <code>DomainManager</code> <p>Handler for interacting with domains defined on a dataset</p> <code>Relationship</code> <code>RelationshipManager</code> <p>Functions:</p> Name Description <code>convert_cardinality</code>"},{"location":"modules/database/#arcpie.database.Dataset","title":"<code>Dataset</code>","text":"<p>               Bases: <code>Generic[_Schema]</code></p> <p>A Container for managing workspace connections.</p> <p>A Dataset is initialized using <code>arcpy.da.Walk</code> and will discover all child datasets, tables, and featureclasses. These discovered objects can be accessed by name directly (e.g. <code>dataset['featureclass_name']</code>) or by inspecting the property of the type they belong to (e.g. dataset.feature_classes['featureclass_name']). The benefit of the second  method is that you will be able to know you are getting a <code>FeatureClass</code>, <code>Table</code>, or <code>Dataset</code> object.</p> Usage <pre><code>&gt;&gt;&gt; dataset = Dataset('dataset/path')\n&gt;&gt;&gt; fc1 = dataset.feature_classes['fc1']\n&gt;&gt;&gt; fc1 = dataset.feature_classes['fc2']\n&gt;&gt;&gt; len(fc1)\n243\n&gt;&gt;&gt; len(fc2)\n778\n\n&gt;&gt;&gt; count(dataset['fc1'][where('LENGTH &gt; 500')])\n42\n&gt;&gt;&gt; sum(dataset['fc2']['TOTAL'])\n3204903\n</code></pre> <p>As you can see, the dataset container makes it incredibly easy to interact with data concisely and clearly. </p> <p>Datasets also implement <code>__contains__</code> which allows you to check membership from the root node:</p> Example <pre><code>&gt;&gt;&gt; 'fc1' in dataset\nTrue\n&gt;&gt;&gt; 'fc6' in dataset\nTrue\n&gt;&gt;&gt; list(dataset.feature_classes)\n['fc1', 'fc2']\n&gt;&gt;&gt; list(dataset.datasets)\n['ds1']\n&gt;&gt;&gt; list(dataset['ds1'].feature_classes)\n['fc3', 'fc4', 'fc5', 'fc6']\n</code></pre> <p>Methods:</p> Name Description <code>__contains__</code> <code>__fspath__</code> <code>__getitem__</code> <code>__init__</code> <code>__iter__</code> <code>__len__</code> <code>__repr__</code> <code>__str__</code> <code>export_rules</code> <p>Export all attribute rules from the dataset into feature subdirectories</p> <code>export_schema</code> <p>Export the workspace Schema for a GDB dataset</p> <code>from_schema</code> <p>Create a GDB from a schema file (xlsx, json, xml) generated by export_schema</p> <code>get</code> <code>import_rules</code> <p>Import Attribute rules for the dataset from a directory</p> <code>walk</code> <p>Traverse the connection/path using <code>arcpy.da.Walk</code> and discover all dataset children</p> <p>Attributes:</p> Name Type Description <code>conn</code> <code>datasets</code> <code>dict[str, Dataset[Any]]</code> <p>A mapping of dataset names to child <code>Dataset</code> objects</p> <code>domains</code> <code>DomainManager</code> <code>feature_classes</code> <code>dict[str, FeatureClass]</code> <p>A mapping of featureclass names to <code>FeatureClass</code> objects in the dataset root</p> <code>name</code> <code>str</code> <code>parent</code> <code>relationships</code> <code>RelationshipManager</code> <p>A Manager object for interacting with RelationshipClasses</p> <code>schema</code> <code>SchemaWorkspace</code> <code>tables</code> <code>dict[str, Table[Any]]</code> <p>A mapping of table names to <code>Table</code> objects in the dataset root</p> Source code in <code>src/arcpie/database.py</code> <pre><code>class Dataset(Generic[_Schema]):\n    \"\"\"A Container for managing workspace connections.\n\n    A Dataset is initialized using `arcpy.da.Walk` and will discover all child datasets, tables, and featureclasses.\n    These discovered objects can be accessed by name directly (e.g. `dataset['featureclass_name']`) or by inspecting the\n    property of the type they belong to (e.g. dataset.feature_classes['featureclass_name']). The benefit of the second \n    method is that you will be able to know you are getting a `FeatureClass`, `Table`, or `Dataset` object.\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; dataset = Dataset('dataset/path')\n        &gt;&gt;&gt; fc1 = dataset.feature_classes['fc1']\n        &gt;&gt;&gt; fc1 = dataset.feature_classes['fc2']\n        &gt;&gt;&gt; len(fc1)\n        243\n        &gt;&gt;&gt; len(fc2)\n        778\n\n        &gt;&gt;&gt; count(dataset['fc1'][where('LENGTH &gt; 500')])\n        42\n        &gt;&gt;&gt; sum(dataset['fc2']['TOTAL'])\n        3204903\n        ```\n    As you can see, the dataset container makes it incredibly easy to interact with data concisely and clearly. \n\n    Datasets also implement `__contains__` which allows you to check membership from the root node:\n\n    Example:\n        ```python\n        &gt;&gt;&gt; 'fc1' in dataset\n        True\n        &gt;&gt;&gt; 'fc6' in dataset\n        True\n        &gt;&gt;&gt; list(dataset.feature_classes)\n        ['fc1', 'fc2']\n        &gt;&gt;&gt; list(dataset.datasets)\n        ['ds1']\n        &gt;&gt;&gt; list(dataset['ds1'].feature_classes)\n        ['fc3', 'fc4', 'fc5', 'fc6']\n        ```\n    \"\"\"\n    def __init__(self, conn: str|Path, *, parent: Dataset[Any]|None=None) -&gt; None:\n        self.conn = Path(conn)\n\n        # Force root dataset to be a gdb, pointing to a folder can cause issues with Walk\n        if not parent and self.conn.suffix != '.gdb':\n            raise ValueError('Root Dataset requires a valid gdb path!')\n        self.parent = parent\n        self._datasets: dict[str, Dataset[Any]] | None = None\n        self._feature_classes: dict[str, FeatureClass] | None=None\n        self._tables: dict[str, Table[Any]] | None=None\n        self._relationships: dict[str, Relationship]\n        self.walk()\n\n    @property\n    def name(self) -&gt; str:\n        return self.conn.stem\n\n    @property\n    def datasets(self) -&gt; dict[str, Dataset[Any]]:\n        \"\"\"A mapping of dataset names to child `Dataset` objects\"\"\"\n        return self._datasets or {}\n\n    @property\n    def feature_classes(self) -&gt; dict[str, FeatureClass]:\n        \"\"\"A mapping of featureclass names to `FeatureClass` objects in the dataset root\"\"\"\n        return self._feature_classes or {}\n\n    @property\n    def tables(self) -&gt; dict[str, Table[Any]]:\n        \"\"\"A mapping of table names to `Table` objects in the dataset root\"\"\"\n        return self._tables or {}\n\n    @property\n    def relationships(self) -&gt; RelationshipManager:\n        \"\"\"A Manager object for interacting with RelationshipClasses\"\"\"\n        return RelationshipManager(self)\n\n    @property\n    def domains(self) -&gt; DomainManager:\n        return DomainManager(self)\n\n    @property\n    def schema(self) -&gt; SchemaWorkspace:\n        return json.load(convert_schema(self, 'JSON'))\n\n    def export_rules(self, rule_dir: Path|str) -&gt; None:\n        \"\"\"Export all attribute rules from the dataset into feature subdirectories\n\n        Args:\n            rule_dir (Path|str): The target directory for the rules\n\n        Usage:\n            ```python\n            &gt;&gt;&gt; # Transfer rules from one dataset to another\n            &gt;&gt;&gt; ds.export_rules('my_rules')\n            &gt;&gt;&gt; ds2.import_rules('my_rules')\n            ```\n        \"\"\"\n        for feature_class in self.feature_classes.values():\n            feature_class.attribute_rules.export_rules(Path(rule_dir))\n\n    def import_rules(self, rule_dir: Path|str, \n                     *, \n                     skip_fail: bool=False) -&gt; None:\n        \"\"\"Import Attribute rules for the dataset from a directory\n\n        Args:\n            rule_dir (Path|str): A directory containing rules in feature sub directories\n            skip_fail (bool): Skip any attribute rule imports that fail (whole FC) (default: False)\n\n        Usage:\n            ```python\n            &gt;&gt;&gt; # Transfer rules from one dataset to another\n            &gt;&gt;&gt; ds.export_rules('my_rules')\n            &gt;&gt;&gt; ds2.import_rules('my_rules')\n            ```\n        \"\"\"\n        rule_dir = Path(rule_dir)\n        for feature_class in self.feature_classes.values():\n                if not (rule_dir / feature_class.name).exists():\n                    continue\n                try:\n                    feature_class.attribute_rules.import_rules(rule_dir / feature_class.name)\n                except Exception as e:\n                    if skip_fail:\n                        print(f'Failed to import rules for {feature_class.name}: \\n\\t{e.__notes__}\\n\\t{e}')\n                    else:\n                        raise e\n\n    def walk(self) -&gt; None:\n        \"\"\"Traverse the connection/path using `arcpy.da.Walk` and discover all dataset children\n\n        Note:\n            This is called on dataset initialization and can take some time. Larger datasets can take up to\n            a second or more to initialize.\n\n        Note:\n            If the contents of a dataset change during its lifetime, you may need to call walk again. All \n            children that are already initialized will be skipped and only new children will be initialized\n        \"\"\"\n        self._feature_classes = {}\n        for root, _, fcs in Walk(str(self.conn), datatype=['FeatureClass']):\n            root = Path(root)\n            for fc in fcs:\n                # Backlink Datasets to parent\n                if self.parent is not None and fc in self.parent:\n                    self._feature_classes[fc] = self.parent.feature_classes[fc]\n                else:\n                    self._feature_classes[fc] = FeatureClass(root / fc)\n\n        self._tables = {}\n        for root, _, tbls in Walk(str(self.conn), datatype=['Table']):\n            root = Path(root)\n            for tbl in tbls:\n                # Backlink Datasets to parent (Should never hit since tables are in root only)\n                if self.parent and tbl in self.parent:\n                    self._tables[tbl] = self.parent.tables[tbl]\n                else:\n                    self._tables[tbl] = Table(root / tbl)\n\n        self._relationships = {}\n        for root, _, rels in Walk(str(self.conn), datatype=['RelationshipClass']):\n            root = Path(root)\n            for rel in rels:\n                # Backlink Datasets to parent\n                if self.parent and rel in self.parent:\n                    self._relationships[rel] = self.parent.relationships[rel]\n                else:\n                    self._relationships[rel] = Relationship(self, root / rel)\n\n        # Handle datasets last to allow for backlinking     \n        self._datasets = {}\n        for root, ds, _ in Walk(str(self.conn), datatype=['FeatureDataset']):\n            root = Path(root)\n            self._datasets.update({d: Dataset(root / d, parent=self) for d in ds})\n\n    def __getitem__(self, key: str) -&gt; FeatureClass | Table[Any] | Dataset[Any] | Relationship:\n        if ret := self.tables.get(key) or self.feature_classes.get(key) or self.datasets.get(key) or self.relationships.get(key):\n            return ret\n        raise KeyError(f'{key} is not a child of {self.conn.stem}')\n\n    def get(self, key: str, default: _Default=None) -&gt; FeatureClass | Table[Any] | Dataset[Any] | Relationship | _Default:\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __contains__(self, key: str) -&gt; bool:\n        try:\n            self[key]\n            return True\n        except KeyError:\n            return False\n\n    def __iter__(self) -&gt; Iterator[FeatureClass | Table[Any] | Dataset[Any] | Relationship]:\n        for feature_class in self.feature_classes.values():\n            yield feature_class\n\n        for table in self.tables.values():\n            yield table\n\n        for dataset in self.datasets.values():\n            yield from dataset\n\n        for relationship in self.relationships:\n            yield relationship\n\n    def __len__(self) -&gt; int:\n        return sum(1 for _ in self)\n\n    def __repr__(self) -&gt; str:\n        return (\n            \"Dataset(\"\n            f\"{self.name}, \"\n            \"{\"\n            f\"Features: {len(self.feature_classes)}, \"\n            f\"Tables: {len(self.tables)}, \"\n            f\"Datasets: {len(self.datasets)}, \"\n            f\"Relationships: {len(self.relationships)}\"\n            \"})\"\n        )\n\n    def __str__(self) -&gt; str:\n        return self.__fspath__()\n\n    def __fspath__(self) -&gt; str:\n        return str(self.conn.resolve())\n\n    def export_schema(self, out_loc: Path|str,\n                      *,\n                      schema_name: str|None=None, \n                      out_format: Literal['JSON', 'XLSX', 'HTML', 'PDF', 'XML']='JSON',\n                      remove_rules: bool=False) -&gt; Path:\n        \"\"\"Export the workspace Schema for a GDB dataset\n\n        Args:\n            out_loc (Path|str): The output location for the workspace schema\n            schema_name (str): A name for the schema (default: Dataset.name)\n            out_format (Literal['json', 'xml', 'xlsx', 'html']): The output format (default: 'json')\n            remove_rules (bool): Don't export associated attribute rules for the dataset (default: False)\n\n        Returns:\n            Path : The Path object pointing to the output file\n        \"\"\"\n        out_loc = Path(out_loc)\n        out_loc.mkdir(exist_ok=True, parents=True)\n        name = schema_name or self.name\n        outfile = (out_loc / name).with_suffix(f'.{out_format.lower()}')\n        workspace = json.load(convert_schema(self, out_format))\n        schema = patch_schema_rules(workspace, remove_rules=remove_rules)\n        with outfile.open('w') as f:\n            json.dump(schema, f, indent=2)\n        return outfile\n\n    @classmethod\n    def from_schema(cls, schema: Path|str, out_loc: Path|str, gdb_name: str, \n                    *,\n                    remove_rules: bool=False) -&gt; Dataset[Any]:\n        \"\"\"Create a GDB from a schema file (xlsx, json, xml) generated by export_schema\n\n        Args:\n            schema (Path|str): Path to the schema file\n            out_loc (Path|str): Path to the GDB output directory\n            gdb_name (str): The name of the gdb\n            remove_rules (bool): Don't import Attribute Rules after building the new dataset (default: False)\n\n        Usage:\n            ```python\n            &gt;&gt;&gt; ds = Dataset.from_schema('schema.xlsx', 'out_dir', 'new_db.gdb', skip_rules=True)\n            ... # This can take a while depending on the size of the schema\n            &gt;&gt;&gt; ds\n            Dataset('new_db' {'Features': 10, 'Tables': 3, Datasets: 0})\n            ```\n        \"\"\"\n        schema = Path(schema)\n        out_loc = Path(out_loc)\n        new_database = (out_loc / gdb_name).with_suffix('.gdb')\n\n        # Convert the schema to json for easy parsing of attribute rules\n        with TemporaryDirectory(f'{gdb_name}_json_schema') as temp:\n            temp = Path(temp)\n            # Convert the schema to json\n            if not schema.suffix == '.json':\n                converted_report, = ConvertSchemaReport(\n                    str(schema), str(temp), 'json_schema', 'JSON'\n                )\n            else:\n                converted_report = str(schema)\n            # Patch the schema doc\n            workspace = patch_schema_rules(\n                converted_report, remove_rules=remove_rules\n            )\n            # Write out to tempfile\n            patched_schema = temp / 'patched_schema.json'\n            patched_schema.write_text(json.dumps(workspace), encoding='utf-8')\n            # Convert to importable XML\n            xml_schema, = ConvertSchemaReport(\n                str(patched_schema), str(temp), 'xml_schema', 'XML'\n            )\n            # Create a new GDB\n            CreateFileGDB(str(out_loc), gdb_name, 'CURRENT')\n            # Import the schema doc\n            ImportXMLWorkspaceDocument(\n                str(new_database), xml_schema, 'SCHEMA_ONLY'\n            )\n        return Dataset(new_database)\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.conn","title":"<code>conn = Path(conn)</code>  <code>instance-attribute</code>","text":""},{"location":"modules/database/#arcpie.database.Dataset.datasets","title":"<code>datasets</code>  <code>property</code>","text":"<p>A mapping of dataset names to child <code>Dataset</code> objects</p>"},{"location":"modules/database/#arcpie.database.Dataset.domains","title":"<code>domains</code>  <code>property</code>","text":""},{"location":"modules/database/#arcpie.database.Dataset.feature_classes","title":"<code>feature_classes</code>  <code>property</code>","text":"<p>A mapping of featureclass names to <code>FeatureClass</code> objects in the dataset root</p>"},{"location":"modules/database/#arcpie.database.Dataset.name","title":"<code>name</code>  <code>property</code>","text":""},{"location":"modules/database/#arcpie.database.Dataset.parent","title":"<code>parent = parent</code>  <code>instance-attribute</code>","text":""},{"location":"modules/database/#arcpie.database.Dataset.relationships","title":"<code>relationships</code>  <code>property</code>","text":"<p>A Manager object for interacting with RelationshipClasses</p>"},{"location":"modules/database/#arcpie.database.Dataset.schema","title":"<code>schema</code>  <code>property</code>","text":""},{"location":"modules/database/#arcpie.database.Dataset.tables","title":"<code>tables</code>  <code>property</code>","text":"<p>A mapping of table names to <code>Table</code> objects in the dataset root</p>"},{"location":"modules/database/#arcpie.database.Dataset.__contains__","title":"<code>__contains__(key)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __contains__(self, key: str) -&gt; bool:\n    try:\n        self[key]\n        return True\n    except KeyError:\n        return False\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.__fspath__","title":"<code>__fspath__()</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __fspath__(self) -&gt; str:\n    return str(self.conn.resolve())\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __getitem__(self, key: str) -&gt; FeatureClass | Table[Any] | Dataset[Any] | Relationship:\n    if ret := self.tables.get(key) or self.feature_classes.get(key) or self.datasets.get(key) or self.relationships.get(key):\n        return ret\n    raise KeyError(f'{key} is not a child of {self.conn.stem}')\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.__init__","title":"<code>__init__(conn, *, parent=None)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __init__(self, conn: str|Path, *, parent: Dataset[Any]|None=None) -&gt; None:\n    self.conn = Path(conn)\n\n    # Force root dataset to be a gdb, pointing to a folder can cause issues with Walk\n    if not parent and self.conn.suffix != '.gdb':\n        raise ValueError('Root Dataset requires a valid gdb path!')\n    self.parent = parent\n    self._datasets: dict[str, Dataset[Any]] | None = None\n    self._feature_classes: dict[str, FeatureClass] | None=None\n    self._tables: dict[str, Table[Any]] | None=None\n    self._relationships: dict[str, Relationship]\n    self.walk()\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __iter__(self) -&gt; Iterator[FeatureClass | Table[Any] | Dataset[Any] | Relationship]:\n    for feature_class in self.feature_classes.values():\n        yield feature_class\n\n    for table in self.tables.values():\n        yield table\n\n    for dataset in self.datasets.values():\n        yield from dataset\n\n    for relationship in self.relationships:\n        yield relationship\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.__len__","title":"<code>__len__()</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __len__(self) -&gt; int:\n    return sum(1 for _ in self)\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return (\n        \"Dataset(\"\n        f\"{self.name}, \"\n        \"{\"\n        f\"Features: {len(self.feature_classes)}, \"\n        f\"Tables: {len(self.tables)}, \"\n        f\"Datasets: {len(self.datasets)}, \"\n        f\"Relationships: {len(self.relationships)}\"\n        \"})\"\n    )\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.__str__","title":"<code>__str__()</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __str__(self) -&gt; str:\n    return self.__fspath__()\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.export_rules","title":"<code>export_rules(rule_dir)</code>","text":"<p>Export all attribute rules from the dataset into feature subdirectories</p> <p>Parameters:</p> Name Type Description Default <code>rule_dir</code> <code>Path | str</code> <p>The target directory for the rules</p> required Usage <pre><code>&gt;&gt;&gt; # Transfer rules from one dataset to another\n&gt;&gt;&gt; ds.export_rules('my_rules')\n&gt;&gt;&gt; ds2.import_rules('my_rules')\n</code></pre> Source code in <code>src/arcpie/database.py</code> <pre><code>def export_rules(self, rule_dir: Path|str) -&gt; None:\n    \"\"\"Export all attribute rules from the dataset into feature subdirectories\n\n    Args:\n        rule_dir (Path|str): The target directory for the rules\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; # Transfer rules from one dataset to another\n        &gt;&gt;&gt; ds.export_rules('my_rules')\n        &gt;&gt;&gt; ds2.import_rules('my_rules')\n        ```\n    \"\"\"\n    for feature_class in self.feature_classes.values():\n        feature_class.attribute_rules.export_rules(Path(rule_dir))\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.export_schema","title":"<code>export_schema(out_loc, *, schema_name=None, out_format='JSON', remove_rules=False)</code>","text":"<p>Export the workspace Schema for a GDB dataset</p> <p>Parameters:</p> Name Type Description Default <code>out_loc</code> <code>Path | str</code> <p>The output location for the workspace schema</p> required <code>schema_name</code> <code>str</code> <p>A name for the schema (default: Dataset.name)</p> <code>None</code> <code>out_format</code> <code>Literal['json', 'xml', 'xlsx', 'html']</code> <p>The output format (default: 'json')</p> <code>'JSON'</code> <code>remove_rules</code> <code>bool</code> <p>Don't export associated attribute rules for the dataset (default: False)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The Path object pointing to the output file</p> Source code in <code>src/arcpie/database.py</code> <pre><code>def export_schema(self, out_loc: Path|str,\n                  *,\n                  schema_name: str|None=None, \n                  out_format: Literal['JSON', 'XLSX', 'HTML', 'PDF', 'XML']='JSON',\n                  remove_rules: bool=False) -&gt; Path:\n    \"\"\"Export the workspace Schema for a GDB dataset\n\n    Args:\n        out_loc (Path|str): The output location for the workspace schema\n        schema_name (str): A name for the schema (default: Dataset.name)\n        out_format (Literal['json', 'xml', 'xlsx', 'html']): The output format (default: 'json')\n        remove_rules (bool): Don't export associated attribute rules for the dataset (default: False)\n\n    Returns:\n        Path : The Path object pointing to the output file\n    \"\"\"\n    out_loc = Path(out_loc)\n    out_loc.mkdir(exist_ok=True, parents=True)\n    name = schema_name or self.name\n    outfile = (out_loc / name).with_suffix(f'.{out_format.lower()}')\n    workspace = json.load(convert_schema(self, out_format))\n    schema = patch_schema_rules(workspace, remove_rules=remove_rules)\n    with outfile.open('w') as f:\n        json.dump(schema, f, indent=2)\n    return outfile\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.from_schema","title":"<code>from_schema(schema, out_loc, gdb_name, *, remove_rules=False)</code>  <code>classmethod</code>","text":"<p>Create a GDB from a schema file (xlsx, json, xml) generated by export_schema</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Path | str</code> <p>Path to the schema file</p> required <code>out_loc</code> <code>Path | str</code> <p>Path to the GDB output directory</p> required <code>gdb_name</code> <code>str</code> <p>The name of the gdb</p> required <code>remove_rules</code> <code>bool</code> <p>Don't import Attribute Rules after building the new dataset (default: False)</p> <code>False</code> Usage <pre><code>&gt;&gt;&gt; ds = Dataset.from_schema('schema.xlsx', 'out_dir', 'new_db.gdb', skip_rules=True)\n... # This can take a while depending on the size of the schema\n&gt;&gt;&gt; ds\nDataset('new_db' {'Features': 10, 'Tables': 3, Datasets: 0})\n</code></pre> Source code in <code>src/arcpie/database.py</code> <pre><code>@classmethod\ndef from_schema(cls, schema: Path|str, out_loc: Path|str, gdb_name: str, \n                *,\n                remove_rules: bool=False) -&gt; Dataset[Any]:\n    \"\"\"Create a GDB from a schema file (xlsx, json, xml) generated by export_schema\n\n    Args:\n        schema (Path|str): Path to the schema file\n        out_loc (Path|str): Path to the GDB output directory\n        gdb_name (str): The name of the gdb\n        remove_rules (bool): Don't import Attribute Rules after building the new dataset (default: False)\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; ds = Dataset.from_schema('schema.xlsx', 'out_dir', 'new_db.gdb', skip_rules=True)\n        ... # This can take a while depending on the size of the schema\n        &gt;&gt;&gt; ds\n        Dataset('new_db' {'Features': 10, 'Tables': 3, Datasets: 0})\n        ```\n    \"\"\"\n    schema = Path(schema)\n    out_loc = Path(out_loc)\n    new_database = (out_loc / gdb_name).with_suffix('.gdb')\n\n    # Convert the schema to json for easy parsing of attribute rules\n    with TemporaryDirectory(f'{gdb_name}_json_schema') as temp:\n        temp = Path(temp)\n        # Convert the schema to json\n        if not schema.suffix == '.json':\n            converted_report, = ConvertSchemaReport(\n                str(schema), str(temp), 'json_schema', 'JSON'\n            )\n        else:\n            converted_report = str(schema)\n        # Patch the schema doc\n        workspace = patch_schema_rules(\n            converted_report, remove_rules=remove_rules\n        )\n        # Write out to tempfile\n        patched_schema = temp / 'patched_schema.json'\n        patched_schema.write_text(json.dumps(workspace), encoding='utf-8')\n        # Convert to importable XML\n        xml_schema, = ConvertSchemaReport(\n            str(patched_schema), str(temp), 'xml_schema', 'XML'\n        )\n        # Create a new GDB\n        CreateFileGDB(str(out_loc), gdb_name, 'CURRENT')\n        # Import the schema doc\n        ImportXMLWorkspaceDocument(\n            str(new_database), xml_schema, 'SCHEMA_ONLY'\n        )\n    return Dataset(new_database)\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.get","title":"<code>get(key, default=None)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def get(self, key: str, default: _Default=None) -&gt; FeatureClass | Table[Any] | Dataset[Any] | Relationship | _Default:\n    try:\n        return self[key]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.import_rules","title":"<code>import_rules(rule_dir, *, skip_fail=False)</code>","text":"<p>Import Attribute rules for the dataset from a directory</p> <p>Parameters:</p> Name Type Description Default <code>rule_dir</code> <code>Path | str</code> <p>A directory containing rules in feature sub directories</p> required <code>skip_fail</code> <code>bool</code> <p>Skip any attribute rule imports that fail (whole FC) (default: False)</p> <code>False</code> Usage <pre><code>&gt;&gt;&gt; # Transfer rules from one dataset to another\n&gt;&gt;&gt; ds.export_rules('my_rules')\n&gt;&gt;&gt; ds2.import_rules('my_rules')\n</code></pre> Source code in <code>src/arcpie/database.py</code> <pre><code>def import_rules(self, rule_dir: Path|str, \n                 *, \n                 skip_fail: bool=False) -&gt; None:\n    \"\"\"Import Attribute rules for the dataset from a directory\n\n    Args:\n        rule_dir (Path|str): A directory containing rules in feature sub directories\n        skip_fail (bool): Skip any attribute rule imports that fail (whole FC) (default: False)\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; # Transfer rules from one dataset to another\n        &gt;&gt;&gt; ds.export_rules('my_rules')\n        &gt;&gt;&gt; ds2.import_rules('my_rules')\n        ```\n    \"\"\"\n    rule_dir = Path(rule_dir)\n    for feature_class in self.feature_classes.values():\n            if not (rule_dir / feature_class.name).exists():\n                continue\n            try:\n                feature_class.attribute_rules.import_rules(rule_dir / feature_class.name)\n            except Exception as e:\n                if skip_fail:\n                    print(f'Failed to import rules for {feature_class.name}: \\n\\t{e.__notes__}\\n\\t{e}')\n                else:\n                    raise e\n</code></pre>"},{"location":"modules/database/#arcpie.database.Dataset.walk","title":"<code>walk()</code>","text":"<p>Traverse the connection/path using <code>arcpy.da.Walk</code> and discover all dataset children</p> Note <p>This is called on dataset initialization and can take some time. Larger datasets can take up to a second or more to initialize.</p> Note <p>If the contents of a dataset change during its lifetime, you may need to call walk again. All  children that are already initialized will be skipped and only new children will be initialized</p> Source code in <code>src/arcpie/database.py</code> <pre><code>def walk(self) -&gt; None:\n    \"\"\"Traverse the connection/path using `arcpy.da.Walk` and discover all dataset children\n\n    Note:\n        This is called on dataset initialization and can take some time. Larger datasets can take up to\n        a second or more to initialize.\n\n    Note:\n        If the contents of a dataset change during its lifetime, you may need to call walk again. All \n        children that are already initialized will be skipped and only new children will be initialized\n    \"\"\"\n    self._feature_classes = {}\n    for root, _, fcs in Walk(str(self.conn), datatype=['FeatureClass']):\n        root = Path(root)\n        for fc in fcs:\n            # Backlink Datasets to parent\n            if self.parent is not None and fc in self.parent:\n                self._feature_classes[fc] = self.parent.feature_classes[fc]\n            else:\n                self._feature_classes[fc] = FeatureClass(root / fc)\n\n    self._tables = {}\n    for root, _, tbls in Walk(str(self.conn), datatype=['Table']):\n        root = Path(root)\n        for tbl in tbls:\n            # Backlink Datasets to parent (Should never hit since tables are in root only)\n            if self.parent and tbl in self.parent:\n                self._tables[tbl] = self.parent.tables[tbl]\n            else:\n                self._tables[tbl] = Table(root / tbl)\n\n    self._relationships = {}\n    for root, _, rels in Walk(str(self.conn), datatype=['RelationshipClass']):\n        root = Path(root)\n        for rel in rels:\n            # Backlink Datasets to parent\n            if self.parent and rel in self.parent:\n                self._relationships[rel] = self.parent.relationships[rel]\n            else:\n                self._relationships[rel] = Relationship(self, root / rel)\n\n    # Handle datasets last to allow for backlinking     \n    self._datasets = {}\n    for root, ds, _ in Walk(str(self.conn), datatype=['FeatureDataset']):\n        root = Path(root)\n        self._datasets.update({d: Dataset(root / d, parent=self) for d in ds})\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager","title":"<code>DomainManager</code>","text":"<p>Handler for interacting with domains defined on a dataset</p> <p>Methods:</p> Name Description <code>__contains__</code> <code>__getitem__</code> <code>__init__</code> <code>__iter__</code> <p>Iterate all domains</p> <code>__len__</code> <code>add_domain</code> <p>Add a domain to the parent dataset or the root dataset (gdb)</p> <code>alter_domain</code> <p>Alter a domain using the given domain values</p> <code>delete_domain</code> <p>Delete a domain from the workspace</p> <code>get</code> <code>usage</code> <p>A mapping of domains to features to fields that shows usage of a domain in a dataset</p> <p>Attributes:</p> Name Type Description <code>dataset</code> <code>Dataset[Any]</code> <p>Get the parent Dataset object</p> <code>domain_map</code> <code>dict[str, Domain]</code> <p>A mapping of domain names to domain objects</p> <code>unused_domains</code> <code>dict[str, Domain]</code> <code>workspace</code> <code>Path</code> <p>Get a path to the root workspace that the domains live in</p> Source code in <code>src/arcpie/database.py</code> <pre><code>class DomainManager:\n    \"\"\"Handler for interacting with domains defined on a dataset\"\"\"\n\n    def __init__(self, dataset: Dataset[Any]) -&gt; None:\n        self._dataset = dataset\n\n    @property\n    def dataset(self) -&gt; Dataset[Any]:\n        \"\"\"Get the parent Dataset object\"\"\"\n        return self._dataset\n\n    @property\n    def workspace(self) -&gt; Path:\n        \"\"\"Get a path to the root workspace that the domains live in\"\"\"\n        if self.dataset.parent is None:\n            return self.dataset.conn\n        else:\n            return self.dataset.parent.conn\n\n    @property\n    def domain_map(self) -&gt; dict[str, Domain]:\n        \"\"\"A mapping of domain names to domain objects\"\"\"\n        if self.dataset.parent:\n            return self.dataset.parent.domains.domain_map\n        return {d.name: d for d in ListDomains(str(self.dataset.conn))}\n\n    @property\n    def unused_domains(self) -&gt; dict[str, Domain]:\n        usage = self.usage()\n        return {\n            name: domain\n            for name, domain in self.domain_map.items() \n            if name not in usage\n            or not usage[name]\n        }\n\n    def __len__(self) -&gt; int:\n        return len(self.domain_map)\n\n    def __iter__(self) -&gt; Iterator[Domain]:\n        \"\"\"Iterate all domains\"\"\"\n        yield from self.domain_map.values()\n\n    def __getitem__(self, name: str) -&gt; Domain:\n        return self.domain_map[name]\n\n    def get(self, name: str, default: _Default) -&gt; Domain | _Default:\n        try:\n            return self[name]\n        except KeyError:\n            return default\n\n    def __contains__(self, domain: str) -&gt; bool:\n        return domain in self.domain_map\n\n    def usage(self, *domain_names: str) -&gt; dict[str, dict[str, list[str]]]:\n        \"\"\"A mapping of domains to features to fields that shows usage of a domain in a dataset\n\n        Args:\n            *domain_names (str): Varargs of all domain names to include in the output mapping\n\n        Returns:\n            ( dict[str, dict[str, list[str]]] ) : A Nested mapping of `Domain Name -&gt; Feature Class -&gt; [Field Name, ...]`\n        \"\"\"\n\n        if not domain_names:\n            domain_names = tuple(self.domain_map)\n        schema = self.dataset.schema\n        fc_usage: dict[str, dict[str, list[str]]] = {}\n        for ds in schema['datasets']:\n            if 'datasets' in ds:\n                ds = ds['datasets']\n            else:\n                ds = [ds]\n            for fc in filter(lambda f: 'fields' in f, ds):\n                for field in filter(lambda fld: 'domain' in fld, fc['fields']['fieldArray']):\n                    assert 'domain' in field\n                    if (dn := field['domain']['domainName']) in domain_names:\n                        fc_usage.setdefault(dn, {}).setdefault(fc['name'], [])\n                        fc_usage[dn][fc['name']].append(field.get('name', '??'))\n        return fc_usage\n\n    def add_domain(self, domain: Domain|None=None, **opts: Unpack[CreateDomainOpts]) -&gt; None:\n        \"\"\"Add a domain to the parent dataset or the root dataset (gdb)\n\n        Args:\n            domain (Domain): The domain object to add to the managed Dataset (optional)\n            **opts (CreateDomainOpts): Additional overrides that will be applied to the create domain call\n        \"\"\"\n\n        if domain:\n            args: CreateDomainOpts = {\n                'domain_name': domain.name,\n                'domain_description': domain.description,\n                'domain_type': domain_param(domain.domainType),\n                'field_type': domain_param(domain.type),\n                'merge_policy': domain_param(domain.mergePolicy),\n                'split_policy': domain_param(domain.splitPolicy),\n            }\n            # Allow overrides\n            args.update(opts)\n        else:\n            args = opts\n        CreateDomain(in_workspace=str(self.workspace), **args)\n\n    def delete_domain(self, domain: str) -&gt; None:\n        \"\"\"Delete a domain from the workspace\n\n        Args:\n            domain (str): The name of the domain to delete\n        \"\"\"\n        DeleteDomain(str(self.workspace), domain)\n\n    def alter_domain(self, domain: str, **opts: Unpack[AlterDomainOpts]) -&gt; None:\n        \"\"\"Alter a domain using the given domain values\n\n        Args:\n            **opts (AlterDomainOpts): Passthrough for AlterDomain function\n        \"\"\"\n        AlterDomain(in_workspace=str(self.workspace), domain_name=domain, **opts)\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.dataset","title":"<code>dataset</code>  <code>property</code>","text":"<p>Get the parent Dataset object</p>"},{"location":"modules/database/#arcpie.database.DomainManager.domain_map","title":"<code>domain_map</code>  <code>property</code>","text":"<p>A mapping of domain names to domain objects</p>"},{"location":"modules/database/#arcpie.database.DomainManager.unused_domains","title":"<code>unused_domains</code>  <code>property</code>","text":""},{"location":"modules/database/#arcpie.database.DomainManager.workspace","title":"<code>workspace</code>  <code>property</code>","text":"<p>Get a path to the root workspace that the domains live in</p>"},{"location":"modules/database/#arcpie.database.DomainManager.__contains__","title":"<code>__contains__(domain)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __contains__(self, domain: str) -&gt; bool:\n    return domain in self.domain_map\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.__getitem__","title":"<code>__getitem__(name)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __getitem__(self, name: str) -&gt; Domain:\n    return self.domain_map[name]\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.__init__","title":"<code>__init__(dataset)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __init__(self, dataset: Dataset[Any]) -&gt; None:\n    self._dataset = dataset\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate all domains</p> Source code in <code>src/arcpie/database.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Domain]:\n    \"\"\"Iterate all domains\"\"\"\n    yield from self.domain_map.values()\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.__len__","title":"<code>__len__()</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.domain_map)\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.add_domain","title":"<code>add_domain(domain=None, **opts)</code>","text":"<p>Add a domain to the parent dataset or the root dataset (gdb)</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>Domain</code> <p>The domain object to add to the managed Dataset (optional)</p> <code>None</code> <code>**opts</code> <code>CreateDomainOpts</code> <p>Additional overrides that will be applied to the create domain call</p> <code>{}</code> Source code in <code>src/arcpie/database.py</code> <pre><code>def add_domain(self, domain: Domain|None=None, **opts: Unpack[CreateDomainOpts]) -&gt; None:\n    \"\"\"Add a domain to the parent dataset or the root dataset (gdb)\n\n    Args:\n        domain (Domain): The domain object to add to the managed Dataset (optional)\n        **opts (CreateDomainOpts): Additional overrides that will be applied to the create domain call\n    \"\"\"\n\n    if domain:\n        args: CreateDomainOpts = {\n            'domain_name': domain.name,\n            'domain_description': domain.description,\n            'domain_type': domain_param(domain.domainType),\n            'field_type': domain_param(domain.type),\n            'merge_policy': domain_param(domain.mergePolicy),\n            'split_policy': domain_param(domain.splitPolicy),\n        }\n        # Allow overrides\n        args.update(opts)\n    else:\n        args = opts\n    CreateDomain(in_workspace=str(self.workspace), **args)\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.alter_domain","title":"<code>alter_domain(domain, **opts)</code>","text":"<p>Alter a domain using the given domain values</p> <p>Parameters:</p> Name Type Description Default <code>**opts</code> <code>AlterDomainOpts</code> <p>Passthrough for AlterDomain function</p> <code>{}</code> Source code in <code>src/arcpie/database.py</code> <pre><code>def alter_domain(self, domain: str, **opts: Unpack[AlterDomainOpts]) -&gt; None:\n    \"\"\"Alter a domain using the given domain values\n\n    Args:\n        **opts (AlterDomainOpts): Passthrough for AlterDomain function\n    \"\"\"\n    AlterDomain(in_workspace=str(self.workspace), domain_name=domain, **opts)\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.delete_domain","title":"<code>delete_domain(domain)</code>","text":"<p>Delete a domain from the workspace</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>The name of the domain to delete</p> required Source code in <code>src/arcpie/database.py</code> <pre><code>def delete_domain(self, domain: str) -&gt; None:\n    \"\"\"Delete a domain from the workspace\n\n    Args:\n        domain (str): The name of the domain to delete\n    \"\"\"\n    DeleteDomain(str(self.workspace), domain)\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.get","title":"<code>get(name, default)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def get(self, name: str, default: _Default) -&gt; Domain | _Default:\n    try:\n        return self[name]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"modules/database/#arcpie.database.DomainManager.usage","title":"<code>usage(*domain_names)</code>","text":"<p>A mapping of domains to features to fields that shows usage of a domain in a dataset</p> <p>Parameters:</p> Name Type Description Default <code>*domain_names</code> <code>str</code> <p>Varargs of all domain names to include in the output mapping</p> <code>()</code> <p>Returns:</p> Type Description <code>dict[str, dict[str, list[str]]]</code> <p>( dict[str, dict[str, list[str]]] ) : A Nested mapping of <code>Domain Name -&gt; Feature Class -&gt; [Field Name, ...]</code></p> Source code in <code>src/arcpie/database.py</code> <pre><code>def usage(self, *domain_names: str) -&gt; dict[str, dict[str, list[str]]]:\n    \"\"\"A mapping of domains to features to fields that shows usage of a domain in a dataset\n\n    Args:\n        *domain_names (str): Varargs of all domain names to include in the output mapping\n\n    Returns:\n        ( dict[str, dict[str, list[str]]] ) : A Nested mapping of `Domain Name -&gt; Feature Class -&gt; [Field Name, ...]`\n    \"\"\"\n\n    if not domain_names:\n        domain_names = tuple(self.domain_map)\n    schema = self.dataset.schema\n    fc_usage: dict[str, dict[str, list[str]]] = {}\n    for ds in schema['datasets']:\n        if 'datasets' in ds:\n            ds = ds['datasets']\n        else:\n            ds = [ds]\n        for fc in filter(lambda f: 'fields' in f, ds):\n            for field in filter(lambda fld: 'domain' in fld, fc['fields']['fieldArray']):\n                assert 'domain' in field\n                if (dn := field['domain']['domainName']) in domain_names:\n                    fc_usage.setdefault(dn, {}).setdefault(fc['name'], [])\n                    fc_usage[dn][fc['name']].append(field.get('name', '??'))\n    return fc_usage\n</code></pre>"},{"location":"modules/database/#arcpie.database.Relationship","title":"<code>Relationship</code>","text":"<p>Methods:</p> Name Description <code>__init__</code> <code>add_rule</code> <code>delete</code> <p>Delete the relationship</p> <code>remove_rule</code> <code>update</code> <p>Update the relationship class</p> <p>Attributes:</p> Name Type Description <code>describe</code> <code>RelationshipClass</code> <code>destination_keys</code> <code>dict[Literal['DestinationPrimary', 'DestinationForeign'], str]</code> <p>Mapping of destination Primary and Foreign keys</p> <code>destinations</code> <code>list[FeatureClass | Table[Any]]</code> <p>Destination FeatureClass/Table objects</p> <code>name</code> <code>str</code> <code>origin_keys</code> <code>dict[Literal['OriginPrimary', 'OriginForeign'], str]</code> <p>Mapping of origin Primary and Foreign keys</p> <code>origins</code> <code>list[FeatureClass | Table[Any]]</code> <p>Origin FeatureClass/Table objects</p> <code>parent</code> <code>path</code> <code>settings</code> <code>RelationshipOpts</code> Source code in <code>src/arcpie/database.py</code> <pre><code>class Relationship:\n    def __init__(self, parent: Dataset[Any], path: Path|str) -&gt; None:\n        self.parent = parent\n        self.path = path\n\n    @cached_property\n    def describe(self) -&gt; RelationshipClass:\n        return Describe(str(self.path)) # pyright: ignore[reportUnknownVariableType]\n\n    @property\n    def name(self) -&gt; str:\n        return self.describe.name\n\n    @property\n    def settings(self) -&gt; RelationshipOpts:\n        return RelationshipOpts(\n            origin_table=self.describe.originClassNames[0],\n            destination_table=self.describe.destinationClassNames[0],\n            out_relationship_class=self.name,\n            relationship_type='COMPOSITE' if self.describe.isComposite else 'SIMPLE',\n            forward_label=self.describe.forwardPathLabel,\n            backward_label=self.describe.backwardPathLabel,\n            message_direction=self.describe.notification.upper(), # type: ignore\n            cardinality=convert_cardinality(self.describe.cardinality),\n            attributed= 'ATTRIBUTED' if self.describe.isAttributed else 'NONE',\n            origin_primary_key=self.origin_keys['OriginPrimary'],\n            origin_foreign_key=self.origin_keys['OriginForeign'],\n            destination_primary_key=self.destination_keys['DestinationPrimary'],\n            destination_foreign_key=self.destination_keys['DestinationForeign'],\n        )\n\n    @property\n    def origins(self) -&gt; list[FeatureClass | Table[Any]]:\n        \"\"\"Origin FeatureClass/Table objects\"\"\"\n        return [\n            self.parent.feature_classes.get(origin) or self.parent.tables[origin]\n            for origin in self.describe.originClassNames \n            if origin in self.parent\n        ]\n\n    @property\n    def origin_keys(self) -&gt; dict[Literal['OriginPrimary', 'OriginForeign'], str]:\n        \"\"\"Mapping of origin Primary and Foreign keys\"\"\"\n        keys = {\n            'OriginPrimary': '',\n            'OriginForeign': '',\n        }\n        for f, k, _ in self.describe.originClassKeys:\n            keys['OriginForeign'] = k if f == 'OriginForeign' else ''\n            keys['OriginPrimary'] = k if f == 'OriginPrimary' else ''\n        return keys # pyright: ignore[reportReturnType]\n\n    @property\n    def destinations(self) -&gt; list[FeatureClass | Table[Any]]:\n        \"\"\"Destination FeatureClass/Table objects\"\"\"\n        return [\n            self.parent.feature_classes.get(dest) or self.parent.tables[dest]\n            for dest in self.describe.destinationClassNames \n            if dest in self.parent\n        ]\n\n    @property\n    def destination_keys(self) -&gt; dict[Literal['DestinationPrimary', 'DestinationForeign'], str]:\n        \"\"\"Mapping of destination Primary and Foreign keys\"\"\"\n        keys = {\n            'DestinationPrimary': '',\n            'DestinationForeign': '',\n        }\n        for f, k, _ in self.describe.destinationClassKeys:\n            keys['DestinationForeign'] = k if f == 'DestinationForeign' else ''\n            keys['DestinationPrimary'] = k if f == 'DestinationPrimary' else ''\n        return keys # pyright: ignore[reportReturnType]\n\n    def add_rule(self, **options: Unpack[RelationshipAddRuleOpts]) -&gt; None:\n        options['in_rel_class'] = str(self.path)\n        AddRuleToRelationshipClass(**options)\n\n    def remove_rule(self, **options: Unpack[RelationshipRemoveRuleOpts]) -&gt; None:\n        options['in_rel_class'] = str(self.path)\n        RemoveRuleFromRelationshipClass(**options)\n\n    def delete(self) -&gt; None:\n        \"\"\"Delete the relationship\"\"\"\n        Delete(str(self.path), 'RelationshipClass')\n\n    def update(self, **options: Unpack[RelationshipOpts]) -&gt; None:\n        \"\"\"Update the relationship class\"\"\"\n        rel_opts = self.settings\n        self.delete()\n        rel_opts.update(options)\n        CreateRelationshipClass(**rel_opts)\n</code></pre>"},{"location":"modules/database/#arcpie.database.Relationship.describe","title":"<code>describe</code>  <code>cached</code> <code>property</code>","text":""},{"location":"modules/database/#arcpie.database.Relationship.destination_keys","title":"<code>destination_keys</code>  <code>property</code>","text":"<p>Mapping of destination Primary and Foreign keys</p>"},{"location":"modules/database/#arcpie.database.Relationship.destinations","title":"<code>destinations</code>  <code>property</code>","text":"<p>Destination FeatureClass/Table objects</p>"},{"location":"modules/database/#arcpie.database.Relationship.name","title":"<code>name</code>  <code>property</code>","text":""},{"location":"modules/database/#arcpie.database.Relationship.origin_keys","title":"<code>origin_keys</code>  <code>property</code>","text":"<p>Mapping of origin Primary and Foreign keys</p>"},{"location":"modules/database/#arcpie.database.Relationship.origins","title":"<code>origins</code>  <code>property</code>","text":"<p>Origin FeatureClass/Table objects</p>"},{"location":"modules/database/#arcpie.database.Relationship.parent","title":"<code>parent = parent</code>  <code>instance-attribute</code>","text":""},{"location":"modules/database/#arcpie.database.Relationship.path","title":"<code>path = path</code>  <code>instance-attribute</code>","text":""},{"location":"modules/database/#arcpie.database.Relationship.settings","title":"<code>settings</code>  <code>property</code>","text":""},{"location":"modules/database/#arcpie.database.Relationship.__init__","title":"<code>__init__(parent, path)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __init__(self, parent: Dataset[Any], path: Path|str) -&gt; None:\n    self.parent = parent\n    self.path = path\n</code></pre>"},{"location":"modules/database/#arcpie.database.Relationship.add_rule","title":"<code>add_rule(**options)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def add_rule(self, **options: Unpack[RelationshipAddRuleOpts]) -&gt; None:\n    options['in_rel_class'] = str(self.path)\n    AddRuleToRelationshipClass(**options)\n</code></pre>"},{"location":"modules/database/#arcpie.database.Relationship.delete","title":"<code>delete()</code>","text":"<p>Delete the relationship</p> Source code in <code>src/arcpie/database.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete the relationship\"\"\"\n    Delete(str(self.path), 'RelationshipClass')\n</code></pre>"},{"location":"modules/database/#arcpie.database.Relationship.remove_rule","title":"<code>remove_rule(**options)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def remove_rule(self, **options: Unpack[RelationshipRemoveRuleOpts]) -&gt; None:\n    options['in_rel_class'] = str(self.path)\n    RemoveRuleFromRelationshipClass(**options)\n</code></pre>"},{"location":"modules/database/#arcpie.database.Relationship.update","title":"<code>update(**options)</code>","text":"<p>Update the relationship class</p> Source code in <code>src/arcpie/database.py</code> <pre><code>def update(self, **options: Unpack[RelationshipOpts]) -&gt; None:\n    \"\"\"Update the relationship class\"\"\"\n    rel_opts = self.settings\n    self.delete()\n    rel_opts.update(options)\n    CreateRelationshipClass(**rel_opts)\n</code></pre>"},{"location":"modules/database/#arcpie.database.RelationshipManager","title":"<code>RelationshipManager</code>","text":"<p>Methods:</p> Name Description <code>__getitem__</code> <code>__init__</code> <code>__iter__</code> <code>__len__</code> <code>create</code> <p>Create a relationship</p> <code>delete</code> <p>Delete the relationship and return the settings so it can be made again</p> <code>get</code> <p>Attributes:</p> Name Type Description <code>names</code> <code>list[str]</code> <code>parent</code> <code>relationships</code> <code>dict[str, Relationship]</code> Source code in <code>src/arcpie/database.py</code> <pre><code>class RelationshipManager:\n    def __init__(self, parent: Dataset[Any]) -&gt; None:\n        self.parent = parent\n\n    @property\n    def relationships(self) -&gt; dict[str, Relationship]:\n        return self.parent._relationships # pyright: ignore[reportPrivateUsage]\n\n    @property\n    def names(self) -&gt; list[str]:\n        return list(self.relationships.keys())\n\n    def create(self, **options: Unpack[RelationshipOpts]) -&gt; None:\n        \"\"\"Create a relationship\"\"\"\n        CreateRelationshipClass(**options)\n\n    def delete(self, name: str) -&gt; RelationshipOpts | None:\n        \"\"\"Delete the relationship and return the settings so it can be made again\"\"\"\n        rel = self.get(name)\n        if rel is None:\n            return None\n        settings = rel.settings\n        rel.delete()\n        return settings\n\n    def __len__(self) -&gt; int:\n        return len(self.relationships)\n\n    def __iter__(self) -&gt; Iterator[Relationship]:\n        for rel in self.relationships.values():\n            yield rel\n\n    def __getitem__(self, key: str) -&gt; Relationship:\n        if key in self.relationships:\n            return self.relationships[key]\n        raise KeyError(f'{key} not found in {self.parent.name} Relationships')\n\n    def get(self, key: str, default: _Default=None) -&gt; Relationship | _Default:\n        try:\n            return self[key]\n        except KeyError:\n            return default\n</code></pre>"},{"location":"modules/database/#arcpie.database.RelationshipManager.names","title":"<code>names</code>  <code>property</code>","text":""},{"location":"modules/database/#arcpie.database.RelationshipManager.parent","title":"<code>parent = parent</code>  <code>instance-attribute</code>","text":""},{"location":"modules/database/#arcpie.database.RelationshipManager.relationships","title":"<code>relationships</code>  <code>property</code>","text":""},{"location":"modules/database/#arcpie.database.RelationshipManager.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __getitem__(self, key: str) -&gt; Relationship:\n    if key in self.relationships:\n        return self.relationships[key]\n    raise KeyError(f'{key} not found in {self.parent.name} Relationships')\n</code></pre>"},{"location":"modules/database/#arcpie.database.RelationshipManager.__init__","title":"<code>__init__(parent)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __init__(self, parent: Dataset[Any]) -&gt; None:\n    self.parent = parent\n</code></pre>"},{"location":"modules/database/#arcpie.database.RelationshipManager.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Relationship]:\n    for rel in self.relationships.values():\n        yield rel\n</code></pre>"},{"location":"modules/database/#arcpie.database.RelationshipManager.__len__","title":"<code>__len__()</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.relationships)\n</code></pre>"},{"location":"modules/database/#arcpie.database.RelationshipManager.create","title":"<code>create(**options)</code>","text":"<p>Create a relationship</p> Source code in <code>src/arcpie/database.py</code> <pre><code>def create(self, **options: Unpack[RelationshipOpts]) -&gt; None:\n    \"\"\"Create a relationship\"\"\"\n    CreateRelationshipClass(**options)\n</code></pre>"},{"location":"modules/database/#arcpie.database.RelationshipManager.delete","title":"<code>delete(name)</code>","text":"<p>Delete the relationship and return the settings so it can be made again</p> Source code in <code>src/arcpie/database.py</code> <pre><code>def delete(self, name: str) -&gt; RelationshipOpts | None:\n    \"\"\"Delete the relationship and return the settings so it can be made again\"\"\"\n    rel = self.get(name)\n    if rel is None:\n        return None\n    settings = rel.settings\n    rel.delete()\n    return settings\n</code></pre>"},{"location":"modules/database/#arcpie.database.RelationshipManager.get","title":"<code>get(key, default=None)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def get(self, key: str, default: _Default=None) -&gt; Relationship | _Default:\n    try:\n        return self[key]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"modules/database/#arcpie.database.convert_cardinality","title":"<code>convert_cardinality(arg)</code>","text":"Source code in <code>src/arcpie/database.py</code> <pre><code>def convert_cardinality(arg: str) -&gt; Literal['ONE_TO_ONE', 'ONE_TO_MANY', 'MANY_TO_MANY']:\n    if arg == 'OneToOne':\n        return 'ONE_TO_ONE'\n    if arg == 'OneToMany':\n        return 'ONE_TO_MANY'\n    if arg == 'ManyToMany':\n        return 'MANY_TO_MANY'\n    else:\n        raise ValueError(f'{arg} is not a valid relationsip type')\n</code></pre>"},{"location":"modules/diff/","title":"diff","text":"<p>Functions:</p> Name Description <code>attribute_rule_diff</code> <p>Get a diff of rules for matching FeatureClasses in the dataset</p> <code>domain_diff</code> <p>Get a diff of rules for matching FeatureClasses in the dataset</p> <code>feature_diff</code> <p>Get features that are added/removed from source/target</p> <code>field_diff</code> <p>Get fields that are added/removed from source/target</p> <code>layer_diff</code> <p>Get layers that are added/removed from source/target</p> <code>table_diff</code> <p>Get tables that are added/removed/changed from source/target</p> <p>Attributes:</p> Name Type Description <code>Diff</code>"},{"location":"modules/diff/#arcpie.diff.Diff","title":"<code>Diff = dict[Literal['added', 'removed', 'updated'], list[str] | list[dict[str, Any]]]</code>  <code>module-attribute</code>","text":""},{"location":"modules/diff/#arcpie.diff.attribute_rule_diff","title":"<code>attribute_rule_diff(source, target)</code>","text":"<p>Get a diff of rules for matching FeatureClasses in the dataset</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Dataset</code> <p>The starting point of the delta</p> required <code>target</code> <code>Dataset</code> <p>The ending point of the delta</p> required <p>Returns:</p> Type Description <code>dict[str, diff]</code> <p>A Mapping of Features to rules with a delta type</p> Source code in <code>src/arcpie/diff.py</code> <pre><code>def attribute_rule_diff(source: Dataset, target: Dataset) -&gt; dict[str, Diff]:\n    \"\"\"Get a diff of rules for matching FeatureClasses in the dataset\n\n    Args:\n        source (Dataset): The starting point of the delta\n        target (Dataset): The ending point of the delta\n\n    Returns:\n        (dict[str, diff]): A Mapping of Features to rules with a delta type\n    \"\"\"\n\n    _diffs: dict[str, Diff] = {}\n    for fc_name, source_fc in source.feature_classes.items():\n        if (target_fc := target.feature_classes.get(fc_name, None)) is not None:\n            _diffs.setdefault(fc_name, {})\n            _diffs[fc_name]['added'] = [rule for rule in target_fc.attribute_rules.names if rule not in source_fc.attribute_rules.names]\n            _diffs[fc_name]['removed'] = [rule for rule in source_fc.attribute_rules.names if rule not in target_fc.attribute_rules.names]\n            _diffs[fc_name]['updated'] = [\n                rule_name\n                for rule_name, rule in source_fc.attribute_rules.rules.items()\n                if rule and (t_rule := target_fc.attribute_rules.get(rule_name) )\n                and rule['scriptExpression'] != t_rule['scriptExpression']\n            ]\n    return {k:v for k, v in _diffs.items() if v['added'] or v['removed'] or v['updated']}\n</code></pre>"},{"location":"modules/diff/#arcpie.diff.domain_diff","title":"<code>domain_diff(source, target)</code>","text":"<p>Get a diff of rules for matching FeatureClasses in the dataset</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Dataset</code> <p>The starting point of the delta</p> required <code>target</code> <code>Dataset</code> <p>The ending point of the delta</p> required <p>Returns:</p> Type Description <code>Diff</code> <p>A domain diff</p> Source code in <code>src/arcpie/diff.py</code> <pre><code>def domain_diff(source: Dataset, target: Dataset) -&gt; Diff:\n    \"\"\"Get a diff of rules for matching FeatureClasses in the dataset\n\n    Args:\n        source (Dataset): The starting point of the delta\n        target (Dataset): The ending point of the delta\n\n    Returns:\n        (Diff): A domain diff\n    \"\"\"\n    _diff: Diff = {}\n    _to_check: list[str] = ['codedValues', 'description', 'domainType', 'mergePolicy', 'splitPolicy', 'type']\n    _diff['added'] = [d for d in target.domains if d not in source.domains]\n    _diff['removed'] = [d for d in source.domains if d not in target.domains]\n    _diff['updated'] = [\n        {name : changes}\n        for name, source_domain in source.domains.items()\n        if name in target.domains\n        and (changes := {\n            attr: f\"{getattr(source_domain, attr, None)} -&gt; {getattr(target.domains[name], attr, None)}\"\n            for attr in _to_check\n            if str(getattr(source_domain, attr, None)) != str(getattr(target.domains[name], attr, None))\n        })\n    ]\n    return _diff\n</code></pre>"},{"location":"modules/diff/#arcpie.diff.feature_diff","title":"<code>feature_diff(source, target)</code>","text":"<p>Get features that are added/removed from source/target</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Dataset</code> <p>The starting point of the delta</p> required <code>target</code> <code>Dataset</code> <p>The ending point of the delta</p> required <p>Returns:</p> Type Description <code>Diff</code> <p>FeatureClass delta</p> Source code in <code>src/arcpie/diff.py</code> <pre><code>def feature_diff(source: Dataset, target: Dataset) -&gt; Diff:\n    \"\"\"Get features that are added/removed from source/target\n\n    Args:\n        source (Dataset): The starting point of the delta\n        target (Dataset): The ending point of the delta\n\n    Returns:\n        (Diff): FeatureClass delta\n    \"\"\"\n    _diff: Diff = {}\n    _diff['added'] = list(set(target.feature_classes) - set(source.feature_classes))\n    _diff['removed'] = list(set(source.feature_classes) - set(target.feature_classes))\n    _diff['updated'] = [\n        fc for fc in source.feature_classes\n        if fc in target\n        and (\n            set(target.feature_classes[fc].fields) != set(source.feature_classes[fc].fields)\n            or not target.feature_classes[fc].py_types.values() == source.feature_classes[fc].py_types.values()\n        ) \n    ]\n    return _diff\n</code></pre>"},{"location":"modules/diff/#arcpie.diff.field_diff","title":"<code>field_diff(source, target)</code>","text":"<p>Get fields that are added/removed from source/target</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Dataset</code> <p>The starting point of the delta</p> required <code>target</code> <code>Dataset</code> <p>The ending point of the delta</p> required <p>Returns:</p> Type Description <code>dict[str, Diff]</code> <p>A Mapping of feature names to field deltas</p> Source code in <code>src/arcpie/diff.py</code> <pre><code>def field_diff(source: Dataset, target: Dataset) -&gt; dict[str, Diff]:\n    \"\"\"Get fields that are added/removed from source/target\n\n    Args:\n        source (Dataset): The starting point of the delta\n        target (Dataset): The ending point of the delta\n\n    Returns:\n        (dict[str, Diff]): A Mapping of feature names to field deltas\n    \"\"\"\n    _diffs: dict[str, Diff] = {}\n    for fc_name, source_fc in source.feature_classes.items():\n        if (target_fc := target.feature_classes.get(fc_name, None)) is not None:\n            _diffs.setdefault(fc_name, {})\n            _diffs[fc_name]['added'] = [f for f in target_fc.fields if f not in source_fc.fields]\n            _diffs[fc_name]['removed'] = [f for f in source_fc.fields if f not in target_fc.fields]\n\n            # Compare fields from matching features\n            _to_compare = ('baseName', 'aliasName', 'defaultValue', 'domain', \n                           'editable', 'isNullable', 'length', 'name', \n                           'precision', 'required', 'scale', 'type')\n            _source_fields = {f.baseName: f for f in source_fc.describe.fields}\n            _target_fields = {f.baseName: f for f in target_fc.describe.fields}\n            _diffs[fc_name]['updated'] = [\n                {f : changes} \n                for f in _source_fields\n                if f in _target_fields\n                and (changes := {\n                    attr: f\"{getattr(_source_fields[f], attr)} -&gt; {getattr(_target_fields[f], attr)}\"\n                    for attr in _to_compare\n                    if getattr(_source_fields[f], attr) != getattr(_target_fields[f], attr)\n                })\n            ]\n\n    return {k:v for k, v in _diffs.items() if v['added'] or v['removed'] or v['updated']}\n</code></pre>"},{"location":"modules/diff/#arcpie.diff.layer_diff","title":"<code>layer_diff(source, target)</code>","text":"<p>Get layers that are added/removed from source/target</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Project</code> <p>The starting point of the delta</p> required <code>target</code> <code>Project</code> <p>The ending point of the delta</p> required <p>Returns:</p> Type Description <code>dict[str, Diff]</code> <p>A Mapping of map names to layer deltas</p> Source code in <code>src/arcpie/diff.py</code> <pre><code>def layer_diff(source: Project, target: Project) -&gt; dict[str, Diff]:\n    \"\"\"Get layers that are added/removed from source/target\n\n    Args:\n        source (Project): The starting point of the delta\n        target (Project): The ending point of the delta\n\n    Returns:\n        (dict[str, Diff]): A Mapping of map names to layer deltas\n    \"\"\"\n    _diffs: dict[str, Diff] = {}\n    for source_map in source.maps:\n        map_name = source_map.unique_name\n        if (target_map := target.maps.get(source_map.unique_name, None)) is not None:\n            _diffs.setdefault(map_name, {})\n            _diffs[map_name]['added'] = list(set(target_map.layers.names) - set(source_map.layers.names))\n            _diffs[map_name]['removed'] = list(set(source_map.layers.names) - set(target_map.layers.names))\n            _diffs[map_name]['updated'] = [\n                l.unique_name for l in source_map.layers\n                if hasattr(l, 'name') \n                and l.unique_name in target_map.layers.names\n                and (source_cim := l.cim_dict)\n                and (target_cim := target_map.layers[l.unique_name].cim_dict)\n                and any(\n                    str(source_cim.get(k, 'Source')) != str(target_cim.get(k, 'Target'))\n                    for k in ['renderer', 'labelClasses'] # Only compare symbology and labels\n                )\n            ]\n    return {k:v for k, v in _diffs.items() if v['added'] or v['removed'] or v['updated']}\n</code></pre>"},{"location":"modules/diff/#arcpie.diff.table_diff","title":"<code>table_diff(source, target)</code>","text":"<p>Get tables that are added/removed/changed from source/target</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Project</code> <p>The starting point of the delta</p> required <code>target</code> <code>Project</code> <p>The ending point of the delta</p> required <p>Returns:</p> Type Description <code>dict[str, Diff]</code> <p>A Mapping of map names to table deltas</p> Source code in <code>src/arcpie/diff.py</code> <pre><code>def table_diff(source: Project, target: Project) -&gt; dict[str, Diff]:\n    \"\"\"Get tables that are added/removed/changed from source/target\n\n    Args:\n        source (Project): The starting point of the delta\n        target (Project): The ending point of the delta\n\n    Returns:\n        (dict[str, Diff]): A Mapping of map names to table deltas\n    \"\"\"\n    _diffs: dict[str, Diff] = {}\n    for source_map in source.maps:\n        map_name = source_map.unique_name\n        if (target_map := target.maps.get(source_map.unique_name, None)) is not None:\n            _diffs.setdefault(map_name, {})\n            _diffs[map_name]['added'] = list(set(target_map.tables.names) - set(source_map.tables.names))\n            _diffs[map_name]['removed'] = list(set(source_map.tables.names) - set(target_map.tables.names))\n            _diffs[map_name]['updated'] = [\n                t.unique_name for t in source_map.tables\n                if hasattr(t, 'name') \n                and t.unique_name in target_map.tables.names\n                and (source_cim := t.cim_dict)\n                and (target_cim := target_map.tables[t.unique_name].cim_dict)\n                and any(\n                    str(source_cim.get(k, 'Source')) != str(target_cim.get(k, 'Target'))\n                    for k in ['displayField'] # Only compare display field\n                )\n            ]\n    return {k:v for k, v in _diffs.items() if v['added'] or v['removed'] or v['updated']}\n</code></pre>"},{"location":"modules/featureclass/","title":"featureclass","text":"<p>Classes:</p> Name Description <code>AttributeRuleManager</code> <p>Handler for interacting with AttributeRules on a FeatureClass or Table</p> <code>FeatureClass</code> <p>A Wrapper for ArcGIS FeatureClass objects</p> <code>Table</code> <p>A Wrapper for ArcGIS Table objects</p> <p>Functions:</p> Name Description <code>as_dict</code> <p>Take a Cusrsor object and yield rows from it </p> <code>count</code> <p>Get the record count of a FeatureClass</p> <code>extract_singleton</code> <p>Helper function to allow passing single values to arguments that expect a tuple</p> <code>filter_fields</code> <p>Decorator for filter functions that limits fields checked by the SearchCursor</p> <code>format_query_list</code> <p>Format a list of values into a SQL list</p> <code>norm</code> <p>Normalize a value for SQL query (wrap strings in single quotes)</p> <code>valid_field</code> <p>Validate a fieldname</p> <code>where</code> <p>Wrap a string in a WhereClause object to use with indexing</p> <p>Attributes:</p> Name Type Description <code>FieldName</code> <p>Alias for string that specifies the function needs a valid fieldname</p> <code>FilterFunc</code> <p>The expected type signature for function indexing</p> <code>RowRecord</code> <p>Alias for a dictionary of fieldnames and field values</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FieldName","title":"<code>FieldName = str</code>  <code>module-attribute</code>","text":"<p>Alias for string that specifies the function needs a valid fieldname</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FilterFunc","title":"<code>FilterFunc = Callable[[_Schema], bool]</code>  <code>module-attribute</code>","text":"<p>The expected type signature for function indexing</p>"},{"location":"modules/featureclass/#arcpie.featureclass.RowRecord","title":"<code>RowRecord = dict[FieldName, Any]</code>  <code>module-attribute</code>","text":"<p>Alias for a dictionary of fieldnames and field values</p>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager","title":"<code>AttributeRuleManager</code>","text":"<p>Handler for interacting with AttributeRules on a FeatureClass or Table</p> <p>Methods:</p> Name Description <code>__contains__</code> <code>__getitem__</code> <code>__init__</code> <code>__iter__</code> <code>__setitem__</code> <p>The primary method for interacting with attribute rules</p> <code>add_attribute_rule</code> <code>alter_attribute_rule</code> <code>delete_attribute_rule</code> <p>Delete provided attribute rules from the ruleset</p> <code>delete_attribute_rules</code> <p>DEPRECATED: USE <code>delete_attribute_rule</code> instead</p> <code>disable_attribute_rule</code> <p>Disable provided attribute rules from the ruleset</p> <code>disable_attribute_rules</code> <p>DEPRECATED: USE <code>disable_attribute_rule</code> instead</p> <code>enable_attribute_rule</code> <p>Enable provided attribute rules in the ruleset</p> <code>enable_attribute_rules</code> <p>DEPRECATED: USE <code>enable_attribute_rule</code> instead</p> <code>export_rules</code> <p>Write attribute rules out to a structured directory</p> <code>get</code> <code>import_rules</code> <p>Import attribute rules that were previously exported to the filesystem for editing</p> <code>sync</code> <p>Sync the rules in this FeatureClass/Table instance with those of another overwriting </p> <p>Attributes:</p> Name Type Description <code>names</code> <code>list[str]</code> <code>parent</code> <code>Table[Any] | FeatureClass</code> <code>rules</code> <code>dict[str, AttributeRule]</code> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>class AttributeRuleManager:\n    \"\"\"Handler for interacting with AttributeRules on a FeatureClass or Table\"\"\"\n    def __init__(self, parent: Table[Any]|FeatureClass) -&gt; None:\n        self._parent = parent\n\n    @property\n    def names(self) -&gt; list[str]:\n        return list(self.rules.keys())\n\n    @property\n    def parent(self) -&gt; Table[Any] | FeatureClass:\n        return self._parent \n\n    @property\n    def rules(self) -&gt; dict[str, AttributeRule]:\n        return {\n            rule['name']: AttributeRule(rule) \n            for rule in self._parent.da_describe['attributeRules']\n        }\n\n    def export_rules(self, out_dir: Path|str) -&gt; None:\n        \"\"\"Write attribute rules out to a structured directory\n\n        Args:\n            out_dir (Path|str): The target directory to dump all attribute rules and configs to\n\n        Note:\n            out_dir -&gt; fc_name -&gt; [rule_name.cfg, rule_name.js]\n        \"\"\"\n        out_dir = Path(out_dir)\n        for rule_name, rule in self.rules.items():\n            rule_name = rule_name.replace('/', '-') # Arc allows / in rulenames\n            _script: str = str(rule.pop('scriptExpression', '')) # TypedDict has bugged pop typing\n            out_file = out_dir / self._parent.name / rule_name\n            out_file.parent.mkdir(exist_ok=True, parents=True)\n            out_file.with_suffix('.js').write_text(_script)\n            out_file.with_suffix('.cfg').write_text(json.dumps(rule, indent=2))\n        return\n\n    def import_rules(self, src_dir: Path|str, *, strict: bool=False, disable: bool=False) -&gt; None:\n        \"\"\"Import attribute rules that were previously exported to the filesystem for editing\n\n        Args:\n            src_dir (Path|str): The directory that contains the `.cfg` and `.js` files for each rule\n            strict (bool): Delete any attribute rules in the FeatureClass that do not have a matching file (default: False)\n            disable (bool): Disable any attribute rules in the FeatureClass that do not have a matching file (default: False)\n\n        Note:\n            the `disable` option will be ignored if strict is not set\n        \"\"\"\n        # Ensure that only the directory for the parent FC is accessed\n        src_dir = Path(src_dir)\n        if src_dir.stem != self.parent.name:\n            src_dir = src_dir / self.parent.name\n\n        _old_rules = {k: v.copy() for k,v in self.rules.items()}\n        _imported_rule_names: set[str] = set()\n        rule_config: AttributeRule = {'name': 'UNINITIALIZED'} # type: ignore\n        try:\n            rule_orders: dict[str, int] = {}\n            for cfg in src_dir.glob('*.cfg'):\n                # Grab base config and attach script sidecar\n                rule_config: AttributeRule = json.loads(cfg.read_text(encoding='utf-8'))\n                rule_script = cfg.with_suffix('.js').read_text(encoding='utf-8')\n                rule = rule_config.copy()\n                rule['scriptExpression'] = rule_script\n\n                # Let the __setitem__ logic handle the rule (alter/add)\n                self[rule['name']] = rule\n                _imported_rule_names.add(rule['name'])\n\n                # Store order for re-ordering later\n                rule_orders[rule['name']] = rule['evaluationOrder']\n\n            # Re-Order added rules if they don't match\n            for rule_name, rule_order in sorted(rule_orders.items(), key=lambda i: i[1]):\n                if rule_name not in self.rules:\n                    continue\n                if self.rules[rule_name]['evaluationOrder'] != rule_order:\n                    self.alter_attribute_rule(name=rule_name, evaluation_order=rule_order)\n\n            if strict and (to_remove := set(self.names).difference(_imported_rule_names)):\n                if disable:\n                    self.disable_attribute_rule(*to_remove)\n                else:\n                    self.delete_attribute_rule(*to_remove)\n        except Exception as e:\n            # Revert the import if an Exception is rasied\n            for rule_name, rule in _old_rules.items():\n                if rule_name in _imported_rule_names:\n                    self[rule_name] = rule\n\n            # Remove rules\n            if (to_remove := set(_old_rules).difference(self.names)):\n                self.delete_attribute_rule(*to_remove)\n\n            e.add_note(f\"{rule_config['name']} failed to import\")\n            e.add_note(f'Config: {pformat(convert_rule(rule_config))}')\n            e.add_note(f'Transaction reverted for {_imported_rule_names} in {self.parent.name}')\n            raise e # Raise the Exception\n\n    def sync(self, target: FeatureClass|Table) -&gt; None:\n        \"\"\"Sync the rules in this FeatureClass/Table instance with those of another overwriting \n        the current ruleset with the targeted ruleset\n\n        Args:\n            target (FeatureClass|Table): The target ruleset to overwrite the current rules with\n        \"\"\"\n        # Use existing import functionality\n        with TemporaryDirectory() as temp:\n            target.attribute_rules.export_rules(temp)\n            self.import_rules(temp)\n\n    def add_attribute_rule(self, **rule: Unpack[AddRuleOpts]) -&gt; None:\n\n        # The AddAttributeRule function requires subtype codes to be converted to names\n        # Since AlterAttributeRule does not accept subtypes\n        _subtypes: list[str] = []\n        for subtype in rule.get('subtype', []):\n            if int(subtype) in self.parent.subtypes:\n                _subtypes.append(self.parent.subtypes[int(subtype)]['Name'])\n        if _subtypes:\n            rule['subtype'] = _subtypes\n\n        AddAttributeRule(self._parent.path, **rule)\n\n    def alter_attribute_rule(self, evaluation_order: int | None=None, **rule: Unpack[AlterRuleOpts]) -&gt; None:\n        if evaluation_order: # Handle reorder\n            ReorderAttributeRule(self._parent.path, rule['name'], evaluation_order)\n        if rule:\n            AlterAttributeRule(self._parent.path, **rule)\n\n    def delete_attribute_rule(self, *rule_name: str, delete_all: bool=False) -&gt; None:\n        \"\"\"Delete provided attribute rules from the ruleset\n\n        Args:\n            *rule_name (str): The rule names to delete as positional varargs\n            delete_all (bool): If this flag is set, the noarg case will delete all rules (default: False)\n        \"\"\"\n        if not rule_name and delete_all:\n            rule_name = tuple(self.names)\n        DeleteAttributeRule(str(self.parent), rule_name)\n\n    @deprecated('Use delete_attribute_rule(*rule_name, ...) [varargs] instead')\n    def delete_attribute_rules(self, rule_names: Sequence[str]) -&gt; None:\n        \"\"\"DEPRECATED: USE `delete_attribute_rule` instead\"\"\"\n        self.delete_attribute_rule(*rule_names) \n\n    def disable_attribute_rule(self, *rule_name: str, disable_all: bool=False) -&gt; None:\n        \"\"\"Disable provided attribute rules from the ruleset\n\n        Args:\n            *rule_name (str): The rule names to delete as positional varargs\n            disable_all (bool): If this flag is set, the noarg case will disable all rules (default: False)\n        \"\"\"\n        if not rule_name and disable_all:\n            rule_name = tuple(self.names)\n        DisableAttributeRules(str(self.parent), rule_name)\n\n    @deprecated('Use disable_attribute_rules(*rule_name, ...) [varargs] instead')\n    def disable_attribute_rules(self, rule_names: Sequence[str]) -&gt; None:\n        \"\"\"DEPRECATED: USE `disable_attribute_rule` instead\"\"\"\n        self.disable_attribute_rule(*rule_names)\n\n    def enable_attribute_rule(self, *rule_name: str, enable_all: bool=False) -&gt; None:\n        \"\"\"Enable provided attribute rules in the ruleset\n\n        Args:\n            *rule_name (str): The rule names to delete as positional varargs\n            enable_all (bool): If this flag is set, the noarg case will enable all rules (default: False)\n        \"\"\"\n        if not rule_name and enable_all:\n            rule_name = tuple(self.names)\n        EnableAttributeRules(str(self.parent), rule_name)\n\n    @deprecated('Use enable_attribute_rules(*rule_name, ...) [varargs] instead')\n    def enable_attribute_rules(self, rule_names: Sequence[str]) -&gt; None:\n        \"\"\"DEPRECATED: USE `enable_attribute_rule` instead\"\"\"\n        self.enable_attribute_rule(*rule_names)\n\n    def __iter__(self) -&gt; Iterator[AttributeRule]:\n        return iter(self.rules.values())\n\n    def __getitem__(self, rule_name: str) -&gt; AttributeRule:\n        return self.rules[rule_name]\n\n    def __contains__(self, name: str) -&gt; bool:\n        return name in self.names\n\n    def __setitem__(self, rule_name: str, new_rule: AttributeRule) -&gt; None:\n        \"\"\"The primary method for interacting with attribute rules\n\n        The setitem override will take any dictionary that contains the keys expected by \n        the `AttributeRule` definition. Alteration or Addition is determined and applied \n        depending on the name of the rule and its state compared to the matching rule in \n        the current ruleset.\n\n        Example:\n            ```python\n            &gt;&gt;&gt; fc.attribute_rules.names\n            ['Rule A', 'Rule B']\n            &gt;&gt;&gt; fc.attribute_rules['Rule A'] = {'isEnabled': False}\n            ```\n        \"\"\"\n        new_rule['name'] = rule_name\n        current_rule = self.get(rule_name)\n        is_enabled = new_rule.get('isEnabled', True)\n\n        # Skip fields that are modified by the system\n        skip_compare = {\n            'id',\n            'type',\n            'requiredGeodatabaseClientVersion',\n            'creationTime',\n        }\n\n        # Add a new rule\n        if not current_rule:\n            self.add_attribute_rule(**to_rule_add(new_rule))\n            if not is_enabled:\n                self.disable_attribute_rule(rule_name)\n            return\n\n        # Enable/Disable\n        if is_enabled and not current_rule['isEnabled']:\n            self.enable_attribute_rule(rule_name)\n        elif not is_enabled and current_rule['isEnabled']:\n            self.disable_attribute_rule(rule_name)\n        is_enabled = current_rule['isEnabled']\n\n        # Get Changes\n        changes: dict[str, Any] = {\n            setting: new_rule[setting]\n            for setting in current_rule \n            if setting not in skip_compare\n            and setting in new_rule\n            and new_rule[setting] != current_rule[setting]\n        }\n\n        if not changes:\n            return\n\n        # Subtype change requires a re-build\n        if 'subtypeCodes'in changes:\n            self.delete_attribute_rule(rule_name)\n            current_rule.update(new_rule)\n            self.add_attribute_rule(**to_rule_add(current_rule))\n        else:\n            self.alter_attribute_rule(\n                evaluation_order=changes.get('evaluatonOrder'),\n                **to_rule_alter(new_rule)\n            )\n\n    def get(self, rule_name: str, default: _T=None) -&gt; AttributeRule | _T:\n        return self.rules.get(rule_name, default)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.names","title":"<code>names</code>  <code>property</code>","text":""},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.parent","title":"<code>parent</code>  <code>property</code>","text":""},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.rules","title":"<code>rules</code>  <code>property</code>","text":""},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.__contains__","title":"<code>__contains__(name)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __contains__(self, name: str) -&gt; bool:\n    return name in self.names\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.__getitem__","title":"<code>__getitem__(rule_name)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __getitem__(self, rule_name: str) -&gt; AttributeRule:\n    return self.rules[rule_name]\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.__init__","title":"<code>__init__(parent)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __init__(self, parent: Table[Any]|FeatureClass) -&gt; None:\n    self._parent = parent\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __iter__(self) -&gt; Iterator[AttributeRule]:\n    return iter(self.rules.values())\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.__setitem__","title":"<code>__setitem__(rule_name, new_rule)</code>","text":"<p>The primary method for interacting with attribute rules</p> <p>The setitem override will take any dictionary that contains the keys expected by  the <code>AttributeRule</code> definition. Alteration or Addition is determined and applied  depending on the name of the rule and its state compared to the matching rule in  the current ruleset.</p> Example <pre><code>&gt;&gt;&gt; fc.attribute_rules.names\n['Rule A', 'Rule B']\n&gt;&gt;&gt; fc.attribute_rules['Rule A'] = {'isEnabled': False}\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __setitem__(self, rule_name: str, new_rule: AttributeRule) -&gt; None:\n    \"\"\"The primary method for interacting with attribute rules\n\n    The setitem override will take any dictionary that contains the keys expected by \n    the `AttributeRule` definition. Alteration or Addition is determined and applied \n    depending on the name of the rule and its state compared to the matching rule in \n    the current ruleset.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; fc.attribute_rules.names\n        ['Rule A', 'Rule B']\n        &gt;&gt;&gt; fc.attribute_rules['Rule A'] = {'isEnabled': False}\n        ```\n    \"\"\"\n    new_rule['name'] = rule_name\n    current_rule = self.get(rule_name)\n    is_enabled = new_rule.get('isEnabled', True)\n\n    # Skip fields that are modified by the system\n    skip_compare = {\n        'id',\n        'type',\n        'requiredGeodatabaseClientVersion',\n        'creationTime',\n    }\n\n    # Add a new rule\n    if not current_rule:\n        self.add_attribute_rule(**to_rule_add(new_rule))\n        if not is_enabled:\n            self.disable_attribute_rule(rule_name)\n        return\n\n    # Enable/Disable\n    if is_enabled and not current_rule['isEnabled']:\n        self.enable_attribute_rule(rule_name)\n    elif not is_enabled and current_rule['isEnabled']:\n        self.disable_attribute_rule(rule_name)\n    is_enabled = current_rule['isEnabled']\n\n    # Get Changes\n    changes: dict[str, Any] = {\n        setting: new_rule[setting]\n        for setting in current_rule \n        if setting not in skip_compare\n        and setting in new_rule\n        and new_rule[setting] != current_rule[setting]\n    }\n\n    if not changes:\n        return\n\n    # Subtype change requires a re-build\n    if 'subtypeCodes'in changes:\n        self.delete_attribute_rule(rule_name)\n        current_rule.update(new_rule)\n        self.add_attribute_rule(**to_rule_add(current_rule))\n    else:\n        self.alter_attribute_rule(\n            evaluation_order=changes.get('evaluatonOrder'),\n            **to_rule_alter(new_rule)\n        )\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.add_attribute_rule","title":"<code>add_attribute_rule(**rule)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def add_attribute_rule(self, **rule: Unpack[AddRuleOpts]) -&gt; None:\n\n    # The AddAttributeRule function requires subtype codes to be converted to names\n    # Since AlterAttributeRule does not accept subtypes\n    _subtypes: list[str] = []\n    for subtype in rule.get('subtype', []):\n        if int(subtype) in self.parent.subtypes:\n            _subtypes.append(self.parent.subtypes[int(subtype)]['Name'])\n    if _subtypes:\n        rule['subtype'] = _subtypes\n\n    AddAttributeRule(self._parent.path, **rule)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.alter_attribute_rule","title":"<code>alter_attribute_rule(evaluation_order=None, **rule)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def alter_attribute_rule(self, evaluation_order: int | None=None, **rule: Unpack[AlterRuleOpts]) -&gt; None:\n    if evaluation_order: # Handle reorder\n        ReorderAttributeRule(self._parent.path, rule['name'], evaluation_order)\n    if rule:\n        AlterAttributeRule(self._parent.path, **rule)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.delete_attribute_rule","title":"<code>delete_attribute_rule(*rule_name, delete_all=False)</code>","text":"<p>Delete provided attribute rules from the ruleset</p> <p>Parameters:</p> Name Type Description Default <code>*rule_name</code> <code>str</code> <p>The rule names to delete as positional varargs</p> <code>()</code> <code>delete_all</code> <code>bool</code> <p>If this flag is set, the noarg case will delete all rules (default: False)</p> <code>False</code> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def delete_attribute_rule(self, *rule_name: str, delete_all: bool=False) -&gt; None:\n    \"\"\"Delete provided attribute rules from the ruleset\n\n    Args:\n        *rule_name (str): The rule names to delete as positional varargs\n        delete_all (bool): If this flag is set, the noarg case will delete all rules (default: False)\n    \"\"\"\n    if not rule_name and delete_all:\n        rule_name = tuple(self.names)\n    DeleteAttributeRule(str(self.parent), rule_name)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.delete_attribute_rules","title":"<code>delete_attribute_rules(rule_names)</code>","text":"<p>DEPRECATED: USE <code>delete_attribute_rule</code> instead</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@deprecated('Use delete_attribute_rule(*rule_name, ...) [varargs] instead')\ndef delete_attribute_rules(self, rule_names: Sequence[str]) -&gt; None:\n    \"\"\"DEPRECATED: USE `delete_attribute_rule` instead\"\"\"\n    self.delete_attribute_rule(*rule_names) \n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.disable_attribute_rule","title":"<code>disable_attribute_rule(*rule_name, disable_all=False)</code>","text":"<p>Disable provided attribute rules from the ruleset</p> <p>Parameters:</p> Name Type Description Default <code>*rule_name</code> <code>str</code> <p>The rule names to delete as positional varargs</p> <code>()</code> <code>disable_all</code> <code>bool</code> <p>If this flag is set, the noarg case will disable all rules (default: False)</p> <code>False</code> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def disable_attribute_rule(self, *rule_name: str, disable_all: bool=False) -&gt; None:\n    \"\"\"Disable provided attribute rules from the ruleset\n\n    Args:\n        *rule_name (str): The rule names to delete as positional varargs\n        disable_all (bool): If this flag is set, the noarg case will disable all rules (default: False)\n    \"\"\"\n    if not rule_name and disable_all:\n        rule_name = tuple(self.names)\n    DisableAttributeRules(str(self.parent), rule_name)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.disable_attribute_rules","title":"<code>disable_attribute_rules(rule_names)</code>","text":"<p>DEPRECATED: USE <code>disable_attribute_rule</code> instead</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@deprecated('Use disable_attribute_rules(*rule_name, ...) [varargs] instead')\ndef disable_attribute_rules(self, rule_names: Sequence[str]) -&gt; None:\n    \"\"\"DEPRECATED: USE `disable_attribute_rule` instead\"\"\"\n    self.disable_attribute_rule(*rule_names)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.enable_attribute_rule","title":"<code>enable_attribute_rule(*rule_name, enable_all=False)</code>","text":"<p>Enable provided attribute rules in the ruleset</p> <p>Parameters:</p> Name Type Description Default <code>*rule_name</code> <code>str</code> <p>The rule names to delete as positional varargs</p> <code>()</code> <code>enable_all</code> <code>bool</code> <p>If this flag is set, the noarg case will enable all rules (default: False)</p> <code>False</code> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def enable_attribute_rule(self, *rule_name: str, enable_all: bool=False) -&gt; None:\n    \"\"\"Enable provided attribute rules in the ruleset\n\n    Args:\n        *rule_name (str): The rule names to delete as positional varargs\n        enable_all (bool): If this flag is set, the noarg case will enable all rules (default: False)\n    \"\"\"\n    if not rule_name and enable_all:\n        rule_name = tuple(self.names)\n    EnableAttributeRules(str(self.parent), rule_name)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.enable_attribute_rules","title":"<code>enable_attribute_rules(rule_names)</code>","text":"<p>DEPRECATED: USE <code>enable_attribute_rule</code> instead</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@deprecated('Use enable_attribute_rules(*rule_name, ...) [varargs] instead')\ndef enable_attribute_rules(self, rule_names: Sequence[str]) -&gt; None:\n    \"\"\"DEPRECATED: USE `enable_attribute_rule` instead\"\"\"\n    self.enable_attribute_rule(*rule_names)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.export_rules","title":"<code>export_rules(out_dir)</code>","text":"<p>Write attribute rules out to a structured directory</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>Path | str</code> <p>The target directory to dump all attribute rules and configs to</p> required Note <p>out_dir -&gt; fc_name -&gt; [rule_name.cfg, rule_name.js]</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def export_rules(self, out_dir: Path|str) -&gt; None:\n    \"\"\"Write attribute rules out to a structured directory\n\n    Args:\n        out_dir (Path|str): The target directory to dump all attribute rules and configs to\n\n    Note:\n        out_dir -&gt; fc_name -&gt; [rule_name.cfg, rule_name.js]\n    \"\"\"\n    out_dir = Path(out_dir)\n    for rule_name, rule in self.rules.items():\n        rule_name = rule_name.replace('/', '-') # Arc allows / in rulenames\n        _script: str = str(rule.pop('scriptExpression', '')) # TypedDict has bugged pop typing\n        out_file = out_dir / self._parent.name / rule_name\n        out_file.parent.mkdir(exist_ok=True, parents=True)\n        out_file.with_suffix('.js').write_text(_script)\n        out_file.with_suffix('.cfg').write_text(json.dumps(rule, indent=2))\n    return\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.get","title":"<code>get(rule_name, default=None)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def get(self, rule_name: str, default: _T=None) -&gt; AttributeRule | _T:\n    return self.rules.get(rule_name, default)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.import_rules","title":"<code>import_rules(src_dir, *, strict=False, disable=False)</code>","text":"<p>Import attribute rules that were previously exported to the filesystem for editing</p> <p>Parameters:</p> Name Type Description Default <code>src_dir</code> <code>Path | str</code> <p>The directory that contains the <code>.cfg</code> and <code>.js</code> files for each rule</p> required <code>strict</code> <code>bool</code> <p>Delete any attribute rules in the FeatureClass that do not have a matching file (default: False)</p> <code>False</code> <code>disable</code> <code>bool</code> <p>Disable any attribute rules in the FeatureClass that do not have a matching file (default: False)</p> <code>False</code> Note <p>the <code>disable</code> option will be ignored if strict is not set</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def import_rules(self, src_dir: Path|str, *, strict: bool=False, disable: bool=False) -&gt; None:\n    \"\"\"Import attribute rules that were previously exported to the filesystem for editing\n\n    Args:\n        src_dir (Path|str): The directory that contains the `.cfg` and `.js` files for each rule\n        strict (bool): Delete any attribute rules in the FeatureClass that do not have a matching file (default: False)\n        disable (bool): Disable any attribute rules in the FeatureClass that do not have a matching file (default: False)\n\n    Note:\n        the `disable` option will be ignored if strict is not set\n    \"\"\"\n    # Ensure that only the directory for the parent FC is accessed\n    src_dir = Path(src_dir)\n    if src_dir.stem != self.parent.name:\n        src_dir = src_dir / self.parent.name\n\n    _old_rules = {k: v.copy() for k,v in self.rules.items()}\n    _imported_rule_names: set[str] = set()\n    rule_config: AttributeRule = {'name': 'UNINITIALIZED'} # type: ignore\n    try:\n        rule_orders: dict[str, int] = {}\n        for cfg in src_dir.glob('*.cfg'):\n            # Grab base config and attach script sidecar\n            rule_config: AttributeRule = json.loads(cfg.read_text(encoding='utf-8'))\n            rule_script = cfg.with_suffix('.js').read_text(encoding='utf-8')\n            rule = rule_config.copy()\n            rule['scriptExpression'] = rule_script\n\n            # Let the __setitem__ logic handle the rule (alter/add)\n            self[rule['name']] = rule\n            _imported_rule_names.add(rule['name'])\n\n            # Store order for re-ordering later\n            rule_orders[rule['name']] = rule['evaluationOrder']\n\n        # Re-Order added rules if they don't match\n        for rule_name, rule_order in sorted(rule_orders.items(), key=lambda i: i[1]):\n            if rule_name not in self.rules:\n                continue\n            if self.rules[rule_name]['evaluationOrder'] != rule_order:\n                self.alter_attribute_rule(name=rule_name, evaluation_order=rule_order)\n\n        if strict and (to_remove := set(self.names).difference(_imported_rule_names)):\n            if disable:\n                self.disable_attribute_rule(*to_remove)\n            else:\n                self.delete_attribute_rule(*to_remove)\n    except Exception as e:\n        # Revert the import if an Exception is rasied\n        for rule_name, rule in _old_rules.items():\n            if rule_name in _imported_rule_names:\n                self[rule_name] = rule\n\n        # Remove rules\n        if (to_remove := set(_old_rules).difference(self.names)):\n            self.delete_attribute_rule(*to_remove)\n\n        e.add_note(f\"{rule_config['name']} failed to import\")\n        e.add_note(f'Config: {pformat(convert_rule(rule_config))}')\n        e.add_note(f'Transaction reverted for {_imported_rule_names} in {self.parent.name}')\n        raise e # Raise the Exception\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.AttributeRuleManager.sync","title":"<code>sync(target)</code>","text":"<p>Sync the rules in this FeatureClass/Table instance with those of another overwriting  the current ruleset with the targeted ruleset</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>FeatureClass | Table</code> <p>The target ruleset to overwrite the current rules with</p> required Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def sync(self, target: FeatureClass|Table) -&gt; None:\n    \"\"\"Sync the rules in this FeatureClass/Table instance with those of another overwriting \n    the current ruleset with the targeted ruleset\n\n    Args:\n        target (FeatureClass|Table): The target ruleset to overwrite the current rules with\n    \"\"\"\n    # Use existing import functionality\n    with TemporaryDirectory() as temp:\n        target.attribute_rules.export_rules(temp)\n        self.import_rules(temp)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass","title":"<code>FeatureClass</code>","text":"<p>               Bases: <code>Table[_Schema]</code>, <code>Generic[_GeometryType, _Schema]</code></p> <p>A Wrapper for ArcGIS FeatureClass objects</p> Example <pre><code>&gt;&gt;&gt; # Initialize FeatureClass with Geometry Type\n&gt;&gt;&gt; point_features = FeatureClass[PointGeometry]('&lt;feature_class_path&gt;')\n&gt;&gt;&gt; # Create a buffer Iterator\n&gt;&gt;&gt; buffers = (pt.buffer(10) for pt in point_features.shapes)\n... \n&gt;&gt;&gt; sr = SpatialReference(4206)\n&gt;&gt;&gt; # Set a new spatial reference\n&gt;&gt;&gt; with point_features.reference_as(sr):\n...     # Consume the Iterator, but with the new reference\n...     for buffer in buffers:\n...        area = buffer.area\n...        units = sr.linearUnitName\n...        print(f\"{area} Sq{units}\")\n</code></pre> <p>Methods:</p> Name Description <code>__format__</code> <code>__getitem__</code> <p>Handle all defined overloads using pattern matching syntax</p> <code>__init__</code> <code>copy</code> <p>Create a new FeatureClass instance to prevent overriding a shared resource</p> <code>footprint</code> <p>Merge all geometry in the featureclass using current SelectionOptions into a single geometry object to use </p> <code>from_layer</code> <p>Build a FeatureClass object from a layer applying the layer's current selection to the stored cursors</p> <code>get</code> <p>Allows safe indexing of a FeatureClass, see <code>Table.get</code> for more information</p> <code>get_transformation</code> <p>Get the name of the transformation to convert from feature reference to provided reference</p> <code>recalculate_extent</code> <p>Recalculate the FeatureClass Extent</p> <code>reference_as</code> <p>Allows you to temporarily set a spatial reference on SearchCursor and UpdateCursor objects within a context block</p> <code>spatial_filter</code> <p>Apply a spatial filter to the FeatureClass in a context</p> <p>Attributes:</p> Name Type Description <code>Tokens</code> <code>describe</code> <code>FeatureClass</code> <p>A describe object fort the FeatureClass</p> <code>extent</code> <code>Extent</code> <p>Get the stored extent of the FeatureClass</p> <code>fields</code> <code>tuple[FieldName | FeatureToken, ...]</code> <p>Tuple of all fieldnames in the FeatureClass with <code>OID@</code> and <code>SHAPE@</code> as first 2</p> <code>py_types</code> <code>dict[str, type]</code> <p>Get a mapping of the field types for the FeatureClass</p> <code>shape_extent</code> <code>Extent | None</code> <p>Get a new extent by finding the maximum extent of the current shapes. </p> <code>shape_field_name</code> <code>str</code> <p>The name for the base shape field of the FeatureClass</p> <code>shape_token</code> <code>ShapeToken</code> <p>Set the default <code>SHAPE@??</code> token for iteration. Use <code>SHAPE@</code> for full shape (default: <code>SHAPE@</code>)</p> <code>shape_type</code> <code>type[_GeometryType]</code> <code>shapes</code> <code>Iterator[_GeometryType]</code> <p>An iterator of feature shapes</p> <code>spatial_reference</code> <p>The SpatialReference object for the FeatureClass</p> <code>units</code> <code>str</code> <p>The unit name of the FeatureClass</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>class FeatureClass(Table[_Schema], Generic[_GeometryType, _Schema]):\n    \"\"\"A Wrapper for ArcGIS FeatureClass objects\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # Initialize FeatureClass with Geometry Type\n        &gt;&gt;&gt; point_features = FeatureClass[PointGeometry]('&lt;feature_class_path&gt;')\n        &gt;&gt;&gt; # Create a buffer Iterator\n        &gt;&gt;&gt; buffers = (pt.buffer(10) for pt in point_features.shapes)\n        ... \n        &gt;&gt;&gt; sr = SpatialReference(4206)\n        &gt;&gt;&gt; # Set a new spatial reference\n        &gt;&gt;&gt; with point_features.reference_as(sr):\n        ...     # Consume the Iterator, but with the new reference\n        ...     for buffer in buffers:\n        ...        area = buffer.area\n        ...        units = sr.linearUnitName\n        ...        print(f\"{area} Sq{units}\")\n        ```\n    \"\"\"\n\n    Tokens = FeatureTokens\n\n    def __init__(\n            self, path: str|Path,\n            *,\n            search_options: SearchOptions|None=None, \n            update_options: UpdateOptions|None=None, \n            insert_options: InsertOptions|None=None,\n            clause: SQLClause|None=None,\n            where: str|None=None,\n            shape_token: ShapeToken='SHAPE@'\n        ) -&gt; None:\n        super().__init__(\n            path=path, \n            search_options=search_options, update_options=update_options, insert_options=insert_options, \n            clause=clause, where=where\n        )\n        self._shape_token: ShapeToken = shape_token\n\n    # rw Properties\n\n    @property\n    def shape_token(self) -&gt; ShapeToken:\n        \"\"\"Set the default `SHAPE@??` token for iteration. Use `SHAPE@` for full shape (default: `SHAPE@`)\"\"\"\n        return self._shape_token\n\n    @shape_token.setter\n    def shape_token(self, shape_token: ShapeToken) -&gt; None:\n        self._shape_token = shape_token\n\n    # ro Properties\n\n    @property\n    def shape_type(self) -&gt; type[_GeometryType]:\n        for shape in self.shapes:\n            return type(shape)\n        else:\n            return Geometry # type: ignore\n\n    @property\n    def describe(self) -&gt; dt.FeatureClass: # pyright: ignore[reportIncompatibleMethodOverride]\n        \"\"\"A describe object fort the FeatureClass\"\"\"\n        return Describe(self.path) # type: ignore\n\n    @property\n    def shape_field_name(self) -&gt; str:\n        \"\"\"The name for the base shape field of the FeatureClass\"\"\"\n        return self.describe.shapeFieldName\n\n    @property\n    def fields(self) -&gt; tuple[FieldName | FeatureToken, ...]:\n        \"\"\"Tuple of all fieldnames in the FeatureClass with `OID@` and `SHAPE@` as first 2\"\"\"\n        if self._fields:\n            return self._fields\n        exclude = (self.oid_field_name, self.shape_field_name)\n        replace = ('OID@', self.shape_token)\n        _fields = ()\n        with self.search_cursor('*') as c:\n            _fields = c.fields\n        self._fields = replace + tuple((f for f in _fields if f not in exclude))\n        return self._fields\n\n    @property\n    def shapes(self) -&gt; Iterator[_GeometryType]:\n        \"\"\"An iterator of feature shapes\"\"\"\n        yield from ( shape for shape, in self.search_cursor('SHAPE@'))\n\n    @property\n    def spatial_reference(self):\n        \"\"\"The SpatialReference object for the FeatureClass\"\"\"\n        return self.describe.spatialReference\n\n    @property\n    def units(self) -&gt; str:\n        \"\"\"The unit name of the FeatureClass\"\"\"\n        return self.spatial_reference.linearUnitName\n\n    @property\n    def extent(self) -&gt; Extent:\n        \"\"\"Get the stored extent of the FeatureClass\"\"\"\n        return self.describe.extent\n\n    @property\n    def shape_extent(self) -&gt; Extent | None:\n        \"\"\"Get a new extent by finding the maximum extent of the current shapes. \n\n        If no features, None is returned\n        will respect the spatial reference applied in a context manager (inherit ref from shapes)\n        \"\"\"\n        x_max = None\n        x_min = None\n        y_max = None\n        y_min = None\n        s_ref = None\n        for s in self.shapes:\n            if s_ref is None:\n                s_ref = s.spatialReference\n            x_max = max(s.extent.XMax, x_max or s.extent.XMax)\n            x_min = min(s.extent.XMax, x_min or s.extent.XMin)\n            y_max = max(s.extent.YMax, y_max or s.extent.YMax)\n            y_min = min(s.extent.YMax, y_min or s.extent.YMin)\n        if all([x_min, x_max, y_min, y_max]):\n            return Extent(x_min, y_min, x_max, y_max, spatial_reference=s_ref)\n\n\n    @property\n    def py_types(self) -&gt; dict[str, type]:\n        \"\"\"Get a mapping of the field types for the FeatureClass\"\"\"\n        _types = convert_dtypes(self.np_dtypes)\n        if 'SHAPE@' in _types and len(self) &gt; 0:\n                _types['SHAPE@'] = type(next(self.shapes))\n        return _types\n    # Data Operations\n\n    @overload\n    def footprint(self, buffer: float) -&gt; Polygon | None: ...\n    @overload\n    def footprint(self, buffer: None) -&gt; _GeometryType | None: ...\n    @overload\n    def footprint(self, /) -&gt; _GeometryType | None: ...\n    def footprint(self, buffer: float|None=None) -&gt; _GeometryType | Polygon | None:\n        \"\"\"Merge all geometry in the featureclass using current SelectionOptions into a single geometry object to use \n        as a spatial filter on other FeatureClasses\n\n        Args:\n            buffer (float | None): Optional buffer (in feature units, respects projection context) to buffer by (default: None)\n\n        Returns:\n            (GeometryType | None): A merged Multi-Geometry of all feature geometries or `None` if no features in FeatureClass\n        \"\"\"\n        if len(self) == 0:\n            return None\n\n        def merge(acc: _GeometryType | Polygon, nxt: _GeometryType | Polygon) -&gt; _GeometryType | Polygon:\n            # Return type of union is Geometry for all types which is incorrect, it is Polygon\n            if buffer:\n                return acc.union(nxt.buffer(buffer)) # pyright: ignore[reportReturnType]\n            else:\n                return acc.union(nxt) # pyright: ignore[reportReturnType]\n\n        # Consume the shape generator popping off the first shape and applying the buffer, \n        # Then buffering each additional shape and merging it into the accumulator (starting with _first)\n        _shapes = self.shapes\n        for _first in _shapes:\n            break\n        else:\n            return None\n\n        if buffer:\n            _first = _first.buffer(buffer)\n\n        return reduce(merge, _shapes, _first)\n\n    def recalculate_extent(self) -&gt; None:\n        \"\"\"Recalculate the FeatureClass Extent\"\"\"\n        RecalculateFeatureClassExtent(self.path, 'STORE_EXTENT')\n\n    # Magic Methods\n\n    @overload\n    def __getitem__(self, field: tuple[FieldName, ...]) -&gt; Iterator[tuple[Any, ...]]: ...\n    @overload\n    def __getitem__(self, field: list[FieldName]) -&gt; Iterator[list[Any]]: ...\n    @overload\n    def __getitem__(self, field: set[FieldName]) -&gt; Iterator[_Schema]: ...\n    @overload # Overload 'SHAPE@' for special case before FieldName (which it is a subset of)\n    def __getitem__(self, field: Literal['SHAPE@']) -&gt; Iterator[_GeometryType]: ...\n    @overload\n    def __getitem__(self, field: FieldName) -&gt; Iterator[Any]: ...\n    @overload\n    def __getitem__(self, field: FilterFunc[_Schema]) -&gt; Iterator[_Schema]: ...\n    @overload\n    def __getitem__(self, field: WhereClause) -&gt; Iterator[_Schema]: ...\n    @overload\n    def __getitem__(self, field: None) -&gt; Iterator[None]: ...\n    @overload\n    def __getitem__(self, field: GeometryType | Extent) -&gt; Iterator[_Schema]: ...\n    def __getitem__(self, field: Table._IndexableTypes | FilterFunc[_Schema] | Extent | GeometryType | Literal['SHAPE@']) -&gt; Iterator[Any]:\n        \"\"\"Handle all defined overloads using pattern matching syntax\n\n        Args:\n            field (str): Yield values in the specified column (values only)\n            field (list[str]): Yield lists of values for requested columns (requested fields)\n            field (tuple[str]): Yield tuples of values for requested columns (requested fields)\n            field (set[str]): Yield dictionaries of values for requested columns (requested fields)\n            field (Geometry | Extent): Yield dictionaries of values for all features intersecting the specified shape\n            field (FilterFunc): Yield rows that match function (all fields)\n            field (WhereClause): Yield rows that match clause (all fields)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; # Single Field\n            &gt;&gt;&gt; print(list(fc['field']))\n            [val1, val2, val3, ...]\n\n            &gt;&gt;&gt; # Field Tuple\n            &gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n            [(val1, val2), (val1, val2), ...]\n\n            &gt;&gt;&gt; # Field List\n            &gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n            [[val1, val2], [val1, val2], ...]\n\n            &gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n            &gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n            [{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n            &gt;&gt;&gt; # Last two options always return all fields in a mapping\n            &gt;&gt;&gt; # Filter Function (passed to FeatureClass.filter())\n            &gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n            &gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # Shape Filter (provide a shape to use as a spatial filter on the rows)\n            &gt;&gt;&gt; print(list(fc[shape]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # None (Empty Iterator)\n            &gt;&gt;&gt; print(list(fc[None]))\n            ```\n        \"\"\"\n        match field:\n            case 'SHAPE@':\n                yield from self.shapes\n            case shape if isinstance(shape, Extent | GeometryType):\n                with self.search_cursor(*self.fields, spatial_filter=shape) as cur:\n                    yield from (row for row in self.as_dict(cur))\n            case field if isinstance(field, str|set|list|tuple|Callable|WhereClause|None):\n                yield from super().__getitem__(field)\n            case _:\n                raise KeyError(f'{type(field)}: {field}')\n\n    @overload\n    def get(self, field: tuple[FieldName, ...], default: _T) -&gt; Iterator[tuple[Any, ...]] | _T: ...\n    @overload\n    def get(self, field: list[FieldName], default: _T) -&gt; Iterator[list[Any]] | _T: ...\n    @overload\n    def get(self, field: set[FieldName], default: _T) -&gt; Iterator[_Schema] | _T: ...\n    @overload # Overload 'SHAPE@' for special case before FieldName (which it is a subset of)\n    def get(self, field: Literal['SHAPE@'], default: _T) -&gt; Iterator[_GeometryType] | _T: ...\n    @overload\n    def get(self, field: FieldName, default: _T) -&gt; Iterator[Any] | _T: ...\n    @overload\n    def get(self, field: FilterFunc[_Schema], default: _T) -&gt; Iterator[_Schema] | _T: ...\n    @overload\n    def get(self, field: WhereClause, default: _T) -&gt; Iterator[_Schema] | _T: ...\n    @overload\n    def get(self, field: None, default: _T) -&gt; Iterator[None] | _T: ...\n    @overload\n    def get(self, field: GeometryType | Extent, default: _T) -&gt; Iterator[_Schema] | _T: ...\n    def get(self, field: Table._IndexableTypes | FilterFunc[_Schema] | Extent | GeometryType | Literal['SHAPE@'], default: _T=None) -&gt; Iterator[Any] | _T:\n        \"\"\"Allows safe indexing of a FeatureClass, see `Table.get` for more information\"\"\"\n        try:\n            return self[field]\n        except (KeyError, RuntimeError) as e:\n            if isinstance(e, RuntimeError) and 'Cannot find field' in str(e):\n                raise\n            return default\n\n    def __format__(self, format_spec: str) -&gt; str:\n        match format_spec:\n            case 'shape' | 'shp':\n                return self.describe.shapeType\n            case 'wkid' | 'code':\n                return str(self.spatial_reference.factoryCode)\n            case 'unit':\n                return self.spatial_reference.linearUnitName\n            case _:\n                return super().__format__(format_spec)\n\n    # Context Managers\n\n    @contextmanager\n    def reference_as(self, spatial_reference: SpatialReference):\n        \"\"\"Allows you to temporarily set a spatial reference on SearchCursor and UpdateCursor objects within a context block\n\n        Args:\n            spatial_reference (SpatialReference): The spatial reference to apply to the cursor objects\n\n        Yields:\n            (self): Mutated self with search and update options set to use the provided spatial reference\n\n        Example:\n            ```python\n            &gt;&gt;&gt; sr = arcpy.SpatialReference(26971)\n            &gt;&gt;&gt; fc = FeatureClass[Polygon]('&lt;fc_path&gt;')\n\n            &gt;&gt;&gt; orig_shapes = list(fc.shapes)\n\n            &gt;&gt;&gt; with fc.project_as(sr):\n            ...     proj_shapes = list(fc.shapes)\n\n            &gt;&gt;&gt; print(orig_shapes[0].spatialReference)\n            SpatialReference(4326)\n\n            &gt;&gt;&gt; print(proj_shapes[0].spatialReference)\n            SpatialReference(26971)\n            ```\n        \"\"\"\n        with self.options(\n            search_options=SearchOptions(spatial_reference=spatial_reference), \n            update_options=UpdateOptions(spatial_reference=spatial_reference)):\n            yield self\n\n    @contextmanager\n    def spatial_filter(self, spatial_filter: GeometryType | Extent, spatial_relationship: SpatialRelationship='INTERSECTS'):\n        \"\"\"Apply a spatial filter to the FeatureClass in a context\n\n        Args:\n            spatial_filter (Geometry | Extent): The geometry to use as a spatial filter\n            spatial_relationship (SpatialRelationship): The relationship to check for (default: `INTERSECTS`)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; with fc.spatial_filter(boundary) as f:\n            ...     print(len(fc))\n            100\n            &gt;&gt;&gt; print(len(fc))\n            50000\n            ```\n\n        Note:\n            Same as with `where`, this method will be much faster than any manual `filter` you can apply using python. \n            If you need to filter a FeatureClass by a spatial relationship, use this method, then do your expensive \n            `filter` operation on the reduced dataset\n\n            ```python\n            &gt;&gt;&gt; def expensive_filter(rec):\n            &gt;&gt;&gt;     ...\n            &gt;&gt;&gt; with fc.spatial_filter(boundary) as local:\n            &gt;&gt;&gt;     for row in fc.filter(expensive_filter):\n            &gt;&gt;&gt;         ...\n            ```\n        \"\"\"\n        with self.options(\n            search_options=SearchOptions(\n                spatial_filter=spatial_filter, \n                spatial_relationship=spatial_relationship)):\n            yield self\n\n    def get_transformation(self, to_ref: SpatialReference) -&gt; str | None:\n        \"\"\"Get the name of the transformation to convert from feature reference to provided reference\n\n        Args:\n            to_ref (SpatialReference): The spatial reference to get a transformation for\n\n        Returns:\n            (str | None): The name of the first transformation or None if no transformation available\n        \"\"\"\n        trans = ListTransformations(self.spatial_reference, to_ref, first_only=True)\n        if not trans:\n            return None\n        return trans[0]\n\n    # Factory Constructors        \n\n    @classmethod\n    def from_layer(cls, layer: Layer,\n                   *,\n                   ignore_selection: bool = False,\n                   ignore_def_query: bool = False,) -&gt; FeatureClass:\n        \"\"\"Build a FeatureClass object from a layer applying the layer's current selection to the stored cursors\n\n        Args:\n            layer (Layer): The layer to convert to a FeatureClass\n            ignore_selection (bool): Ignore the layer selection (default: False)\n            ignore_def_query (bool): Ignore the layer definition query (default: False)\n        Returns:\n            ( FeatureClass ): The FeatureClass object with the layer query applied\n        \"\"\"\n        fc = cls(layer.dataSource)\n\n        selected_ids: set[int] | None = (\n            layer.getSelectionSet() or None\n            if not ignore_selection \n            else None\n        )\n        definition_query: str|None = (\n            layer.definitionQuery or None\n            if not ignore_def_query \n            else None\n        )\n        selection: str|None = (\n            f\"{fc.oid_field_name} IN ({format_query_list(selected_ids)})\" \n            if selected_ids \n            else None\n        )\n\n        if (query_components := list(filter(None, [definition_query, selection]))):\n            where_clause = ' AND '.join(query_components)\n            fc.search_options = SearchOptions(where_clause=where_clause)\n            fc.update_options = UpdateOptions(where_clause=where_clause)\n\n        fc.layer = layer\n        return fc\n\n    def copy(self) -&gt; FeatureClass[_GeometryType, _Schema]:\n        \"\"\"Create a new FeatureClass instance to prevent overriding a shared resource\"\"\"\n        return FeatureClass[_GeometryType, _Schema](\n            self._path, \n            search_options=self.search_options.copy(),\n            update_options=self.update_options.copy(),\n            insert_options=self.insert_options.copy(),\n            clause=self.clause,\n            shape_token=self.shape_token,\n        )\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.Tokens","title":"<code>Tokens = FeatureTokens</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.describe","title":"<code>describe</code>  <code>property</code>","text":"<p>A describe object fort the FeatureClass</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.extent","title":"<code>extent</code>  <code>property</code>","text":"<p>Get the stored extent of the FeatureClass</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.fields","title":"<code>fields</code>  <code>property</code>","text":"<p>Tuple of all fieldnames in the FeatureClass with <code>OID@</code> and <code>SHAPE@</code> as first 2</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.py_types","title":"<code>py_types</code>  <code>property</code>","text":"<p>Get a mapping of the field types for the FeatureClass</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.shape_extent","title":"<code>shape_extent</code>  <code>property</code>","text":"<p>Get a new extent by finding the maximum extent of the current shapes. </p> <p>If no features, None is returned will respect the spatial reference applied in a context manager (inherit ref from shapes)</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.shape_field_name","title":"<code>shape_field_name</code>  <code>property</code>","text":"<p>The name for the base shape field of the FeatureClass</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.shape_token","title":"<code>shape_token</code>  <code>property</code> <code>writable</code>","text":"<p>Set the default <code>SHAPE@??</code> token for iteration. Use <code>SHAPE@</code> for full shape (default: <code>SHAPE@</code>)</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.shape_type","title":"<code>shape_type</code>  <code>property</code>","text":""},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.shapes","title":"<code>shapes</code>  <code>property</code>","text":"<p>An iterator of feature shapes</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.spatial_reference","title":"<code>spatial_reference</code>  <code>property</code>","text":"<p>The SpatialReference object for the FeatureClass</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.units","title":"<code>units</code>  <code>property</code>","text":"<p>The unit name of the FeatureClass</p>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.__format__","title":"<code>__format__(format_spec)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __format__(self, format_spec: str) -&gt; str:\n    match format_spec:\n        case 'shape' | 'shp':\n            return self.describe.shapeType\n        case 'wkid' | 'code':\n            return str(self.spatial_reference.factoryCode)\n        case 'unit':\n            return self.spatial_reference.linearUnitName\n        case _:\n            return super().__format__(format_spec)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.__getitem__","title":"<code>__getitem__(field)</code>","text":"<pre><code>__getitem__(\n    field: tuple[FieldName, ...],\n) -&gt; Iterator[tuple[Any, ...]]\n</code></pre><pre><code>__getitem__(field: list[FieldName]) -&gt; Iterator[list[Any]]\n</code></pre><pre><code>__getitem__(field: set[FieldName]) -&gt; Iterator[_Schema]\n</code></pre><pre><code>__getitem__(\n    field: Literal[\"SHAPE@\"],\n) -&gt; Iterator[_GeometryType]\n</code></pre><pre><code>__getitem__(field: FieldName) -&gt; Iterator[Any]\n</code></pre><pre><code>__getitem__(\n    field: FilterFunc[_Schema],\n) -&gt; Iterator[_Schema]\n</code></pre><pre><code>__getitem__(field: WhereClause) -&gt; Iterator[_Schema]\n</code></pre><pre><code>__getitem__(field: None) -&gt; Iterator[None]\n</code></pre><pre><code>__getitem__(\n    field: GeometryType | Extent,\n) -&gt; Iterator[_Schema]\n</code></pre> <p>Handle all defined overloads using pattern matching syntax</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>Yield values in the specified column (values only)</p> required <code>field</code> <code>list[str]</code> <p>Yield lists of values for requested columns (requested fields)</p> required <code>field</code> <code>tuple[str]</code> <p>Yield tuples of values for requested columns (requested fields)</p> required <code>field</code> <code>set[str]</code> <p>Yield dictionaries of values for requested columns (requested fields)</p> required <code>field</code> <code>Geometry | Extent</code> <p>Yield dictionaries of values for all features intersecting the specified shape</p> required <code>field</code> <code>FilterFunc</code> <p>Yield rows that match function (all fields)</p> required <code>field</code> <code>WhereClause</code> <p>Yield rows that match clause (all fields)</p> required Example <pre><code>&gt;&gt;&gt; # Single Field\n&gt;&gt;&gt; print(list(fc['field']))\n[val1, val2, val3, ...]\n\n&gt;&gt;&gt; # Field Tuple\n&gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n[(val1, val2), (val1, val2), ...]\n\n&gt;&gt;&gt; # Field List\n&gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n[[val1, val2], [val1, val2], ...]\n\n&gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n&gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n[{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n&gt;&gt;&gt; # Last two options always return all fields in a mapping\n&gt;&gt;&gt; # Filter Function (passed to FeatureClass.filter())\n&gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n&gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # Shape Filter (provide a shape to use as a spatial filter on the rows)\n&gt;&gt;&gt; print(list(fc[shape]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # None (Empty Iterator)\n&gt;&gt;&gt; print(list(fc[None]))\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __getitem__(self, field: Table._IndexableTypes | FilterFunc[_Schema] | Extent | GeometryType | Literal['SHAPE@']) -&gt; Iterator[Any]:\n    \"\"\"Handle all defined overloads using pattern matching syntax\n\n    Args:\n        field (str): Yield values in the specified column (values only)\n        field (list[str]): Yield lists of values for requested columns (requested fields)\n        field (tuple[str]): Yield tuples of values for requested columns (requested fields)\n        field (set[str]): Yield dictionaries of values for requested columns (requested fields)\n        field (Geometry | Extent): Yield dictionaries of values for all features intersecting the specified shape\n        field (FilterFunc): Yield rows that match function (all fields)\n        field (WhereClause): Yield rows that match clause (all fields)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # Single Field\n        &gt;&gt;&gt; print(list(fc['field']))\n        [val1, val2, val3, ...]\n\n        &gt;&gt;&gt; # Field Tuple\n        &gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n        [(val1, val2), (val1, val2), ...]\n\n        &gt;&gt;&gt; # Field List\n        &gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n        [[val1, val2], [val1, val2], ...]\n\n        &gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n        &gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n        [{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n        &gt;&gt;&gt; # Last two options always return all fields in a mapping\n        &gt;&gt;&gt; # Filter Function (passed to FeatureClass.filter())\n        &gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n        &gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # Shape Filter (provide a shape to use as a spatial filter on the rows)\n        &gt;&gt;&gt; print(list(fc[shape]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # None (Empty Iterator)\n        &gt;&gt;&gt; print(list(fc[None]))\n        ```\n    \"\"\"\n    match field:\n        case 'SHAPE@':\n            yield from self.shapes\n        case shape if isinstance(shape, Extent | GeometryType):\n            with self.search_cursor(*self.fields, spatial_filter=shape) as cur:\n                yield from (row for row in self.as_dict(cur))\n        case field if isinstance(field, str|set|list|tuple|Callable|WhereClause|None):\n            yield from super().__getitem__(field)\n        case _:\n            raise KeyError(f'{type(field)}: {field}')\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.__init__","title":"<code>__init__(path, *, search_options=None, update_options=None, insert_options=None, clause=None, where=None, shape_token='SHAPE@')</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __init__(\n        self, path: str|Path,\n        *,\n        search_options: SearchOptions|None=None, \n        update_options: UpdateOptions|None=None, \n        insert_options: InsertOptions|None=None,\n        clause: SQLClause|None=None,\n        where: str|None=None,\n        shape_token: ShapeToken='SHAPE@'\n    ) -&gt; None:\n    super().__init__(\n        path=path, \n        search_options=search_options, update_options=update_options, insert_options=insert_options, \n        clause=clause, where=where\n    )\n    self._shape_token: ShapeToken = shape_token\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.copy","title":"<code>copy()</code>","text":"<p>Create a new FeatureClass instance to prevent overriding a shared resource</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def copy(self) -&gt; FeatureClass[_GeometryType, _Schema]:\n    \"\"\"Create a new FeatureClass instance to prevent overriding a shared resource\"\"\"\n    return FeatureClass[_GeometryType, _Schema](\n        self._path, \n        search_options=self.search_options.copy(),\n        update_options=self.update_options.copy(),\n        insert_options=self.insert_options.copy(),\n        clause=self.clause,\n        shape_token=self.shape_token,\n    )\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.footprint","title":"<code>footprint(buffer=None)</code>","text":"<pre><code>footprint(buffer: float) -&gt; Polygon | None\n</code></pre><pre><code>footprint(buffer: None) -&gt; _GeometryType | None\n</code></pre><pre><code>footprint() -&gt; _GeometryType | None\n</code></pre> <p>Merge all geometry in the featureclass using current SelectionOptions into a single geometry object to use  as a spatial filter on other FeatureClasses</p> <p>Parameters:</p> Name Type Description Default <code>buffer</code> <code>float | None</code> <p>Optional buffer (in feature units, respects projection context) to buffer by (default: None)</p> <code>None</code> <p>Returns:</p> Type Description <code>GeometryType | None</code> <p>A merged Multi-Geometry of all feature geometries or <code>None</code> if no features in FeatureClass</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def footprint(self, buffer: float|None=None) -&gt; _GeometryType | Polygon | None:\n    \"\"\"Merge all geometry in the featureclass using current SelectionOptions into a single geometry object to use \n    as a spatial filter on other FeatureClasses\n\n    Args:\n        buffer (float | None): Optional buffer (in feature units, respects projection context) to buffer by (default: None)\n\n    Returns:\n        (GeometryType | None): A merged Multi-Geometry of all feature geometries or `None` if no features in FeatureClass\n    \"\"\"\n    if len(self) == 0:\n        return None\n\n    def merge(acc: _GeometryType | Polygon, nxt: _GeometryType | Polygon) -&gt; _GeometryType | Polygon:\n        # Return type of union is Geometry for all types which is incorrect, it is Polygon\n        if buffer:\n            return acc.union(nxt.buffer(buffer)) # pyright: ignore[reportReturnType]\n        else:\n            return acc.union(nxt) # pyright: ignore[reportReturnType]\n\n    # Consume the shape generator popping off the first shape and applying the buffer, \n    # Then buffering each additional shape and merging it into the accumulator (starting with _first)\n    _shapes = self.shapes\n    for _first in _shapes:\n        break\n    else:\n        return None\n\n    if buffer:\n        _first = _first.buffer(buffer)\n\n    return reduce(merge, _shapes, _first)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.from_layer","title":"<code>from_layer(layer, *, ignore_selection=False, ignore_def_query=False)</code>  <code>classmethod</code>","text":"<p>Build a FeatureClass object from a layer applying the layer's current selection to the stored cursors</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer to convert to a FeatureClass</p> required <code>ignore_selection</code> <code>bool</code> <p>Ignore the layer selection (default: False)</p> <code>False</code> <code>ignore_def_query</code> <code>bool</code> <p>Ignore the layer definition query (default: False)</p> <code>False</code> <p>Returns:     ( FeatureClass ): The FeatureClass object with the layer query applied</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@classmethod\ndef from_layer(cls, layer: Layer,\n               *,\n               ignore_selection: bool = False,\n               ignore_def_query: bool = False,) -&gt; FeatureClass:\n    \"\"\"Build a FeatureClass object from a layer applying the layer's current selection to the stored cursors\n\n    Args:\n        layer (Layer): The layer to convert to a FeatureClass\n        ignore_selection (bool): Ignore the layer selection (default: False)\n        ignore_def_query (bool): Ignore the layer definition query (default: False)\n    Returns:\n        ( FeatureClass ): The FeatureClass object with the layer query applied\n    \"\"\"\n    fc = cls(layer.dataSource)\n\n    selected_ids: set[int] | None = (\n        layer.getSelectionSet() or None\n        if not ignore_selection \n        else None\n    )\n    definition_query: str|None = (\n        layer.definitionQuery or None\n        if not ignore_def_query \n        else None\n    )\n    selection: str|None = (\n        f\"{fc.oid_field_name} IN ({format_query_list(selected_ids)})\" \n        if selected_ids \n        else None\n    )\n\n    if (query_components := list(filter(None, [definition_query, selection]))):\n        where_clause = ' AND '.join(query_components)\n        fc.search_options = SearchOptions(where_clause=where_clause)\n        fc.update_options = UpdateOptions(where_clause=where_clause)\n\n    fc.layer = layer\n    return fc\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.get","title":"<code>get(field, default=None)</code>","text":"<pre><code>get(\n    field: tuple[FieldName, ...], default: _T\n) -&gt; Iterator[tuple[Any, ...]] | _T\n</code></pre><pre><code>get(\n    field: list[FieldName], default: _T\n) -&gt; Iterator[list[Any]] | _T\n</code></pre><pre><code>get(\n    field: set[FieldName], default: _T\n) -&gt; Iterator[_Schema] | _T\n</code></pre><pre><code>get(\n    field: Literal[\"SHAPE@\"], default: _T\n) -&gt; Iterator[_GeometryType] | _T\n</code></pre><pre><code>get(field: FieldName, default: _T) -&gt; Iterator[Any] | _T\n</code></pre><pre><code>get(\n    field: FilterFunc[_Schema], default: _T\n) -&gt; Iterator[_Schema] | _T\n</code></pre><pre><code>get(\n    field: WhereClause, default: _T\n) -&gt; Iterator[_Schema] | _T\n</code></pre><pre><code>get(field: None, default: _T) -&gt; Iterator[None] | _T\n</code></pre><pre><code>get(\n    field: GeometryType | Extent, default: _T\n) -&gt; Iterator[_Schema] | _T\n</code></pre> <p>Allows safe indexing of a FeatureClass, see <code>Table.get</code> for more information</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def get(self, field: Table._IndexableTypes | FilterFunc[_Schema] | Extent | GeometryType | Literal['SHAPE@'], default: _T=None) -&gt; Iterator[Any] | _T:\n    \"\"\"Allows safe indexing of a FeatureClass, see `Table.get` for more information\"\"\"\n    try:\n        return self[field]\n    except (KeyError, RuntimeError) as e:\n        if isinstance(e, RuntimeError) and 'Cannot find field' in str(e):\n            raise\n        return default\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.get_transformation","title":"<code>get_transformation(to_ref)</code>","text":"<p>Get the name of the transformation to convert from feature reference to provided reference</p> <p>Parameters:</p> Name Type Description Default <code>to_ref</code> <code>SpatialReference</code> <p>The spatial reference to get a transformation for</p> required <p>Returns:</p> Type Description <code>str | None</code> <p>The name of the first transformation or None if no transformation available</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def get_transformation(self, to_ref: SpatialReference) -&gt; str | None:\n    \"\"\"Get the name of the transformation to convert from feature reference to provided reference\n\n    Args:\n        to_ref (SpatialReference): The spatial reference to get a transformation for\n\n    Returns:\n        (str | None): The name of the first transformation or None if no transformation available\n    \"\"\"\n    trans = ListTransformations(self.spatial_reference, to_ref, first_only=True)\n    if not trans:\n        return None\n    return trans[0]\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.recalculate_extent","title":"<code>recalculate_extent()</code>","text":"<p>Recalculate the FeatureClass Extent</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def recalculate_extent(self) -&gt; None:\n    \"\"\"Recalculate the FeatureClass Extent\"\"\"\n    RecalculateFeatureClassExtent(self.path, 'STORE_EXTENT')\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.reference_as","title":"<code>reference_as(spatial_reference)</code>","text":"<p>Allows you to temporarily set a spatial reference on SearchCursor and UpdateCursor objects within a context block</p> <p>Parameters:</p> Name Type Description Default <code>spatial_reference</code> <code>SpatialReference</code> <p>The spatial reference to apply to the cursor objects</p> required <p>Yields:</p> Type Description <code>self</code> <p>Mutated self with search and update options set to use the provided spatial reference</p> Example <pre><code>&gt;&gt;&gt; sr = arcpy.SpatialReference(26971)\n&gt;&gt;&gt; fc = FeatureClass[Polygon]('&lt;fc_path&gt;')\n\n&gt;&gt;&gt; orig_shapes = list(fc.shapes)\n\n&gt;&gt;&gt; with fc.project_as(sr):\n...     proj_shapes = list(fc.shapes)\n\n&gt;&gt;&gt; print(orig_shapes[0].spatialReference)\nSpatialReference(4326)\n\n&gt;&gt;&gt; print(proj_shapes[0].spatialReference)\nSpatialReference(26971)\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef reference_as(self, spatial_reference: SpatialReference):\n    \"\"\"Allows you to temporarily set a spatial reference on SearchCursor and UpdateCursor objects within a context block\n\n    Args:\n        spatial_reference (SpatialReference): The spatial reference to apply to the cursor objects\n\n    Yields:\n        (self): Mutated self with search and update options set to use the provided spatial reference\n\n    Example:\n        ```python\n        &gt;&gt;&gt; sr = arcpy.SpatialReference(26971)\n        &gt;&gt;&gt; fc = FeatureClass[Polygon]('&lt;fc_path&gt;')\n\n        &gt;&gt;&gt; orig_shapes = list(fc.shapes)\n\n        &gt;&gt;&gt; with fc.project_as(sr):\n        ...     proj_shapes = list(fc.shapes)\n\n        &gt;&gt;&gt; print(orig_shapes[0].spatialReference)\n        SpatialReference(4326)\n\n        &gt;&gt;&gt; print(proj_shapes[0].spatialReference)\n        SpatialReference(26971)\n        ```\n    \"\"\"\n    with self.options(\n        search_options=SearchOptions(spatial_reference=spatial_reference), \n        update_options=UpdateOptions(spatial_reference=spatial_reference)):\n        yield self\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.FeatureClass.spatial_filter","title":"<code>spatial_filter(spatial_filter, spatial_relationship='INTERSECTS')</code>","text":"<p>Apply a spatial filter to the FeatureClass in a context</p> <p>Parameters:</p> Name Type Description Default <code>spatial_filter</code> <code>Geometry | Extent</code> <p>The geometry to use as a spatial filter</p> required <code>spatial_relationship</code> <code>SpatialRelationship</code> <p>The relationship to check for (default: <code>INTERSECTS</code>)</p> <code>'INTERSECTS'</code> Example <pre><code>&gt;&gt;&gt; with fc.spatial_filter(boundary) as f:\n...     print(len(fc))\n100\n&gt;&gt;&gt; print(len(fc))\n50000\n</code></pre> Note <p>Same as with <code>where</code>, this method will be much faster than any manual <code>filter</code> you can apply using python.  If you need to filter a FeatureClass by a spatial relationship, use this method, then do your expensive  <code>filter</code> operation on the reduced dataset</p> <pre><code>&gt;&gt;&gt; def expensive_filter(rec):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt; with fc.spatial_filter(boundary) as local:\n&gt;&gt;&gt;     for row in fc.filter(expensive_filter):\n&gt;&gt;&gt;         ...\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef spatial_filter(self, spatial_filter: GeometryType | Extent, spatial_relationship: SpatialRelationship='INTERSECTS'):\n    \"\"\"Apply a spatial filter to the FeatureClass in a context\n\n    Args:\n        spatial_filter (Geometry | Extent): The geometry to use as a spatial filter\n        spatial_relationship (SpatialRelationship): The relationship to check for (default: `INTERSECTS`)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; with fc.spatial_filter(boundary) as f:\n        ...     print(len(fc))\n        100\n        &gt;&gt;&gt; print(len(fc))\n        50000\n        ```\n\n    Note:\n        Same as with `where`, this method will be much faster than any manual `filter` you can apply using python. \n        If you need to filter a FeatureClass by a spatial relationship, use this method, then do your expensive \n        `filter` operation on the reduced dataset\n\n        ```python\n        &gt;&gt;&gt; def expensive_filter(rec):\n        &gt;&gt;&gt;     ...\n        &gt;&gt;&gt; with fc.spatial_filter(boundary) as local:\n        &gt;&gt;&gt;     for row in fc.filter(expensive_filter):\n        &gt;&gt;&gt;         ...\n        ```\n    \"\"\"\n    with self.options(\n        search_options=SearchOptions(\n            spatial_filter=spatial_filter, \n            spatial_relationship=spatial_relationship)):\n        yield self\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table","title":"<code>Table</code>","text":"<p>               Bases: <code>Generic[_Schema]</code></p> <p>A Wrapper for ArcGIS Table objects</p> <p>Methods:</p> Name Description <code>__bool__</code> <code>__contains__</code> <p>Implementation of contains that checks for a field existing in the <code>FeatureClass</code></p> <code>__delitem__</code> <code>__eq__</code> <p>Determine if the datasource of two featureclass objects is the same</p> <code>__format__</code> <p>Implement format specs for string formatting a featureclass.</p> <code>__fspath__</code> <code>__getitem__</code> <p>Handle all defined overloads using pattern matching syntax</p> <code>__hash__</code> <code>__init__</code> <code>__iter__</code> <p>Iterate all rows in the Table or FeatureClass yielding mappings of field name to field value</p> <code>__len__</code> <p>Iterate all rows and count them. Only count with <code>self.search_options</code> queries.</p> <code>__repr__</code> <p>Provide a constructor string e.g. <code>Table or FeatureClass[Polygon]('path')</code></p> <code>__setitem__</code> <code>__str__</code> <p>Return the <code>Table</code> or <code>FeatureClass</code> path for use with other arcpy methods</p> <code>add_field</code> <p>Add a new field to a Table or FeatureClass, if no type is provided, deafault of <code>VARCHAR(255)</code> is used</p> <code>add_fields</code> <p>Provide a mapping of fieldnames to Fields</p> <code>add_to_map</code> <p>Add the featureclass to a map</p> <code>as_dict</code> <code>bind_to_layer</code> <p>Update the provided layer's datasource to this Table or FeatureClass</p> <code>clear</code> <p>Clear all records from the table</p> <code>copy</code> <p>Create a new FeatureClass instance to prevent overriding a shared resource</p> <code>copy_to</code> <p>Copy this <code>Table</code> or <code>FeatureClass</code> to a new workspace</p> <code>delete_field</code> <p>Delete a field from a Table or FeatureClass</p> <code>delete_fields</code> <code>delete_identical</code> <p>Delete all records that have matching field values</p> <code>delete_where</code> <p>Delete all records that match the provided where clause</p> <code>distinct</code> <p>Yield rows of distinct values</p> <code>exists</code> <p>Check if the Table or FeatureClass actually exists (check for deletion or initialization with bad path)</p> <code>fields_as</code> <p>Override the default fields for the Table or FeatureClass so all non-explicit Iterators will</p> <code>filter</code> <p>Apply a function filter to rows in the Table or FeatureClass</p> <code>from_layer</code> <p>Build a Table or FeatureClass object from a layer applying the layer's current selection to the stored cursors</p> <code>from_table</code> <p>See <code>from_layer</code> for documentation, this is an alternative constructor that builds from a mp.Table object</p> <code>get</code> <p>Allow accessing the implemented indexes defined by <code>__getitem__</code> with a default shielding a raised <code>KeyError</code></p> <code>get_records</code> <p>Generate row dicts with in the form <code>{field: value, ...}</code> for each row in the cursor</p> <code>get_tuples</code> <p>Generate tuple rows in the for (val1, val2, ...) for each row in the cursor</p> <code>group_by</code> <p>Group features by matching field values and yield full records in groups</p> <code>has_field</code> <p>Check if the field exists in the featureclass or is a valid Token (@[TOKEN])</p> <code>insert_cursor</code> <p>See <code>Table.search_cursor</code> doc for general info. Operation of this method is identical but returns an <code>InsertCursor</code></p> <code>insert_record</code> <p>Insert a single record into the table</p> <code>insert_records</code> <p>Provide an iterable of records to insert</p> <code>options</code> <p>Enter a context block where the supplied options replace the stored options for the <code>Table</code> or <code>FeatureClass</code></p> <code>row_updater</code> <p>A Bi-Directional generator that yields rows and updates them with the sent value</p> <code>search_cursor</code> <p>Get a <code>SearchCursor</code> for the <code>Table</code> or <code>FeatureClass</code></p> <code>select</code> <p>If the Table or FeatureClass is bound to a layer, update the layer selection with the active SearchOptions</p> <code>unselect</code> <p>If the Table or FeatureClass is bound to a layer, Remove layer selection</p> <code>update_cursor</code> <p>See <code>Table.search_cursor</code> doc for general info. Operation of this method is identical but returns an <code>UpdateCursor</code></p> <code>updater</code> <p>A wrapper around <code>row_updater</code> that allows use as a context manager</p> <code>where</code> <p>Apply a where clause to a Table or FeatureClass in a context</p> <p>Attributes:</p> Name Type Description <code>GroupIdent</code> <code>GroupIter</code> <code>Tokens</code> <code>attribute_rules</code> <code>AttributeRuleManager</code> <p>Get an <code>AttributeRuleManager</code> object bound to the Table/FeatureClass</p> <code>clause</code> <code>SQLClause</code> <p>Default SQLClause</p> <code>da_describe</code> <code>dict[str, Any]</code> <p>Access the da.Describe dictionary for the <code>Table</code> or <code>FeatureClass</code></p> <code>describe</code> <code>Table</code> <p>Access the arcpy.Describe object for the <code>Table</code> or <code>FeatureClass</code></p> <code>editor</code> <code>Editor</code> <p>Get an Editor manager for the Table or FeatureClass</p> <code>fields</code> <code>tuple[TableToken | str, ...]</code> <p>Tuple of all fieldnames in the Table or FeatureClass with <code>OID@</code> as first</p> <code>insert_options</code> <code>InsertOptions</code> <p>Default InsertCursor options</p> <code>layer</code> <code>Layer | None</code> <p>A Layer object for the FeatureClass/Table if one is bound</p> <code>name</code> <code>str</code> <p>The common name of the FeatureClass/Table</p> <code>np_dtypes</code> <p>Numpy dtypes for each field</p> <code>oid_field_name</code> <code>str</code> <p>ObjectID fieldname (ususally FID or OID or ObjectID)</p> <code>path</code> <code>str</code> <p>The filepath of the FeatureClass/Table</p> <code>py_types</code> <code>dict[str, type]</code> <p>Get a mapping of fieldnames to python types for the Table</p> <code>search_options</code> <code>SearchOptions</code> <p>Default SearchCursor options</p> <code>subtype_field</code> <code>str | None</code> <p>The Subtype field (ususally SUBTYPE or SUBTYPE_CODE, etc.)</p> <code>subtypes</code> <code>dict[int, Subtype]</code> <p>Result of ListSubtypes, mapping of code to Subtype object</p> <code>update_options</code> <code>UpdateOptions</code> <p>Default UpdateCursor options</p> <code>workspace</code> <code>str</code> <p>Get the workspace of the <code>Table</code> or <code>FeatureClass</code></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>class Table(Generic[_Schema]):\n    \"\"\"A Wrapper for ArcGIS Table objects\"\"\"\n\n    Tokens = TableTokens\n\n    def __init__(\n            self, path: str|Path,\n            *,\n            search_options: SearchOptions|None=None, \n            update_options: UpdateOptions|None=None, \n            insert_options: InsertOptions|None=None,\n            clause: SQLClause|None=None,\n            where: str|None=None,\n        ) -&gt; None:\n        self._path = str(path)\n        self._clause = clause or SQLClause(None, None)\n        self._search_options = search_options or SearchOptions()\n        self._insert_options = insert_options or InsertOptions()\n        self._update_options = update_options or UpdateOptions()\n\n        # Override\n        if where:\n            self._search_options['where_clause'] = where\n            self._update_options['where_clause'] = where\n\n        self._layer: Layer|None=None\n        self._in_edit_session=False\n        self._fields: tuple[TableToken | str, ...]|None=None\n\n    # rw Properties\n\n    @property\n    def search_options(self) -&gt; SearchOptions:\n        \"\"\"Default SearchCursor options\"\"\"\n        return self._search_options.copy()\n\n    @search_options.setter\n    def search_options(self, search_options: SearchOptions) -&gt; None:\n        \"\"\"Default SearchCursor options setter\"\"\"\n        self._search_options = search_options or SearchOptions()\n\n    @property\n    def insert_options(self) -&gt; InsertOptions:\n        \"\"\"Default InsertCursor options\"\"\"\n        return self._insert_options.copy()\n\n    @insert_options.setter\n    def insert_options(self, insert_options: InsertOptions) -&gt; None:\n        \"\"\"Default InsertCursor options setter\"\"\"\n        self._insert_options = insert_options or InsertOptions()\n\n    @property\n    def update_options(self) -&gt; UpdateOptions:\n        \"\"\"Default UpdateCursor options\"\"\"\n        return self._update_options.copy() # pyright: ignore[reportReturnType]\n\n    @update_options.setter\n    def update_options(self, update_options: UpdateOptions) -&gt; None:\n        \"\"\"Default UpdateCursor options setter\"\"\"\n        self._update_options = update_options or UpdateOptions()\n\n    @property\n    def clause(self) -&gt; SQLClause:\n        \"\"\"Default SQLClause\"\"\"\n        return self._clause\n\n    @clause.setter\n    def clause(self, clause: SQLClause) -&gt; None:\n        \"\"\"Set a feature level SQL clause on all Insert and Search operations\n\n        This clause is overridden by all Option level clauses\n        \"\"\"\n        self._clause = clause\n\n    @property\n    def layer(self) -&gt; Layer|None:\n        \"\"\"A Layer object for the FeatureClass/Table if one is bound\"\"\"\n        return self._layer\n\n    @layer.setter\n    def layer(self, layer: Layer) -&gt; None:\n        \"\"\"Set a layer object for the Table or FeatureClass, layer datasource must be this FeatureClass!\"\"\"\n        if layer.dataSource != self.path:\n            raise ValueError(f'Layer: {layer.name} does not source to {self.name} Table or FeatureClass at {self.path}!')\n        self._layer = layer\n\n    # ro Properties\n\n    @property\n    def path(self) -&gt; str:\n        \"\"\"The filepath of the FeatureClass/Table\"\"\"\n        return self._path\n\n    @property\n    def describe(self) -&gt; dt.Table:\n        \"\"\"Access the arcpy.Describe object for the `Table` or `FeatureClass`\"\"\"\n        return Describe(self.path) #type:ignore (Will be dt.Table or FeatureClass)\n\n    @property\n    def da_describe(self) -&gt; dict[str, Any]:\n        \"\"\"Access the da.Describe dictionary for the `Table` or `FeatureClass`\"\"\"\n        return Describe_da(self.path)\n\n    @property\n    def workspace(self) -&gt; str:\n        \"\"\"Get the workspace of the `Table` or `FeatureClass`\"\"\"\n        return self.describe.workspace.catalogPath\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"The common name of the FeatureClass/Table\"\"\"\n        return self.describe.name\n\n    @property\n    def oid_field_name(self) -&gt; str:\n        \"\"\"ObjectID fieldname (ususally FID or OID or ObjectID)\"\"\"\n        return self.describe.OIDFieldName\n\n    @property\n    def subtype_field(self) -&gt; str | None:\n        \"\"\"The Subtype field (ususally SUBTYPE or SUBTYPE_CODE, etc.)\"\"\"\n        if not self.subtypes:\n            return None\n        return list(self.subtypes.values()).pop()['SubtypeField']\n\n    @property\n    def fields(self) -&gt; tuple[TableToken | str, ...]:\n        \"\"\"Tuple of all fieldnames in the Table or FeatureClass with `OID@` as first\"\"\"\n        if not self._fields:\n            exclude = (self.oid_field_name)\n            replace = ('OID@',)\n            _fields = ()\n            with self.search_cursor('*') as c:\n                _fields = c.fields\n            self._fields = replace + tuple((f for f in _fields if f not in exclude))\n        return self._fields\n\n    @property\n    def np_dtypes(self):\n        \"\"\"Numpy dtypes for each field\"\"\"\n        return self.search_cursor(*self.fields)._dtype # pyright: ignore[reportPrivateUsage]\n\n    @property\n    def py_types(self) -&gt; dict[str, type]:\n        \"\"\"Get a mapping of fieldnames to python types for the Table\"\"\"\n        return convert_dtypes(self.np_dtypes)\n\n    @property\n    def subtypes(self) -&gt; dict[int, Subtype]:\n        \"\"\"Result of ListSubtypes, mapping of code to Subtype object\"\"\"\n        return ListSubtypes(self.path) # type:ignore\n\n    @property\n    def editor(self) -&gt; Editor:\n        \"\"\"Get an Editor manager for the Table or FeatureClass\n        Will set multiuser_mode to True if the feature can version\n        \"\"\"\n        return Editor(self.workspace, multiuser_mode=self.describe.canVersion)\n\n    @property\n    def attribute_rules(self) -&gt; AttributeRuleManager:\n        \"\"\"Get an `AttributeRuleManager` object bound to the Table/FeatureClass\"\"\"\n        return AttributeRuleManager(self)\n\n    # Option Resolvers (kwargs -&gt; Options Object -&gt; Table or FeatureClass Options)\n\n    def _resolve_search_options(self, options: SearchOptions|None, overrides: SearchOptions) -&gt; SearchOptions:\n        \"\"\"Combine all provided SearchOptions into one dictionary\"\"\"\n        return {\n            'sql_clause': self.clause or SQLClause(None, None), \n            **self.search_options, \n            **(options or {}), \n            **overrides\n        }\n\n    def _resolve_insert_options(self, options: InsertOptions|None, overrides: InsertOptions) -&gt; InsertOptions:\n        \"\"\"Combine all provided InsertOptions into one dictionary\"\"\"\n        return {**self.insert_options, **(options or {}), **overrides}\n\n    def _resolve_update_options(self, options: UpdateOptions|None, overrides: UpdateOptions) -&gt; UpdateOptions:\n        \"\"\"Combine all provided UpdateOptions into one dictionary\"\"\"\n        return {\n            'sql_clause': self.clause or SQLClause(None, None), \n            **self.update_options, \n            **(options or {}), \n            **overrides\n        }\n\n    # Cursor Handlers\n\n    def search_cursor(self, *field_names: FieldName,\n                      search_options: SearchOptions|None=None, \n                      **overrides: Unpack[SearchOptions]) -&gt; SearchCursor:\n        \"\"\"Get a `SearchCursor` for the `Table` or `FeatureClass`\n        Supplied search options are resolved by updating the base `Table` or `FeatureClass` Search options in this order:\n\n        `**overrides['kwarg'] -&gt; search_options['kwarg'] -&gt; self.search_options['kwarg']`\n\n        This is implemented using unpacking operations with the lowest importance option set being unpacked first\n\n        `{**self.search_options, **(search_options or {}), **overrides}`\n\n        With direct key word arguments (`**overrides`) shadowing all other supplied options. This allows a FeatureClass to\n        be initialized using a base set of options, then a shared SearchOptions set to be applied in some contexts,\n        then a direct keyword override to be supplied while never mutating the base options of the FeatureClass.\n\n        Args:\n            field_names (str | Iterable[str]): The column names to include from the `Table` or `FeatureClass`\n            search_options (SearchOptions|None): A `SeachOptions` instance that will be used to shadow\n                `search_options` set on the `Table` or `FeatureClass`\n            **overrides ( Unpack[SeachOptions] ): Additional keyword arguments for the cursor that shadow \n                both the `seach_options` variable and the `Table` or `FeatureClass` instance `SearchOptions`\n\n        Returns:\n            ( SearchCursor ): A `SearchCursor` for the `Table` or `FeatureClass` instance that has all supplied options\n                resolved and applied\n\n        Example:\n            ```python\n                &gt;&gt;&gt; cleese_search = SearchOptions(where_clause=\"NAME = 'John Cleese'\")\n                &gt;&gt;&gt; idle_search = SearchOptions(where_clause=\"NAME = 'Eric Idle'\")\n                &gt;&gt;&gt; monty = Table or FeatureClass('&lt;path&gt;', search_options=cleese_search)\n                &gt;&gt;&gt; print(list(monty.search_cursor('NAME')))\n                [('John Cleese',)]\n                &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)))\n                [('Eric Idle', )]\n                &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)), where_clause=\"NAME = Graham Chapman\")\n                [('Graham Chapman', )]\n            ```\n        In this example, you can see that the keyword override is the most important. The fact that the other searches are\n        created outside initialization allows you to store common queries in one place and update them for all cursors using \n        them at the same time, while still allowing specific instances of a cursor to override those shared/stored defaults.\n        \"\"\"\n        return SearchCursor(self.path, field_names, **self._resolve_search_options(search_options, overrides))\n\n    def insert_cursor(self, *field_names: FieldName,\n                      insert_options: InsertOptions|None=None, \n                      **overrides: Unpack[InsertOptions]) -&gt; InsertCursor:\n        \"\"\"See `Table.search_cursor` doc for general info. Operation of this method is identical but returns an `InsertCursor`\"\"\"\n        if 'datum_transformation' in overrides and overrides['datum_transformation'] is None:\n            overrides.pop('datum_transformation')\n        if insert_options and 'datum_transformation' in insert_options and insert_options['datum_transformation'] is None:\n            insert_options.pop('datum_transformation')\n        return InsertCursor(self.path, field_names, **self._resolve_insert_options(insert_options, overrides))\n\n    def update_cursor(self, *field_names: FieldName,\n                    update_options: UpdateOptions|None=None, \n                    **overrides: Unpack[UpdateOptions]) -&gt; UpdateCursor:\n        \"\"\"See `Table.search_cursor` doc for general info. Operation of this method is identical but returns an `UpdateCursor`\"\"\"\n        if 'datum_transformation' in overrides and overrides['datum_transformation'] is None:\n            overrides.pop('datum_transformation')\n        if update_options and 'datum_transformation' in update_options and update_options['datum_transformation'] is None:\n            update_options.pop('datum_transformation')\n        return UpdateCursor(self.path, field_names, **self._resolve_update_options(update_options, overrides))\n\n    # TODO, Fix this\n    def row_updater(self, *field_names: FieldName,\n                    strict: bool=False,\n                    update_options: UpdateOptions|None=None, \n                    **overrides: Unpack[UpdateOptions]) -&gt; Generator[_Schema, _Schema|None, None]:\n        \"\"\"A Bi-Directional generator that yields rows and updates them with the sent value\n\n        Note:\n            This method will assume the full provided schema if there is one, so make sure you keep track of\n            any applied field filters.\n\n        Args:\n            field_names (FieldName|str): The fields to include in the update operation (default: All)\n            strict (bool): Raise a KeyError if an invalid fieldname is passed, otherwise drop invalid updates (default: False)\n            update_options (UpdateOptions): Additional context to pass to the UpdateCursor as a dictionary\n            **overrides (UpdateOptions): Additional context to pass to the UpdateCursor as keyword arguments\n\n        Example:\n            ```python\n            &gt;&gt;&gt; updater = fc.row_updater()\n            &gt;&gt;&gt; for row in updater:\n            ...     if row['Name'] = 'No Name':\n            ...         row['Name'] = None\n            ...         updater.send(row)\n            ```\n        \"\"\"\n        with self.update_cursor(*(field_names or self.fields), update_options=update_options, **overrides) as cur:\n            for row in self.as_dict(cur):\n                upd = yield row\n                if strict and (invalid := set(upd or []) - set(row)):\n                    raise KeyError(f'{invalid} fields not found in {self.name}')\n                if upd is not None:\n                    cur.updateRow([upd.get(f, row[f]) for f in cur.fields])\n\n    @contextmanager\n    def updater(self, *fields: FieldName, strict: bool=False):\n        \"\"\"A wrapper around `row_updater` that allows use as a context manager\n\n        This simplifies the interaction with the `row_updater` method by allowing inline declaration\n        of the generator. For most simple update operations, this manager should work well. \n\n        Args:\n            fields (FieldName|str): The fields to include in the update operation (default: All)\n            stict (bool): Raise a KeyError if an invalid fieldname is passed, otherwise drop invalid updates (default: False)\n\n        Example:\n            &gt;&gt;&gt; with fc.editor, fc.updater() as upd:\n            ...     for row in upd:\n            ...         row['Name'] = 'Dave'\n            ...         upd.send(row)\n        \"\"\"\n        try:\n            yield self.row_updater(*(fields or self.fields), strict=strict)\n        finally:\n            pass\n\n    # Localize as_dict for internal typing of _Schema var\n    def as_dict(self, cursor: SearchCursor | UpdateCursor) -&gt; Iterator[_Schema]:\n        yield from as_dict(cursor) # pyright: ignore[reportReturnType]\n\n    if TYPE_CHECKING:\n        GroupIter = Iterator[tuple[Any, ...] | Any]\n        GroupIdent = tuple[Any, ...] | Any\n    def group_by(self, group_fields: Sequence[FieldName] | FieldName, return_fields: Sequence[FieldName] | FieldName ='*') -&gt; Iterator[tuple[GroupIdent, GroupIter]]:\n        \"\"\"Group features by matching field values and yield full records in groups\n\n        Args:\n            group_fields (FieldOpt): The fields to group the data by\n            return_fields (FieldOpt): The fields to include in the output record (`'*'` means all and is default)\n        Yields:\n            ( Iterator[tuple[tuple[FieldName, ...], Iterator[tuple[Any, ...] | Any]]] ): A nested iterator of groups and then rows\n\n        Example:\n            ```python\n            &gt;&gt;&gt; # With a field group, you will be able to unpack the tuple\n            &gt;&gt;&gt; for group, rows in fc.group_by(['GroupField1', 'GroupField2'], ['ValueField1', 'ValueField2', ...]):\n            ...     print(group)\n            ...     for v1, v2 in rows:\n            ...        if v1 &gt; 10:\n            ...            print(v2)\n            (GroupValue1A, GroupValue1B)\n            valueA\n            valueB\n            ...\n            &gt;&gt;&gt; # With a single field, you will have direct access to the field values   \n            &gt;&gt;&gt; for group, district_populations in fc.group_by(['City', 'State'], 'Population'):\n            &gt;&gt;&gt;         print(f\"{group}: {sum(district_populations)}\")\n            (New York, NY): 8260000\n            (Boston, MA): 4941632\n            ...\n            ```\n        \"\"\"\n\n        # Parameter Validations\n        if isinstance(group_fields, str):\n            group_fields = (group_fields,)\n        if return_fields == '*':\n            return_fields = self.fields\n        if isinstance(return_fields, str):\n            return_fields = (return_fields,)\n        if len(group_fields) &lt; 1 or len(return_fields) &lt; 1:\n            raise ValueError(\"Group Fields and Return Fields must be populated\")\n\n        group_fields = list(group_fields)\n        return_fields = list(return_fields)\n        _all_fields = group_fields + return_fields\n        for group in self.distinct(group_fields):\n            group_key = {field : value for field, value in zip(group_fields, group)}\n            where_clause = \" AND \".join(f\"{field} = {norm(value)}\" for field, value in group_key.items())\n            if '@' not in where_clause: # Handle valid clause (no tokens)\n                with self.search_cursor(*return_fields, where_clause=where_clause) as group_cur:\n                    yield (extract_singleton(group), (extract_singleton(row) for row in group_cur))\n            else: # Handle token being passed by iterating a cursor and checking values directly\n                for row in filter(lambda row: all(row[k] == group_key[k] for k in group_key), self[set(_all_fields)]):\n                    yield (extract_singleton(group), (row.pop(k) for k in return_fields)) # type: ignore (TypedDict Generic causes issues)\n\n    def distinct(self, distinct_fields: Iterable[FieldName] | FieldName) -&gt; Iterator[tuple[Any, ...]]:\n        \"\"\"Yield rows of distinct values\n\n        Args:\n            distinct_fields (FieldOpt): The field or fields to find distinct values for.\n                Choosing multiple fields will find all distinct instances of those field combinations\n\n        Yields:\n            ( tuple[Any, ...] ): A tuple containing the distinct values (single fields will yield `(value, )` tuples)\n        \"\"\"\n        clause = SQLClause(prefix=f'DISTINCT {format_query_list(distinct_fields)}', postfix=None)\n        try:\n            yield from (value for value in self.search_cursor(*distinct_fields, sql_clause=clause))\n        except RuntimeError: # Fallback when DISTINCT is not available or fails with Token input\n            yield from sorted(set(self.get_tuples(distinct_fields)))\n\n    def get_records(self, field_names: Iterable[FieldName] | FieldName, **options: Unpack[SearchOptions]) -&gt; Iterator[_Schema]:\n        \"\"\"Generate row dicts with in the form `{field: value, ...}` for each row in the cursor\n\n        Args:\n            field_names (str | Iterable[str]): The columns to iterate\n            **options (Unpack[SearchOptions]): Additional options to pass on to the cursor\n        Yields \n            ( dict[str, Any] ): A mapping of fieldnames to field values for each row\n        \"\"\"\n        with self.search_cursor(*field_names, **options) as cur:\n            yield from self.as_dict(cur)\n\n    def get_tuples(self, field_names: Iterable[FieldName] | FieldName, **options: Unpack[SearchOptions]) -&gt; Iterator[tuple[Any, ...]]:\n        \"\"\"Generate tuple rows in the for (val1, val2, ...) for each row in the cursor\n\n        Args:\n            field_names (str | Iterable[str]): The columns to iterate\n            **options (SearchOptions): Additional parameters to pass to the SearchCursor\n        \"\"\"\n        with self.search_cursor(*field_names, **options) as cur:\n            yield from cur\n\n    def insert_record(self, record: _Schema, ignore_errors: bool=False) -&gt; int | None:\n        \"\"\"Insert a single record into the table\"\"\"\n        if missing_fields := set(record.keys()).difference(self.fields):\n            if ignore_errors:\n                return None\n            else:\n                raise ValueError(f'{missing_fields} not in {self.fields}')\n        with self.insert_cursor(*record.keys()) as cur:\n            return cur.insertRow(list(record.values()))\n\n    def insert_records(self, records: Iterable[_Schema] , ignore_errors: bool=False) -&gt; Iterator[int]:\n        \"\"\"Provide an iterable of records to insert\n        Args:\n            records (Iterable[RowRecord]): The sequence of records to insert\n            ignore_errors (bool): Ignore per-row errors and continue. Otherwise raise KeyError (default: True)\n\n        Returns:\n            ( Iterator[int] ): Returns the OIDs of the newly inserted rows\n\n        Raises:\n            ( KeyError ): If the records have varying keys or the keys are not in the Table or FeatureClass\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_rows = [\n            ...    {'first': 'John', 'last': 'Cleese', 'year': 1939}, \n            ...    {'first': 'Michael', 'last': 'Palin', 'year': 1943}\n            ... ]\n            &gt;&gt;&gt; print(fc.insert_rows(new_rows))\n            (2,3)\n\n            &gt;&gt;&gt; # Insert all shapes from fc into fc2\n            &gt;&gt;&gt; fc2.insert_rows(fc.get_records(['first', 'last', 'year']))\n            (1,2)\n            ```\n        \"\"\"\n        yield from filter(None, (self.insert_record(record, ignore_errors=ignore_errors) for record in records))\n\n    def delete_identical(self, field_names: Iterable[FieldName] | FieldName) -&gt; dict[int, int]:\n        \"\"\"Delete all records that have matching field values\n\n        Args:\n            field_names (Sequence[FieldName] | FieldName): The fields used to define an identical feature\n\n        Returns:\n            (dict[int, int]): A dictionary of count of identical features deleted per feature\n\n        Note:\n            Insertion order takes precidence unless the Table or FeatureClass is ordered. The first feature found\n            by the cursor will be maintained and all subsequent matches will be removed\n        \"\"\"\n        # All\n        if isinstance(field_names, str):\n            field_names = [field_names]\n\n        unique: dict[int, tuple[Any]] = {}\n        deleted: dict[int, int] = {}\n        with self.update_cursor('OID@', *field_names) as cur:\n            for row in cur:\n                oid: int = row[0]\n                row = tuple(row[1:])\n                for match_id, match_row in unique.items():\n                    if all(a == b for a, b in zip(row, match_row)):\n                        match = match_id\n                        break\n                else:\n                    match = False\n\n                if not match:\n                    unique[oid] = row\n\n                else:\n                    deleted.setdefault(match, 0)\n                    deleted[match] += 1\n                    cur.deleteRow()\n        return deleted\n\n    def filter(self, func: FilterFunc[_Schema], invert: bool=False) -&gt; Iterator[_Schema]:\n        \"\"\"Apply a function filter to rows in the Table or FeatureClass\n\n        Args:\n            func (Callable[[dict[str, Any]], bool]): A callable that takes a \n                row dictionary and returns True or False\n            invert (bool): Invert the function. Only yield rows that return `False`\n\n        Yields:\n            ( dict[str, Any] ): Rows in the Table or FeatureClass that match the filter (or inverted filter)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; def area_filter(row: dict) -&gt; bool:\n            &gt;&gt;&gt;     return row['Area'] &gt;= 10\n\n            &gt;&gt;&gt; for row in fc:\n            &gt;&gt;&gt;     print(row['Area'])\n            1\n            2\n            10\n            &lt;etc&gt;\n\n            &gt;&gt;&gt; for row in fc.filter(area_filter):\n            &gt;&gt;&gt;     print(row['Area'])\n            10\n            11\n            90\n            &lt;etc&gt;\n            ```\n\n        \"\"\"\n        if hasattr(func, 'fields'): # Allow decorated filters for faster iteration (see `filter_fields`)\n            with self.fields_as(*getattr(func, 'fields')):\n                yield from (row for row in self if func(row) == (not invert))\n        else:\n            yield from (row for row in self if func(row) == (not invert))\n\n    # Data Operations\n\n    def copy_to(self, workspace: str, options: bool=True) -&gt; Self:\n        \"\"\"Copy this `Table` or `FeatureClass` to a new workspace\n\n        Args:\n            workspace (str): The path to the workspace\n            options (bool): Copy the cursor options to the new `Table` or `FeatureClass` (default: `True`)\n\n        Returns:\n            (Table or FeatureClass): A `Table` or `FeatureClass` instance of the copied features\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_fc = fc.copy('workspace2')\n            &gt;&gt;&gt; new_fc == fc\n            False\n            ```\n        \"\"\"\n        #name = Path(self.path).relative_to(Path(self.workspace))\n        if Exists(copy_fc := Path(workspace) / self.name):\n            raise ValueError(f'{self.name} already exists in {workspace}!')\n        CopyFeatures(self.path, str(copy_fc))\n        fc = self.__class__(str(copy_fc))\n        if options:\n            fc.search_options = self.search_options\n            fc.update_options = self.update_options\n            fc.insert_options = self.insert_options\n            fc.clause = self.clause\n        return fc\n\n    def exists(self) -&gt; bool:\n        \"\"\"Check if the Table or FeatureClass actually exists (check for deletion or initialization with bad path)\"\"\"\n        return Exists(str(self))\n\n    def has_field(self, fieldname: str) -&gt; bool:\n        \"\"\"Check if the field exists in the featureclass or is a valid Token (@[TOKEN])\"\"\"\n        return fieldname in self.fields or fieldname in self.Tokens\n\n    def add_field(self, fieldname: str, field: Field|None=None, **options: Unpack[Field]) -&gt; None:\n        \"\"\"Add a new field to a Table or FeatureClass, if no type is provided, deafault of `VARCHAR(255)` is used\n\n        Args:\n            fieldname (str): The name of the new field (must not start with a number and be alphanum or underscored)\n            field (Field): A Field object that contains the desired field properties\n            **options (**Field): Allow passing keyword arguments for field directly (Overrides field arg)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; new_field = Field(\n            ...     field_alias='Abbreviated Month',\n            ...     field_type='TEXT',\n            ...     field_length='3',\n            ...     field_domain='Months_ABBR',\n            ... )\n\n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name', 'year']\n\n            &gt;&gt;&gt; fc['month'] = new_field\n            &gt;&gt;&gt; fc2['month'] = new_field # Can re-use a field definition \n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name', 'year', 'month']\n            ```\n        \"\"\"\n        if self.has_field(fieldname):\n            raise ValueError(f'{self.name} already has a field called {fieldname}!')\n\n        # Use provided field or default to 'TEXT' and override with kwargs\n        field = {**(field or Field(field_type='TEXT')), **options}\n\n        # Handle malformed Field arg\n        field['field_type'] = field.get('field_type', 'TEXT')\n\n        _option_kwargs = set(Field.__optional_keys__) | set(Field.__required_keys__)\n        _provided = set(field.keys())\n\n        if not _provided &lt;= _option_kwargs:\n            raise ValueError(f\"Unknown Field properties provided: {_provided - _option_kwargs}\")\n\n        if not valid_field(fieldname):\n            raise ValueError(\n                f\"{fieldname} is invalid, fieldnames must not start with a number \"\n                \"and must only contain alphanumeric characters and underscores\"\n            )\n\n        with EnvManager(workspace=self.workspace):\n            AddField(self.path, fieldname, **field)\n            self._fields = None\n\n    def add_fields(self, fields: dict[str, Field]) -&gt; None:\n        \"\"\"Provide a mapping of fieldnames to Fields\n\n        Args:\n            fields (dict[str, Field]): A mapping of fieldnames to Field objects\n\n        Example:\n            ```python\n            &gt;&gt;&gt; fields = {'f1': Field(...), 'f2': Field(...)}\n            &gt;&gt;&gt; fc.add_fields(fields)\n            &gt;&gt;&gt; fc.fields\n            ['OID@', 'SHAPE@', 'f1', 'f2']\n            ```\n        \"\"\"\n        for fieldname, field in fields.items():\n            self.add_field(fieldname, field)\n\n    def delete_field(self, fieldname: str) -&gt; None:\n        \"\"\"Delete a field from a Table or FeatureClass\n\n        Args:\n            fieldname (str): The name of the field to delete/drop\n\n        Example:\n            ```python\n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name', 'year', 'month']\n\n            &gt;&gt;&gt; del fc['month']\n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name', 'year']\n            &gt;&gt;&gt; fc.delete_field('year')\n            &gt;&gt;&gt; print(fc.fields)\n            ['OID@', 'SHAPE@', 'name']\n            ```\n        \"\"\"\n        if fieldname in self.Tokens:\n            raise ValueError(f\"{fieldname} is a Token and cannot be deleted!\")\n        if not self.has_field(fieldname):\n            raise ValueError(f\"{fieldname} does not exist in {self.name}\")\n        with EnvManager(workspace=self.workspace):\n            DeleteField(self.path, fieldname)\n            self._fields = None # Defer new field check to next access\n\n    def delete_fields(self, fieldnames: Iterable[FieldName]) -&gt; None:\n        for fname in fieldnames:\n            self.delete_field(fname)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all records from the table\"\"\"\n        with self.update_cursor(self.oid_field_name) as cur:\n            for _ in cur:\n                cur.deleteRow()\n\n    def delete_where(self, clause: WhereClause|str) -&gt; None:\n        \"\"\"Delete all records that match the provided where clause\n\n        Args:\n            clause (WhereClause|str): The SQL query that determines the records that will be deleted\n        \"\"\"\n        with self.where(clause):\n            self.clear()\n\n    # Magic Methods\n\n    def __bool__(self) -&gt; Literal[True]:\n        # Override __bool__ to prevent fallback to __len__\n        return True\n\n    _IndexableTypes = FieldName | set[FieldName] | list[FieldName] | tuple[FieldName, ...] | WhereClause | None\n\n    @overload\n    def __getitem__(self, field: tuple[FieldName, ...]) -&gt; Iterator[tuple[Any, ...]]: ...\n    @overload\n    def __getitem__(self, field: list[FieldName]) -&gt; Iterator[list[Any]]: ...\n    @overload\n    def __getitem__(self, field: set[FieldName]) -&gt; Iterator[_Schema]: ...\n    @overload\n    def __getitem__(self, field: FieldName) -&gt; Iterator[Any]: ...\n    @overload\n    def __getitem__(self, field: FilterFunc[_Schema]) -&gt; Iterator[_Schema]: ...\n    @overload\n    def __getitem__(self, field: WhereClause) -&gt; Iterator[_Schema]: ...\n    @overload\n    def __getitem__(self, field: None) -&gt; Iterator[None]: ...\n    def __getitem__(self, field: _IndexableTypes | FilterFunc[_Schema]) -&gt; Iterator[Any]:\n        \"\"\"Handle all defined overloads using pattern matching syntax\n\n        Args:\n            field (str): Yield values in the specified column (values only)\n            field (list[str]): Yield lists of values for requested columns (requested fields)\n            field (tuple[str]): Yield tuples of values for requested columns (requested fields)\n            field (set[str]): Yield dictionaries of values for requested columns (requested fields)\n            field (FilterFunc): Yield rows that match function (all fields)\n            field (WhereClause): Yield rows that match clause (all fields)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; # Single Field\n            &gt;&gt;&gt; print(list(fc['field']))\n            [val1, val2, val3, ...]\n\n            &gt;&gt;&gt; # Field Tuple\n            &gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n            [(val1, val2), (val1, val2), ...]\n\n            &gt;&gt;&gt; # Field List\n            &gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n            [[val1, val2], [val1, val2], ...]\n\n            &gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n            &gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n            [{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n            &gt;&gt;&gt; # Last two options always return all fields in a mapping\n            &gt;&gt;&gt; # Filter Function (passed to Table.filter())\n            &gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n            &gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n            [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n            &gt;&gt;&gt; # None (Empty Iterator)\n            &gt;&gt;&gt; print(list(fc[None]))\n\n            ```\n        \"\"\"\n        match field:\n            # Field Requests\n            case str():\n                with self.search_cursor(field) as cur:\n                    yield from (val for val, in cur)\n            case tuple():\n                with self.search_cursor(*field) as cur:\n                    yield from (row for row in cur)\n            case list():\n                with self.search_cursor(*field) as cur:\n                    yield from (list(row) for row in cur)\n            case set():\n                with self.search_cursor(*field) as cur:\n                    yield from (row for row in self.as_dict(cur))\n            case None:\n                yield from () # This allows a side effect None to be used to get nothing\n\n            # Conditional Requests\n            case wc if isinstance(wc, WhereClause):\n                if not wc.validate(self.fields):\n                    raise KeyError(f'Invalid Where Clause: {wc}, fields not found in {self.name}')\n                with self.search_cursor(*self.fields, where_clause=wc.where_clause) as cur:\n                    yield from (row for row in self.as_dict(cur))\n            case func if callable(func):\n                yield from (row for row in self.filter(func))\n            case _:\n                raise KeyError(\n                    f\"Invalid option: `{field}` \"\n                    \"Must be a WhereClause, filter functon, field, set of fields, list of fields, or tuple of fields\"\n                )\n\n    @overload\n    def get(self, field: tuple[FieldName, ...], default: _T) -&gt; Iterator[tuple[Any, ...]] | _T: ...\n    @overload\n    def get(self, field: list[FieldName], default: _T) -&gt; Iterator[list[Any]] | _T: ...\n    @overload\n    def get(self, field: set[FieldName], default: _T) -&gt; Iterator[_Schema] | _T: ...\n    @overload\n    def get(self, field: FieldName, default: _T) -&gt; Iterator[Any] | _T: ...\n    @overload\n    def get(self, field: FilterFunc[_Schema], default: _T) -&gt; Iterator[_Schema] | _T: ...\n    @overload\n    def get(self, field: WhereClause, default: _T) -&gt; Iterator[_Schema] | _T: ...\n    @overload\n    def get(self, field: None, default: _T) -&gt; Iterator[None] | _T: ...\n    def get(self, field: _IndexableTypes | FilterFunc[_Schema], default: _T=None) -&gt; Iterator[Any] | _T:\n        \"\"\"Allow accessing the implemented indexes defined by `__getitem__` with a default shielding a raised `KeyError`\n\n        Args:\n            field (_Indexable_Types): The index to check (see `__getitem__` implementations)\n            default (_T): A default to return when the indexing raises a `KeyError` or cursor field `RuntimeError` (default: None)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; for name, age in fc[('Name', 'Age')]:\n            &gt;&gt;&gt;     print(name, age)\n            ...\n            KeyError \"Name\"\n            ...\n\n            &gt;&gt;&gt; for name, age in fc.get(('Name', 'Age'), [])\n            ```\n\n        \"\"\"\n        try:\n            return self[field]\n        except (KeyError , RuntimeError) as e:\n            if isinstance(e, RuntimeError) and 'Cannot find field' not in str(e):\n                raise # Raise any non field related RuntimeErrors\n            return default\n\n    def __contains__(self, field: str) -&gt; bool:\n        \"\"\"Implementation of contains that checks for a field existing in the `FeatureClass`\n        \"\"\"\n        return field in self.fields\n\n    def __iter__(self) -&gt; Iterator[_Schema] | Iterator[Any]:\n        \"\"\"Iterate all rows in the Table or FeatureClass yielding mappings of field name to field value\n\n        Note:\n            It was decided to yield mappings because without specifying fields, it is up to the user\n            to deal with the data as they see fit. Yielding tuples in an order that's not defined by\n            the user would be confusing, so a mapping makes it clear exactly what they're accessing\n\n        Note:\n            When a single field is specified using the `fields_as` context, values will be yielded\n        \"\"\" \n        with self.search_cursor(*self.fields) as cur:\n            if len(self.fields) == 1:\n                yield from (row for row, in cur)\n            else:\n                yield from self.as_dict(cur)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Iterate all rows and count them. Only count with `self.search_options` queries.\n\n        Note:\n            The `__format__('len')` spec calls this function. So `len(fc)` and `f'{fc:len}'` are the same, \n            with the caveat that the format spec option returns a string\n\n        Warning:\n            This operation will traverse the whole dataset when called! You should not use it in loops:\n            ```python\n            # Bad\n            for i, _ in enumerate(fc):\n                print(f'{i}/{len(fc)}')\n\n            # Good\n            count = len(fc)\n            for i, _ in enumerate(fc):\n                print(f'{i}/{count}')\n            ```\n        \"\"\"\n        #return sum(1 for _ in self['OID@'])\n        return sum(1 for _ in self.search_cursor('OID@'))\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Provide a constructor string e.g. `Table or FeatureClass[Polygon]('path')`\"\"\"\n        return f\"{self.__class__.__name__}('{self.__fspath__()}')\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the `Table` or `FeatureClass` path for use with other arcpy methods\"\"\"\n        return self.__fspath__()\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"Determine if the datasource of two featureclass objects is the same\"\"\"\n        return isinstance(other, self.__class__) and self.__fspath__() == other.__fspath__()\n\n    def __format__(self, format_spec: str) -&gt; str:\n        \"\"\"Implement format specs for string formatting a featureclass.\n\n        Warning:\n            The `{fc:len}` spec should only be used when needed. This spec will call `__len__` when \n            used and will traverse the entire Table or FeatureClass with applied SearchOptions each time it is \n            called. See: `__len__` doc for info on better ways to track counts in loops.\n\n        Args:\n            format_spec:  One of the options listed below (the `|` symbol is used to seperate aliases)\n\n        Other Parameters:\n            path|pth (str): Table or FeatureClass path\n            len|length (str): Table or FeatureClass length (with applied SearchQuery)\n            layer|lyr (str): Linked Table or FeatureClass layer if applicable (else `'None'`)\n            shape|shp (str): Table or FeatureClass shape type\n            units|unt (str): Table or FeatureClass linear unit name\n            wkid|code (str): Table or FeatureClass WKID\n            name|nm (str): Table or FeatureClass name\n            fields|fld (str): Table or FeatureClass fields (comma seperated)\n\n        Example:\n            ```python\n            &gt;&gt;&gt; f'{fc:wkid}'\n            '2236'\n            &gt;&gt;&gt; f'{fc:path}'\n            'C:\\\\&lt;FeaturePath&gt;'\n            &gt;&gt;&gt; f'{fc:len}'\n            '101'\n            &gt;&gt;&gt; f'{fc:shape}'\n            'Polygon'\n            ```\n        \"\"\"\n        match format_spec:\n            case 'path' | 'pth':\n                return self.path\n            case 'len' | 'length':\n                return str(len(self))\n            case 'layer' | 'lyr':\n                return self.layer.longName if self.layer else 'None'\n            case 'name' | 'nm':\n                return self.name\n            case 'fields' | 'flds':\n                return ','.join(self.fields)\n            case _:\n                return str(self)\n\n    def __fspath__(self) -&gt; str:\n        return str(Path(self.path).resolve())\n\n    def __hash__(self) -&gt; int:\n        return hash(self.__fspath__())\n\n    # Handle Fields\n\n    def __delitem__(self, fieldname: str) -&gt; None:\n        self.delete_field(fieldname)\n\n    def __setitem__(self, fieldname: str, field: Field) -&gt; None:\n        if fieldname in self.fields:\n            raise ValueError(f'{fieldname} already exists in {self.name}')\n        if not set(field.keys()).issubset([*Field.__optional_keys__, *Field.__required_keys__]):\n            raise ValueError(f'Provided Field options are invalid, see `Field` from arcpie.cursor or arcpy for valid keys')\n        self.add_field(fieldname, **field)\n\n    # Context Managers\n\n    @contextmanager\n    def fields_as(self, *fields: FieldName):\n        \"\"\"Override the default fields for the Table or FeatureClass so all non-explicit Iterators will\n        only yield these fields (e.g. `for row in fc: ...`)\n\n        Args:\n            *fields (FieldName): Varargs of the fieldnames to limit all unspecified Iterators to\n\n        Example:\n            ```python\n            &gt;&gt;&gt; with fc.fields_as('OID@', 'NAME'):\n            ...     for row in fc:\n            ...         print(row)\n            {'OID@': 1, 'NAME': 'John'}\n            {'OID@': 2, 'NAME': 'Michael'}\n            ...\n            &gt;&gt;&gt; for row in fc:\n            ...     print(row)\n            {'OID@': 1, 'NAME': 'John', 'AGE': 75, 'ADDRESS': 123 Silly Walk}\n            {'OID@': 2, 'NAME': 'Michael', 'AGE': 70, 'ADDRESS': 42 Dead Parrot Blvd}\n            ...\n            ```\n        \"\"\"\n        # Allow passing a single field as a string `fc.fields_as('OID@')` to maintain\n        # The call format of *Cursor objects\n        _fields = self.fields\n        self._fields = tuple(fields)\n        try:\n            yield self\n        finally:\n            self._fields = _fields\n\n    @contextmanager\n    def options(self,\n                *, \n                strict: bool = False,\n                search_options: SearchOptions|None=None, \n                update_options: UpdateOptions|None=None, \n                insert_options: InsertOptions|None=None, \n                clause: SQLClause|None=None):\n        \"\"\"Enter a context block where the supplied options replace the stored options for the `Table` or `FeatureClass`\n\n        Args:\n            strict (bool): If this is set to `True` the `Table` or `FeatureClass` will not fallback on existing options\n                when set to `False`, provided options override existing options (default: `False`)\n            search_options (SearchOptions): Contextual search overrides\n            update_options (UpdateOptions): Contextual update overrides\n            insert_options (InsertOptions): Contextual insert overrides\n            clause (SQLClause): Contextual `sql_clause` override\n        \"\"\"\n        _src_ops = self.search_options\n        _upd_ops = self.update_options\n        _ins_ops = self.insert_options\n        _clause  = self.clause\n        try:\n            self._search_options = (\n                self._resolve_search_options(_src_ops, search_options or {}) \n                if not strict\n                else search_options or SearchOptions()\n            )\n            self._update_options = (\n                self._resolve_update_options(_upd_ops, update_options or {})\n                if not strict \n                else insert_options or UpdateOptions()\n            )\n            self._insert_options = (\n                self._resolve_insert_options(_ins_ops, insert_options or {})\n                if not strict \n                else insert_options or InsertOptions()\n            )\n            self._clause = (\n                clause or _clause\n                if not strict \n                else SQLClause(None, None)\n            )\n            yield self\n\n        finally:\n            self._search_options = _src_ops\n            self._update_options = _upd_ops\n            self.insert_options = _ins_ops\n            self._clause = _clause\n\n    @contextmanager\n    def where(self, where_clause: WhereClause|str):\n        \"\"\"Apply a where clause to a Table or FeatureClass in a context\n\n        Args:\n            where_clause (WhereClause|str): The where clause to apply to the Table or FeatureClass\n\n        Example:\n            ```python\n            &gt;&gt;&gt; with fc.where(\"first = 'John'\") as f:\n            ...     for f in fc:\n            ...         print(f)\n            {'first': 'John', 'last': 'Cleese', 'year': 1939}\n\n            &gt;&gt;&gt; with fc.where('year &gt; 1939'):\n            ...     print(len(fc))\n            5\n            ... print(len(fc))\n            6\n            ```\n\n        Note:\n            This method of filtering a Table or FeatureClass will always be more performant than using the \n            `.filter` method. If you can achieve the filtering you want with a where clause, do it.\n        \"\"\"\n        with self.options(\n            search_options=SearchOptions(where_clause=str(where_clause)),\n            update_options=UpdateOptions(where_clause=str(where_clause))):\n            yield self\n\n    # Mapping interfaces (These pass common `Layer` operations up to the Table or FeatureClass)\n    def bind_to_layer(self, layer: Layer) -&gt; None:\n        \"\"\"Update the provided layer's datasource to this Table or FeatureClass\n\n        Args:\n            layer (Layer): The layer to update connection properties for\n        \"\"\"\n        layer.updateConnectionProperties(layer.dataSource, self.path) #type:ignore\n\n    def add_to_map(self, map: Map, pos: Literal['AUTO_ARRANGE', 'BOTTOM', 'TOP']='AUTO_ARRANGE') -&gt; None:\n        \"\"\"Add the featureclass to a map\n\n        Note: \n            If the Table or FeatureClass has a layer, the bound layer will be added to the map. \n            Otherwise a default layer will be added. And the new layer will be bound to the Table or FeatureClass\n\n        Args:\n            map (Map): The map to add the featureclass to\n        \"\"\"\n        if not self.layer:\n            # Create a default layer, bind it, remove, and add back\n            # with addLayer to match behavior with existing bound layer\n            self.layer = map.addDataFromPath(self.path) #type:ignore (Always Layer)\n            map.removeLayer(self.layer) #type:ignore (Incorrect Signature)\n        map.addLayer(self.layer, pos) #type:ignore\n\n    def select(self, method: Literal['NEW','DIFFERENCE','INTERSECT','SYMDIFFERENCE','UNION']='NEW') -&gt; None:\n        \"\"\"If the Table or FeatureClass is bound to a layer, update the layer selection with the active SearchOptions\n\n        Args:\n            method: The method to use to apply the selection\\n\n                `DIFFERENCE`: Selects the features that are not in the current selection but are in the Table or FeatureClass.\\n\n                `INTERSECT`: Selects the features that are in the current selection and the Table or FeatureClass.\\n\n                `NEW`: Creates a new feature selection from the Table or FeatureClass.\\n\n                `SYMDIFFERENCE`: Selects the features that are in the current selection or the Table or FeatureClass but not both.\\n\n                `UNION`: Selects all the features in both the current selection and those in Table or FeatureClass.\\n\n\n        Note:\n            Selection changes require the project file to be saved to take effect. \n        \"\"\"\n        if self.layer:\n            _selected = list(self['OID@'])\n            self.layer.setSelectionSet(_selected, method=method)\n            try: # Try to select the layer in the active map\n                if len(_selected) == 1:\n                    _query = f'{self.oid_field_name} = {_selected.pop()})'\n                if len(_selected) &gt; 1:\n                    _query = f'{self.oid_field_name} IN ({format_query_list(_selected)})'\n                else:\n                    return\n                SelectLayerByAttribute(self.layer.longName, 'NEW_SELECTION', _query)\n            except Exception:\n                return\n\n    def unselect(self) -&gt; None:\n        \"\"\"If the Table or FeatureClass is bound to a layer, Remove layer selection\n\n        Note:\n            Selection changes require the project file to be saved to take effect.\n        \"\"\"\n        if self.layer:\n            self.layer.setSelectionSet(method='NEW')\n            try: # Try to unselect the layer in the active map\n                SelectLayerByAttribute(self.layer.longName, 'CLEAR_SELECTION')\n            except Exception:\n                return\n\n    # Factory Constructors\n    @classmethod\n    def from_table(cls, table: TableLayer,\n                   *,\n                   ignore_selection: bool = False,\n                   ignore_def_query: bool = False,) -&gt; Table:\n        \"\"\"See `from_layer` for documentation, this is an alternative constructor that builds from a mp.Table object\"\"\"\n        return Table.from_layer(table, ignore_selection=ignore_selection, ignore_def_query=ignore_def_query) # type: ignore (this won't break the interface)\n\n    @classmethod\n    def from_layer(cls, layer: Layer,\n                   *,\n                   ignore_selection: bool = False,\n                   ignore_def_query: bool = False,) -&gt; Table[Any]:\n        \"\"\"Build a Table or FeatureClass object from a layer applying the layer's current selection to the stored cursors\n\n        Args:\n            layer (Layer): The layer to convert to a Table or FeatureClass\n            ignore_selection (bool): Ignore the layer selection (default: False)\n            ignore_def_query (bool): Ignore the layer definition query (default: False)\n        Returns:\n            ( Table or FeatureClass ): The Table or FeatureClass object with the layer query applied\n        \"\"\"\n        fc = cls(Path(layer.dataSource).resolve())\n\n        selected_ids: set[int] | None = (\n            layer.getSelectionSet() or None\n            if not ignore_selection \n            else None\n        )\n        definition_query: str|None = (\n            layer.definitionQuery or None\n            if not ignore_def_query \n            else None\n        )\n        selection: str|None = (\n            f\"{fc.oid_field_name} IN ({format_query_list(selected_ids)})\" \n            if selected_ids \n            else None\n        )\n\n        if (query_components := list(filter(None, [definition_query, selection]))):\n            where_clause = ' AND '.join(query_components)\n            fc.search_options = SearchOptions(where_clause=where_clause)\n            fc.update_options = UpdateOptions(where_clause=where_clause)\n\n        fc.layer = layer\n        return fc\n\n    def copy(self) -&gt; Table[_Schema]:\n        \"\"\"Create a new FeatureClass instance to prevent overriding a shared resource\"\"\"\n        return Table[_Schema](\n            self._path, \n            search_options=self.search_options.copy(),\n            update_options=self.update_options.copy(),\n            insert_options=self.insert_options.copy(),\n            clause=self.clause\n        )\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.GroupIdent","title":"<code>GroupIdent = tuple[Any, ...] | Any</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/featureclass/#arcpie.featureclass.Table.GroupIter","title":"<code>GroupIter = Iterator[tuple[Any, ...] | Any]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/featureclass/#arcpie.featureclass.Table.Tokens","title":"<code>Tokens = TableTokens</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/featureclass/#arcpie.featureclass.Table.attribute_rules","title":"<code>attribute_rules</code>  <code>property</code>","text":"<p>Get an <code>AttributeRuleManager</code> object bound to the Table/FeatureClass</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.clause","title":"<code>clause</code>  <code>property</code> <code>writable</code>","text":"<p>Default SQLClause</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.da_describe","title":"<code>da_describe</code>  <code>property</code>","text":"<p>Access the da.Describe dictionary for the <code>Table</code> or <code>FeatureClass</code></p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.describe","title":"<code>describe</code>  <code>property</code>","text":"<p>Access the arcpy.Describe object for the <code>Table</code> or <code>FeatureClass</code></p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.editor","title":"<code>editor</code>  <code>property</code>","text":"<p>Get an Editor manager for the Table or FeatureClass Will set multiuser_mode to True if the feature can version</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.fields","title":"<code>fields</code>  <code>property</code>","text":"<p>Tuple of all fieldnames in the Table or FeatureClass with <code>OID@</code> as first</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.insert_options","title":"<code>insert_options</code>  <code>property</code> <code>writable</code>","text":"<p>Default InsertCursor options</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.layer","title":"<code>layer</code>  <code>property</code> <code>writable</code>","text":"<p>A Layer object for the FeatureClass/Table if one is bound</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.name","title":"<code>name</code>  <code>property</code>","text":"<p>The common name of the FeatureClass/Table</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.np_dtypes","title":"<code>np_dtypes</code>  <code>property</code>","text":"<p>Numpy dtypes for each field</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.oid_field_name","title":"<code>oid_field_name</code>  <code>property</code>","text":"<p>ObjectID fieldname (ususally FID or OID or ObjectID)</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.path","title":"<code>path</code>  <code>property</code>","text":"<p>The filepath of the FeatureClass/Table</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.py_types","title":"<code>py_types</code>  <code>property</code>","text":"<p>Get a mapping of fieldnames to python types for the Table</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.search_options","title":"<code>search_options</code>  <code>property</code> <code>writable</code>","text":"<p>Default SearchCursor options</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.subtype_field","title":"<code>subtype_field</code>  <code>property</code>","text":"<p>The Subtype field (ususally SUBTYPE or SUBTYPE_CODE, etc.)</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.subtypes","title":"<code>subtypes</code>  <code>property</code>","text":"<p>Result of ListSubtypes, mapping of code to Subtype object</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.update_options","title":"<code>update_options</code>  <code>property</code> <code>writable</code>","text":"<p>Default UpdateCursor options</p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.workspace","title":"<code>workspace</code>  <code>property</code>","text":"<p>Get the workspace of the <code>Table</code> or <code>FeatureClass</code></p>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__bool__","title":"<code>__bool__()</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __bool__(self) -&gt; Literal[True]:\n    # Override __bool__ to prevent fallback to __len__\n    return True\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__contains__","title":"<code>__contains__(field)</code>","text":"<p>Implementation of contains that checks for a field existing in the <code>FeatureClass</code></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __contains__(self, field: str) -&gt; bool:\n    \"\"\"Implementation of contains that checks for a field existing in the `FeatureClass`\n    \"\"\"\n    return field in self.fields\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__delitem__","title":"<code>__delitem__(fieldname)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __delitem__(self, fieldname: str) -&gt; None:\n    self.delete_field(fieldname)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Determine if the datasource of two featureclass objects is the same</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Determine if the datasource of two featureclass objects is the same\"\"\"\n    return isinstance(other, self.__class__) and self.__fspath__() == other.__fspath__()\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__format__","title":"<code>__format__(format_spec)</code>","text":"<p>Implement format specs for string formatting a featureclass.</p> Warning <p>The <code>{fc:len}</code> spec should only be used when needed. This spec will call <code>__len__</code> when  used and will traverse the entire Table or FeatureClass with applied SearchOptions each time it is  called. See: <code>__len__</code> doc for info on better ways to track counts in loops.</p> <p>Parameters:</p> Name Type Description Default <code>format_spec</code> <code>str</code> <p>One of the options listed below (the <code>|</code> symbol is used to seperate aliases)</p> required <p>Other Parameters:</p> Name Type Description <code>path|pth</code> <code>str</code> <p>Table or FeatureClass path</p> <code>len|length</code> <code>str</code> <p>Table or FeatureClass length (with applied SearchQuery)</p> <code>layer|lyr</code> <code>str</code> <p>Linked Table or FeatureClass layer if applicable (else <code>'None'</code>)</p> <code>shape|shp</code> <code>str</code> <p>Table or FeatureClass shape type</p> <code>units|unt</code> <code>str</code> <p>Table or FeatureClass linear unit name</p> <code>wkid|code</code> <code>str</code> <p>Table or FeatureClass WKID</p> <code>name|nm</code> <code>str</code> <p>Table or FeatureClass name</p> <code>fields|fld</code> <code>str</code> <p>Table or FeatureClass fields (comma seperated)</p> Example <pre><code>&gt;&gt;&gt; f'{fc:wkid}'\n'2236'\n&gt;&gt;&gt; f'{fc:path}'\n'C:\\&lt;FeaturePath&gt;'\n&gt;&gt;&gt; f'{fc:len}'\n'101'\n&gt;&gt;&gt; f'{fc:shape}'\n'Polygon'\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __format__(self, format_spec: str) -&gt; str:\n    \"\"\"Implement format specs for string formatting a featureclass.\n\n    Warning:\n        The `{fc:len}` spec should only be used when needed. This spec will call `__len__` when \n        used and will traverse the entire Table or FeatureClass with applied SearchOptions each time it is \n        called. See: `__len__` doc for info on better ways to track counts in loops.\n\n    Args:\n        format_spec:  One of the options listed below (the `|` symbol is used to seperate aliases)\n\n    Other Parameters:\n        path|pth (str): Table or FeatureClass path\n        len|length (str): Table or FeatureClass length (with applied SearchQuery)\n        layer|lyr (str): Linked Table or FeatureClass layer if applicable (else `'None'`)\n        shape|shp (str): Table or FeatureClass shape type\n        units|unt (str): Table or FeatureClass linear unit name\n        wkid|code (str): Table or FeatureClass WKID\n        name|nm (str): Table or FeatureClass name\n        fields|fld (str): Table or FeatureClass fields (comma seperated)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; f'{fc:wkid}'\n        '2236'\n        &gt;&gt;&gt; f'{fc:path}'\n        'C:\\\\&lt;FeaturePath&gt;'\n        &gt;&gt;&gt; f'{fc:len}'\n        '101'\n        &gt;&gt;&gt; f'{fc:shape}'\n        'Polygon'\n        ```\n    \"\"\"\n    match format_spec:\n        case 'path' | 'pth':\n            return self.path\n        case 'len' | 'length':\n            return str(len(self))\n        case 'layer' | 'lyr':\n            return self.layer.longName if self.layer else 'None'\n        case 'name' | 'nm':\n            return self.name\n        case 'fields' | 'flds':\n            return ','.join(self.fields)\n        case _:\n            return str(self)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__fspath__","title":"<code>__fspath__()</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __fspath__(self) -&gt; str:\n    return str(Path(self.path).resolve())\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__getitem__","title":"<code>__getitem__(field)</code>","text":"<pre><code>__getitem__(\n    field: tuple[FieldName, ...],\n) -&gt; Iterator[tuple[Any, ...]]\n</code></pre><pre><code>__getitem__(field: list[FieldName]) -&gt; Iterator[list[Any]]\n</code></pre><pre><code>__getitem__(field: set[FieldName]) -&gt; Iterator[_Schema]\n</code></pre><pre><code>__getitem__(field: FieldName) -&gt; Iterator[Any]\n</code></pre><pre><code>__getitem__(\n    field: FilterFunc[_Schema],\n) -&gt; Iterator[_Schema]\n</code></pre><pre><code>__getitem__(field: WhereClause) -&gt; Iterator[_Schema]\n</code></pre><pre><code>__getitem__(field: None) -&gt; Iterator[None]\n</code></pre> <p>Handle all defined overloads using pattern matching syntax</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>str</code> <p>Yield values in the specified column (values only)</p> required <code>field</code> <code>list[str]</code> <p>Yield lists of values for requested columns (requested fields)</p> required <code>field</code> <code>tuple[str]</code> <p>Yield tuples of values for requested columns (requested fields)</p> required <code>field</code> <code>set[str]</code> <p>Yield dictionaries of values for requested columns (requested fields)</p> required <code>field</code> <code>FilterFunc</code> <p>Yield rows that match function (all fields)</p> required <code>field</code> <code>WhereClause</code> <p>Yield rows that match clause (all fields)</p> required Example <pre><code>&gt;&gt;&gt; # Single Field\n&gt;&gt;&gt; print(list(fc['field']))\n[val1, val2, val3, ...]\n\n&gt;&gt;&gt; # Field Tuple\n&gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n[(val1, val2), (val1, val2), ...]\n\n&gt;&gt;&gt; # Field List\n&gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n[[val1, val2], [val1, val2], ...]\n\n&gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n&gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n[{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n&gt;&gt;&gt; # Last two options always return all fields in a mapping\n&gt;&gt;&gt; # Filter Function (passed to Table.filter())\n&gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n&gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n[{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n&gt;&gt;&gt; # None (Empty Iterator)\n&gt;&gt;&gt; print(list(fc[None]))\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __getitem__(self, field: _IndexableTypes | FilterFunc[_Schema]) -&gt; Iterator[Any]:\n    \"\"\"Handle all defined overloads using pattern matching syntax\n\n    Args:\n        field (str): Yield values in the specified column (values only)\n        field (list[str]): Yield lists of values for requested columns (requested fields)\n        field (tuple[str]): Yield tuples of values for requested columns (requested fields)\n        field (set[str]): Yield dictionaries of values for requested columns (requested fields)\n        field (FilterFunc): Yield rows that match function (all fields)\n        field (WhereClause): Yield rows that match clause (all fields)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # Single Field\n        &gt;&gt;&gt; print(list(fc['field']))\n        [val1, val2, val3, ...]\n\n        &gt;&gt;&gt; # Field Tuple\n        &gt;&gt;&gt; print(list(fc[('field1', 'field2')]))\n        [(val1, val2), (val1, val2), ...]\n\n        &gt;&gt;&gt; # Field List\n        &gt;&gt;&gt; print(list(fc[['field1', 'field2']]))\n        [[val1, val2], [val1, val2], ...]\n\n        &gt;&gt;&gt; # Field Set (Row mapping limited to only requested fields)\n        &gt;&gt;&gt; print(list(fc[{'field1', 'field2'}]))\n        [{'field1': val1, 'field2': val2}, {'field1': val1, 'field2': val2}, ...]\n\n        &gt;&gt;&gt; # Last two options always return all fields in a mapping\n        &gt;&gt;&gt; # Filter Function (passed to Table.filter())\n        &gt;&gt;&gt; print(list(fc[lambda r: r['field1'] == target]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # Where Clause (Use where() helper function or a WhereClause object)\n        &gt;&gt;&gt; print(list(fc[where('field1 = target')]))\n        [{'field1': val1, 'field2': val2, ...}, {'field1': val1, 'field2': val2, ...}, ...]\n\n        &gt;&gt;&gt; # None (Empty Iterator)\n        &gt;&gt;&gt; print(list(fc[None]))\n\n        ```\n    \"\"\"\n    match field:\n        # Field Requests\n        case str():\n            with self.search_cursor(field) as cur:\n                yield from (val for val, in cur)\n        case tuple():\n            with self.search_cursor(*field) as cur:\n                yield from (row for row in cur)\n        case list():\n            with self.search_cursor(*field) as cur:\n                yield from (list(row) for row in cur)\n        case set():\n            with self.search_cursor(*field) as cur:\n                yield from (row for row in self.as_dict(cur))\n        case None:\n            yield from () # This allows a side effect None to be used to get nothing\n\n        # Conditional Requests\n        case wc if isinstance(wc, WhereClause):\n            if not wc.validate(self.fields):\n                raise KeyError(f'Invalid Where Clause: {wc}, fields not found in {self.name}')\n            with self.search_cursor(*self.fields, where_clause=wc.where_clause) as cur:\n                yield from (row for row in self.as_dict(cur))\n        case func if callable(func):\n            yield from (row for row in self.filter(func))\n        case _:\n            raise KeyError(\n                f\"Invalid option: `{field}` \"\n                \"Must be a WhereClause, filter functon, field, set of fields, list of fields, or tuple of fields\"\n            )\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__hash__","title":"<code>__hash__()</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __hash__(self) -&gt; int:\n    return hash(self.__fspath__())\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__init__","title":"<code>__init__(path, *, search_options=None, update_options=None, insert_options=None, clause=None, where=None)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __init__(\n        self, path: str|Path,\n        *,\n        search_options: SearchOptions|None=None, \n        update_options: UpdateOptions|None=None, \n        insert_options: InsertOptions|None=None,\n        clause: SQLClause|None=None,\n        where: str|None=None,\n    ) -&gt; None:\n    self._path = str(path)\n    self._clause = clause or SQLClause(None, None)\n    self._search_options = search_options or SearchOptions()\n    self._insert_options = insert_options or InsertOptions()\n    self._update_options = update_options or UpdateOptions()\n\n    # Override\n    if where:\n        self._search_options['where_clause'] = where\n        self._update_options['where_clause'] = where\n\n    self._layer: Layer|None=None\n    self._in_edit_session=False\n    self._fields: tuple[TableToken | str, ...]|None=None\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate all rows in the Table or FeatureClass yielding mappings of field name to field value</p> Note <p>It was decided to yield mappings because without specifying fields, it is up to the user to deal with the data as they see fit. Yielding tuples in an order that's not defined by the user would be confusing, so a mapping makes it clear exactly what they're accessing</p> Note <p>When a single field is specified using the <code>fields_as</code> context, values will be yielded</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __iter__(self) -&gt; Iterator[_Schema] | Iterator[Any]:\n    \"\"\"Iterate all rows in the Table or FeatureClass yielding mappings of field name to field value\n\n    Note:\n        It was decided to yield mappings because without specifying fields, it is up to the user\n        to deal with the data as they see fit. Yielding tuples in an order that's not defined by\n        the user would be confusing, so a mapping makes it clear exactly what they're accessing\n\n    Note:\n        When a single field is specified using the `fields_as` context, values will be yielded\n    \"\"\" \n    with self.search_cursor(*self.fields) as cur:\n        if len(self.fields) == 1:\n            yield from (row for row, in cur)\n        else:\n            yield from self.as_dict(cur)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__len__","title":"<code>__len__()</code>","text":"<p>Iterate all rows and count them. Only count with <code>self.search_options</code> queries.</p> Note <p>The <code>__format__('len')</code> spec calls this function. So <code>len(fc)</code> and <code>f'{fc:len}'</code> are the same,  with the caveat that the format spec option returns a string</p> Warning <p>This operation will traverse the whole dataset when called! You should not use it in loops: <pre><code># Bad\nfor i, _ in enumerate(fc):\n    print(f'{i}/{len(fc)}')\n\n# Good\ncount = len(fc)\nfor i, _ in enumerate(fc):\n    print(f'{i}/{count}')\n</code></pre></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Iterate all rows and count them. Only count with `self.search_options` queries.\n\n    Note:\n        The `__format__('len')` spec calls this function. So `len(fc)` and `f'{fc:len}'` are the same, \n        with the caveat that the format spec option returns a string\n\n    Warning:\n        This operation will traverse the whole dataset when called! You should not use it in loops:\n        ```python\n        # Bad\n        for i, _ in enumerate(fc):\n            print(f'{i}/{len(fc)}')\n\n        # Good\n        count = len(fc)\n        for i, _ in enumerate(fc):\n            print(f'{i}/{count}')\n        ```\n    \"\"\"\n    #return sum(1 for _ in self['OID@'])\n    return sum(1 for _ in self.search_cursor('OID@'))\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__repr__","title":"<code>__repr__()</code>","text":"<p>Provide a constructor string e.g. <code>Table or FeatureClass[Polygon]('path')</code></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Provide a constructor string e.g. `Table or FeatureClass[Polygon]('path')`\"\"\"\n    return f\"{self.__class__.__name__}('{self.__fspath__()}')\"\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__setitem__","title":"<code>__setitem__(fieldname, field)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __setitem__(self, fieldname: str, field: Field) -&gt; None:\n    if fieldname in self.fields:\n        raise ValueError(f'{fieldname} already exists in {self.name}')\n    if not set(field.keys()).issubset([*Field.__optional_keys__, *Field.__required_keys__]):\n        raise ValueError(f'Provided Field options are invalid, see `Field` from arcpie.cursor or arcpy for valid keys')\n    self.add_field(fieldname, **field)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.__str__","title":"<code>__str__()</code>","text":"<p>Return the <code>Table</code> or <code>FeatureClass</code> path for use with other arcpy methods</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the `Table` or `FeatureClass` path for use with other arcpy methods\"\"\"\n    return self.__fspath__()\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.add_field","title":"<code>add_field(fieldname, field=None, **options)</code>","text":"<p>Add a new field to a Table or FeatureClass, if no type is provided, deafault of <code>VARCHAR(255)</code> is used</p> <p>Parameters:</p> Name Type Description Default <code>fieldname</code> <code>str</code> <p>The name of the new field (must not start with a number and be alphanum or underscored)</p> required <code>field</code> <code>Field</code> <p>A Field object that contains the desired field properties</p> <code>None</code> <code>**options</code> <code>**Field</code> <p>Allow passing keyword arguments for field directly (Overrides field arg)</p> <code>{}</code> Example <pre><code>&gt;&gt;&gt; new_field = Field(\n...     field_alias='Abbreviated Month',\n...     field_type='TEXT',\n...     field_length='3',\n...     field_domain='Months_ABBR',\n... )\n\n&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name', 'year']\n\n&gt;&gt;&gt; fc['month'] = new_field\n&gt;&gt;&gt; fc2['month'] = new_field # Can re-use a field definition \n&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name', 'year', 'month']\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def add_field(self, fieldname: str, field: Field|None=None, **options: Unpack[Field]) -&gt; None:\n    \"\"\"Add a new field to a Table or FeatureClass, if no type is provided, deafault of `VARCHAR(255)` is used\n\n    Args:\n        fieldname (str): The name of the new field (must not start with a number and be alphanum or underscored)\n        field (Field): A Field object that contains the desired field properties\n        **options (**Field): Allow passing keyword arguments for field directly (Overrides field arg)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_field = Field(\n        ...     field_alias='Abbreviated Month',\n        ...     field_type='TEXT',\n        ...     field_length='3',\n        ...     field_domain='Months_ABBR',\n        ... )\n\n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name', 'year']\n\n        &gt;&gt;&gt; fc['month'] = new_field\n        &gt;&gt;&gt; fc2['month'] = new_field # Can re-use a field definition \n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name', 'year', 'month']\n        ```\n    \"\"\"\n    if self.has_field(fieldname):\n        raise ValueError(f'{self.name} already has a field called {fieldname}!')\n\n    # Use provided field or default to 'TEXT' and override with kwargs\n    field = {**(field or Field(field_type='TEXT')), **options}\n\n    # Handle malformed Field arg\n    field['field_type'] = field.get('field_type', 'TEXT')\n\n    _option_kwargs = set(Field.__optional_keys__) | set(Field.__required_keys__)\n    _provided = set(field.keys())\n\n    if not _provided &lt;= _option_kwargs:\n        raise ValueError(f\"Unknown Field properties provided: {_provided - _option_kwargs}\")\n\n    if not valid_field(fieldname):\n        raise ValueError(\n            f\"{fieldname} is invalid, fieldnames must not start with a number \"\n            \"and must only contain alphanumeric characters and underscores\"\n        )\n\n    with EnvManager(workspace=self.workspace):\n        AddField(self.path, fieldname, **field)\n        self._fields = None\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.add_fields","title":"<code>add_fields(fields)</code>","text":"<p>Provide a mapping of fieldnames to Fields</p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>dict[str, Field]</code> <p>A mapping of fieldnames to Field objects</p> required Example <pre><code>&gt;&gt;&gt; fields = {'f1': Field(...), 'f2': Field(...)}\n&gt;&gt;&gt; fc.add_fields(fields)\n&gt;&gt;&gt; fc.fields\n['OID@', 'SHAPE@', 'f1', 'f2']\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def add_fields(self, fields: dict[str, Field]) -&gt; None:\n    \"\"\"Provide a mapping of fieldnames to Fields\n\n    Args:\n        fields (dict[str, Field]): A mapping of fieldnames to Field objects\n\n    Example:\n        ```python\n        &gt;&gt;&gt; fields = {'f1': Field(...), 'f2': Field(...)}\n        &gt;&gt;&gt; fc.add_fields(fields)\n        &gt;&gt;&gt; fc.fields\n        ['OID@', 'SHAPE@', 'f1', 'f2']\n        ```\n    \"\"\"\n    for fieldname, field in fields.items():\n        self.add_field(fieldname, field)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.add_to_map","title":"<code>add_to_map(map, pos='AUTO_ARRANGE')</code>","text":"<p>Add the featureclass to a map</p> Note <p>If the Table or FeatureClass has a layer, the bound layer will be added to the map.  Otherwise a default layer will be added. And the new layer will be bound to the Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>map</code> <code>Map</code> <p>The map to add the featureclass to</p> required Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def add_to_map(self, map: Map, pos: Literal['AUTO_ARRANGE', 'BOTTOM', 'TOP']='AUTO_ARRANGE') -&gt; None:\n    \"\"\"Add the featureclass to a map\n\n    Note: \n        If the Table or FeatureClass has a layer, the bound layer will be added to the map. \n        Otherwise a default layer will be added. And the new layer will be bound to the Table or FeatureClass\n\n    Args:\n        map (Map): The map to add the featureclass to\n    \"\"\"\n    if not self.layer:\n        # Create a default layer, bind it, remove, and add back\n        # with addLayer to match behavior with existing bound layer\n        self.layer = map.addDataFromPath(self.path) #type:ignore (Always Layer)\n        map.removeLayer(self.layer) #type:ignore (Incorrect Signature)\n    map.addLayer(self.layer, pos) #type:ignore\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.as_dict","title":"<code>as_dict(cursor)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def as_dict(self, cursor: SearchCursor | UpdateCursor) -&gt; Iterator[_Schema]:\n    yield from as_dict(cursor) # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.bind_to_layer","title":"<code>bind_to_layer(layer)</code>","text":"<p>Update the provided layer's datasource to this Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer to update connection properties for</p> required Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def bind_to_layer(self, layer: Layer) -&gt; None:\n    \"\"\"Update the provided layer's datasource to this Table or FeatureClass\n\n    Args:\n        layer (Layer): The layer to update connection properties for\n    \"\"\"\n    layer.updateConnectionProperties(layer.dataSource, self.path) #type:ignore\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.clear","title":"<code>clear()</code>","text":"<p>Clear all records from the table</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear all records from the table\"\"\"\n    with self.update_cursor(self.oid_field_name) as cur:\n        for _ in cur:\n            cur.deleteRow()\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.copy","title":"<code>copy()</code>","text":"<p>Create a new FeatureClass instance to prevent overriding a shared resource</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def copy(self) -&gt; Table[_Schema]:\n    \"\"\"Create a new FeatureClass instance to prevent overriding a shared resource\"\"\"\n    return Table[_Schema](\n        self._path, \n        search_options=self.search_options.copy(),\n        update_options=self.update_options.copy(),\n        insert_options=self.insert_options.copy(),\n        clause=self.clause\n    )\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.copy_to","title":"<code>copy_to(workspace, options=True)</code>","text":"<p>Copy this <code>Table</code> or <code>FeatureClass</code> to a new workspace</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The path to the workspace</p> required <code>options</code> <code>bool</code> <p>Copy the cursor options to the new <code>Table</code> or <code>FeatureClass</code> (default: <code>True</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>Table or FeatureClass</code> <p>A <code>Table</code> or <code>FeatureClass</code> instance of the copied features</p> Example <pre><code>&gt;&gt;&gt; new_fc = fc.copy('workspace2')\n&gt;&gt;&gt; new_fc == fc\nFalse\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def copy_to(self, workspace: str, options: bool=True) -&gt; Self:\n    \"\"\"Copy this `Table` or `FeatureClass` to a new workspace\n\n    Args:\n        workspace (str): The path to the workspace\n        options (bool): Copy the cursor options to the new `Table` or `FeatureClass` (default: `True`)\n\n    Returns:\n        (Table or FeatureClass): A `Table` or `FeatureClass` instance of the copied features\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_fc = fc.copy('workspace2')\n        &gt;&gt;&gt; new_fc == fc\n        False\n        ```\n    \"\"\"\n    #name = Path(self.path).relative_to(Path(self.workspace))\n    if Exists(copy_fc := Path(workspace) / self.name):\n        raise ValueError(f'{self.name} already exists in {workspace}!')\n    CopyFeatures(self.path, str(copy_fc))\n    fc = self.__class__(str(copy_fc))\n    if options:\n        fc.search_options = self.search_options\n        fc.update_options = self.update_options\n        fc.insert_options = self.insert_options\n        fc.clause = self.clause\n    return fc\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.delete_field","title":"<code>delete_field(fieldname)</code>","text":"<p>Delete a field from a Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>fieldname</code> <code>str</code> <p>The name of the field to delete/drop</p> required Example <pre><code>&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name', 'year', 'month']\n\n&gt;&gt;&gt; del fc['month']\n&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name', 'year']\n&gt;&gt;&gt; fc.delete_field('year')\n&gt;&gt;&gt; print(fc.fields)\n['OID@', 'SHAPE@', 'name']\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def delete_field(self, fieldname: str) -&gt; None:\n    \"\"\"Delete a field from a Table or FeatureClass\n\n    Args:\n        fieldname (str): The name of the field to delete/drop\n\n    Example:\n        ```python\n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name', 'year', 'month']\n\n        &gt;&gt;&gt; del fc['month']\n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name', 'year']\n        &gt;&gt;&gt; fc.delete_field('year')\n        &gt;&gt;&gt; print(fc.fields)\n        ['OID@', 'SHAPE@', 'name']\n        ```\n    \"\"\"\n    if fieldname in self.Tokens:\n        raise ValueError(f\"{fieldname} is a Token and cannot be deleted!\")\n    if not self.has_field(fieldname):\n        raise ValueError(f\"{fieldname} does not exist in {self.name}\")\n    with EnvManager(workspace=self.workspace):\n        DeleteField(self.path, fieldname)\n        self._fields = None # Defer new field check to next access\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.delete_fields","title":"<code>delete_fields(fieldnames)</code>","text":"Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def delete_fields(self, fieldnames: Iterable[FieldName]) -&gt; None:\n    for fname in fieldnames:\n        self.delete_field(fname)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.delete_identical","title":"<code>delete_identical(field_names)</code>","text":"<p>Delete all records that have matching field values</p> <p>Parameters:</p> Name Type Description Default <code>field_names</code> <code>Sequence[FieldName] | FieldName</code> <p>The fields used to define an identical feature</p> required <p>Returns:</p> Type Description <code>dict[int, int]</code> <p>A dictionary of count of identical features deleted per feature</p> Note <p>Insertion order takes precidence unless the Table or FeatureClass is ordered. The first feature found by the cursor will be maintained and all subsequent matches will be removed</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def delete_identical(self, field_names: Iterable[FieldName] | FieldName) -&gt; dict[int, int]:\n    \"\"\"Delete all records that have matching field values\n\n    Args:\n        field_names (Sequence[FieldName] | FieldName): The fields used to define an identical feature\n\n    Returns:\n        (dict[int, int]): A dictionary of count of identical features deleted per feature\n\n    Note:\n        Insertion order takes precidence unless the Table or FeatureClass is ordered. The first feature found\n        by the cursor will be maintained and all subsequent matches will be removed\n    \"\"\"\n    # All\n    if isinstance(field_names, str):\n        field_names = [field_names]\n\n    unique: dict[int, tuple[Any]] = {}\n    deleted: dict[int, int] = {}\n    with self.update_cursor('OID@', *field_names) as cur:\n        for row in cur:\n            oid: int = row[0]\n            row = tuple(row[1:])\n            for match_id, match_row in unique.items():\n                if all(a == b for a, b in zip(row, match_row)):\n                    match = match_id\n                    break\n            else:\n                match = False\n\n            if not match:\n                unique[oid] = row\n\n            else:\n                deleted.setdefault(match, 0)\n                deleted[match] += 1\n                cur.deleteRow()\n    return deleted\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.delete_where","title":"<code>delete_where(clause)</code>","text":"<p>Delete all records that match the provided where clause</p> <p>Parameters:</p> Name Type Description Default <code>clause</code> <code>WhereClause | str</code> <p>The SQL query that determines the records that will be deleted</p> required Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def delete_where(self, clause: WhereClause|str) -&gt; None:\n    \"\"\"Delete all records that match the provided where clause\n\n    Args:\n        clause (WhereClause|str): The SQL query that determines the records that will be deleted\n    \"\"\"\n    with self.where(clause):\n        self.clear()\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.distinct","title":"<code>distinct(distinct_fields)</code>","text":"<p>Yield rows of distinct values</p> <p>Parameters:</p> Name Type Description Default <code>distinct_fields</code> <code>FieldOpt</code> <p>The field or fields to find distinct values for. Choosing multiple fields will find all distinct instances of those field combinations</p> required <p>Yields:</p> Type Description <code> tuple[Any, ...] </code> <p>A tuple containing the distinct values (single fields will yield <code>(value, )</code> tuples)</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def distinct(self, distinct_fields: Iterable[FieldName] | FieldName) -&gt; Iterator[tuple[Any, ...]]:\n    \"\"\"Yield rows of distinct values\n\n    Args:\n        distinct_fields (FieldOpt): The field or fields to find distinct values for.\n            Choosing multiple fields will find all distinct instances of those field combinations\n\n    Yields:\n        ( tuple[Any, ...] ): A tuple containing the distinct values (single fields will yield `(value, )` tuples)\n    \"\"\"\n    clause = SQLClause(prefix=f'DISTINCT {format_query_list(distinct_fields)}', postfix=None)\n    try:\n        yield from (value for value in self.search_cursor(*distinct_fields, sql_clause=clause))\n    except RuntimeError: # Fallback when DISTINCT is not available or fails with Token input\n        yield from sorted(set(self.get_tuples(distinct_fields)))\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.exists","title":"<code>exists()</code>","text":"<p>Check if the Table or FeatureClass actually exists (check for deletion or initialization with bad path)</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"Check if the Table or FeatureClass actually exists (check for deletion or initialization with bad path)\"\"\"\n    return Exists(str(self))\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.fields_as","title":"<code>fields_as(*fields)</code>","text":"<p>Override the default fields for the Table or FeatureClass so all non-explicit Iterators will only yield these fields (e.g. <code>for row in fc: ...</code>)</p> <p>Parameters:</p> Name Type Description Default <code>*fields</code> <code>FieldName</code> <p>Varargs of the fieldnames to limit all unspecified Iterators to</p> <code>()</code> Example <pre><code>&gt;&gt;&gt; with fc.fields_as('OID@', 'NAME'):\n...     for row in fc:\n...         print(row)\n{'OID@': 1, 'NAME': 'John'}\n{'OID@': 2, 'NAME': 'Michael'}\n...\n&gt;&gt;&gt; for row in fc:\n...     print(row)\n{'OID@': 1, 'NAME': 'John', 'AGE': 75, 'ADDRESS': 123 Silly Walk}\n{'OID@': 2, 'NAME': 'Michael', 'AGE': 70, 'ADDRESS': 42 Dead Parrot Blvd}\n...\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef fields_as(self, *fields: FieldName):\n    \"\"\"Override the default fields for the Table or FeatureClass so all non-explicit Iterators will\n    only yield these fields (e.g. `for row in fc: ...`)\n\n    Args:\n        *fields (FieldName): Varargs of the fieldnames to limit all unspecified Iterators to\n\n    Example:\n        ```python\n        &gt;&gt;&gt; with fc.fields_as('OID@', 'NAME'):\n        ...     for row in fc:\n        ...         print(row)\n        {'OID@': 1, 'NAME': 'John'}\n        {'OID@': 2, 'NAME': 'Michael'}\n        ...\n        &gt;&gt;&gt; for row in fc:\n        ...     print(row)\n        {'OID@': 1, 'NAME': 'John', 'AGE': 75, 'ADDRESS': 123 Silly Walk}\n        {'OID@': 2, 'NAME': 'Michael', 'AGE': 70, 'ADDRESS': 42 Dead Parrot Blvd}\n        ...\n        ```\n    \"\"\"\n    # Allow passing a single field as a string `fc.fields_as('OID@')` to maintain\n    # The call format of *Cursor objects\n    _fields = self.fields\n    self._fields = tuple(fields)\n    try:\n        yield self\n    finally:\n        self._fields = _fields\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.filter","title":"<code>filter(func, invert=False)</code>","text":"<p>Apply a function filter to rows in the Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[dict[str, Any]], bool]</code> <p>A callable that takes a  row dictionary and returns True or False</p> required <code>invert</code> <code>bool</code> <p>Invert the function. Only yield rows that return <code>False</code></p> <code>False</code> <p>Yields:</p> Type Description <code> dict[str, Any] </code> <p>Rows in the Table or FeatureClass that match the filter (or inverted filter)</p> Example <pre><code>&gt;&gt;&gt; def area_filter(row: dict) -&gt; bool:\n&gt;&gt;&gt;     return row['Area'] &gt;= 10\n\n&gt;&gt;&gt; for row in fc:\n&gt;&gt;&gt;     print(row['Area'])\n1\n2\n10\n&lt;etc&gt;\n\n&gt;&gt;&gt; for row in fc.filter(area_filter):\n&gt;&gt;&gt;     print(row['Area'])\n10\n11\n90\n&lt;etc&gt;\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def filter(self, func: FilterFunc[_Schema], invert: bool=False) -&gt; Iterator[_Schema]:\n    \"\"\"Apply a function filter to rows in the Table or FeatureClass\n\n    Args:\n        func (Callable[[dict[str, Any]], bool]): A callable that takes a \n            row dictionary and returns True or False\n        invert (bool): Invert the function. Only yield rows that return `False`\n\n    Yields:\n        ( dict[str, Any] ): Rows in the Table or FeatureClass that match the filter (or inverted filter)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; def area_filter(row: dict) -&gt; bool:\n        &gt;&gt;&gt;     return row['Area'] &gt;= 10\n\n        &gt;&gt;&gt; for row in fc:\n        &gt;&gt;&gt;     print(row['Area'])\n        1\n        2\n        10\n        &lt;etc&gt;\n\n        &gt;&gt;&gt; for row in fc.filter(area_filter):\n        &gt;&gt;&gt;     print(row['Area'])\n        10\n        11\n        90\n        &lt;etc&gt;\n        ```\n\n    \"\"\"\n    if hasattr(func, 'fields'): # Allow decorated filters for faster iteration (see `filter_fields`)\n        with self.fields_as(*getattr(func, 'fields')):\n            yield from (row for row in self if func(row) == (not invert))\n    else:\n        yield from (row for row in self if func(row) == (not invert))\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.from_layer","title":"<code>from_layer(layer, *, ignore_selection=False, ignore_def_query=False)</code>  <code>classmethod</code>","text":"<p>Build a Table or FeatureClass object from a layer applying the layer's current selection to the stored cursors</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>Layer</code> <p>The layer to convert to a Table or FeatureClass</p> required <code>ignore_selection</code> <code>bool</code> <p>Ignore the layer selection (default: False)</p> <code>False</code> <code>ignore_def_query</code> <code>bool</code> <p>Ignore the layer definition query (default: False)</p> <code>False</code> <p>Returns:     ( Table or FeatureClass ): The Table or FeatureClass object with the layer query applied</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@classmethod\ndef from_layer(cls, layer: Layer,\n               *,\n               ignore_selection: bool = False,\n               ignore_def_query: bool = False,) -&gt; Table[Any]:\n    \"\"\"Build a Table or FeatureClass object from a layer applying the layer's current selection to the stored cursors\n\n    Args:\n        layer (Layer): The layer to convert to a Table or FeatureClass\n        ignore_selection (bool): Ignore the layer selection (default: False)\n        ignore_def_query (bool): Ignore the layer definition query (default: False)\n    Returns:\n        ( Table or FeatureClass ): The Table or FeatureClass object with the layer query applied\n    \"\"\"\n    fc = cls(Path(layer.dataSource).resolve())\n\n    selected_ids: set[int] | None = (\n        layer.getSelectionSet() or None\n        if not ignore_selection \n        else None\n    )\n    definition_query: str|None = (\n        layer.definitionQuery or None\n        if not ignore_def_query \n        else None\n    )\n    selection: str|None = (\n        f\"{fc.oid_field_name} IN ({format_query_list(selected_ids)})\" \n        if selected_ids \n        else None\n    )\n\n    if (query_components := list(filter(None, [definition_query, selection]))):\n        where_clause = ' AND '.join(query_components)\n        fc.search_options = SearchOptions(where_clause=where_clause)\n        fc.update_options = UpdateOptions(where_clause=where_clause)\n\n    fc.layer = layer\n    return fc\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.from_table","title":"<code>from_table(table, *, ignore_selection=False, ignore_def_query=False)</code>  <code>classmethod</code>","text":"<p>See <code>from_layer</code> for documentation, this is an alternative constructor that builds from a mp.Table object</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@classmethod\ndef from_table(cls, table: TableLayer,\n               *,\n               ignore_selection: bool = False,\n               ignore_def_query: bool = False,) -&gt; Table:\n    \"\"\"See `from_layer` for documentation, this is an alternative constructor that builds from a mp.Table object\"\"\"\n    return Table.from_layer(table, ignore_selection=ignore_selection, ignore_def_query=ignore_def_query) # type: ignore (this won't break the interface)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.get","title":"<code>get(field, default=None)</code>","text":"<pre><code>get(\n    field: tuple[FieldName, ...], default: _T\n) -&gt; Iterator[tuple[Any, ...]] | _T\n</code></pre><pre><code>get(\n    field: list[FieldName], default: _T\n) -&gt; Iterator[list[Any]] | _T\n</code></pre><pre><code>get(\n    field: set[FieldName], default: _T\n) -&gt; Iterator[_Schema] | _T\n</code></pre><pre><code>get(field: FieldName, default: _T) -&gt; Iterator[Any] | _T\n</code></pre><pre><code>get(\n    field: FilterFunc[_Schema], default: _T\n) -&gt; Iterator[_Schema] | _T\n</code></pre><pre><code>get(\n    field: WhereClause, default: _T\n) -&gt; Iterator[_Schema] | _T\n</code></pre><pre><code>get(field: None, default: _T) -&gt; Iterator[None] | _T\n</code></pre> <p>Allow accessing the implemented indexes defined by <code>__getitem__</code> with a default shielding a raised <code>KeyError</code></p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>_Indexable_Types</code> <p>The index to check (see <code>__getitem__</code> implementations)</p> required <code>default</code> <code>_T</code> <p>A default to return when the indexing raises a <code>KeyError</code> or cursor field <code>RuntimeError</code> (default: None)</p> <code>None</code> Example <pre><code>&gt;&gt;&gt; for name, age in fc[('Name', 'Age')]:\n&gt;&gt;&gt;     print(name, age)\n...\nKeyError \"Name\"\n...\n\n&gt;&gt;&gt; for name, age in fc.get(('Name', 'Age'), [])\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def get(self, field: _IndexableTypes | FilterFunc[_Schema], default: _T=None) -&gt; Iterator[Any] | _T:\n    \"\"\"Allow accessing the implemented indexes defined by `__getitem__` with a default shielding a raised `KeyError`\n\n    Args:\n        field (_Indexable_Types): The index to check (see `__getitem__` implementations)\n        default (_T): A default to return when the indexing raises a `KeyError` or cursor field `RuntimeError` (default: None)\n\n    Example:\n        ```python\n        &gt;&gt;&gt; for name, age in fc[('Name', 'Age')]:\n        &gt;&gt;&gt;     print(name, age)\n        ...\n        KeyError \"Name\"\n        ...\n\n        &gt;&gt;&gt; for name, age in fc.get(('Name', 'Age'), [])\n        ```\n\n    \"\"\"\n    try:\n        return self[field]\n    except (KeyError , RuntimeError) as e:\n        if isinstance(e, RuntimeError) and 'Cannot find field' not in str(e):\n            raise # Raise any non field related RuntimeErrors\n        return default\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.get_records","title":"<code>get_records(field_names, **options)</code>","text":"<p>Generate row dicts with in the form <code>{field: value, ...}</code> for each row in the cursor</p> <p>Parameters:</p> Name Type Description Default <code>field_names</code> <code>str | Iterable[str]</code> <p>The columns to iterate</p> required <code>**options</code> <code>Unpack[SearchOptions]</code> <p>Additional options to pass on to the cursor</p> <code>{}</code> <p>Yields      ( dict[str, Any] ): A mapping of fieldnames to field values for each row</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def get_records(self, field_names: Iterable[FieldName] | FieldName, **options: Unpack[SearchOptions]) -&gt; Iterator[_Schema]:\n    \"\"\"Generate row dicts with in the form `{field: value, ...}` for each row in the cursor\n\n    Args:\n        field_names (str | Iterable[str]): The columns to iterate\n        **options (Unpack[SearchOptions]): Additional options to pass on to the cursor\n    Yields \n        ( dict[str, Any] ): A mapping of fieldnames to field values for each row\n    \"\"\"\n    with self.search_cursor(*field_names, **options) as cur:\n        yield from self.as_dict(cur)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.get_tuples","title":"<code>get_tuples(field_names, **options)</code>","text":"<p>Generate tuple rows in the for (val1, val2, ...) for each row in the cursor</p> <p>Parameters:</p> Name Type Description Default <code>field_names</code> <code>str | Iterable[str]</code> <p>The columns to iterate</p> required <code>**options</code> <code>SearchOptions</code> <p>Additional parameters to pass to the SearchCursor</p> <code>{}</code> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def get_tuples(self, field_names: Iterable[FieldName] | FieldName, **options: Unpack[SearchOptions]) -&gt; Iterator[tuple[Any, ...]]:\n    \"\"\"Generate tuple rows in the for (val1, val2, ...) for each row in the cursor\n\n    Args:\n        field_names (str | Iterable[str]): The columns to iterate\n        **options (SearchOptions): Additional parameters to pass to the SearchCursor\n    \"\"\"\n    with self.search_cursor(*field_names, **options) as cur:\n        yield from cur\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.group_by","title":"<code>group_by(group_fields, return_fields='*')</code>","text":"<p>Group features by matching field values and yield full records in groups</p> <p>Parameters:</p> Name Type Description Default <code>group_fields</code> <code>FieldOpt</code> <p>The fields to group the data by</p> required <code>return_fields</code> <code>FieldOpt</code> <p>The fields to include in the output record (<code>'*'</code> means all and is default)</p> <code>'*'</code> <p>Yields:     ( Iterator[tuple[tuple[FieldName, ...], Iterator[tuple[Any, ...] | Any]]] ): A nested iterator of groups and then rows</p> Example <pre><code>&gt;&gt;&gt; # With a field group, you will be able to unpack the tuple\n&gt;&gt;&gt; for group, rows in fc.group_by(['GroupField1', 'GroupField2'], ['ValueField1', 'ValueField2', ...]):\n...     print(group)\n...     for v1, v2 in rows:\n...        if v1 &gt; 10:\n...            print(v2)\n(GroupValue1A, GroupValue1B)\nvalueA\nvalueB\n...\n&gt;&gt;&gt; # With a single field, you will have direct access to the field values   \n&gt;&gt;&gt; for group, district_populations in fc.group_by(['City', 'State'], 'Population'):\n&gt;&gt;&gt;         print(f\"{group}: {sum(district_populations)}\")\n(New York, NY): 8260000\n(Boston, MA): 4941632\n...\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def group_by(self, group_fields: Sequence[FieldName] | FieldName, return_fields: Sequence[FieldName] | FieldName ='*') -&gt; Iterator[tuple[GroupIdent, GroupIter]]:\n    \"\"\"Group features by matching field values and yield full records in groups\n\n    Args:\n        group_fields (FieldOpt): The fields to group the data by\n        return_fields (FieldOpt): The fields to include in the output record (`'*'` means all and is default)\n    Yields:\n        ( Iterator[tuple[tuple[FieldName, ...], Iterator[tuple[Any, ...] | Any]]] ): A nested iterator of groups and then rows\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # With a field group, you will be able to unpack the tuple\n        &gt;&gt;&gt; for group, rows in fc.group_by(['GroupField1', 'GroupField2'], ['ValueField1', 'ValueField2', ...]):\n        ...     print(group)\n        ...     for v1, v2 in rows:\n        ...        if v1 &gt; 10:\n        ...            print(v2)\n        (GroupValue1A, GroupValue1B)\n        valueA\n        valueB\n        ...\n        &gt;&gt;&gt; # With a single field, you will have direct access to the field values   \n        &gt;&gt;&gt; for group, district_populations in fc.group_by(['City', 'State'], 'Population'):\n        &gt;&gt;&gt;         print(f\"{group}: {sum(district_populations)}\")\n        (New York, NY): 8260000\n        (Boston, MA): 4941632\n        ...\n        ```\n    \"\"\"\n\n    # Parameter Validations\n    if isinstance(group_fields, str):\n        group_fields = (group_fields,)\n    if return_fields == '*':\n        return_fields = self.fields\n    if isinstance(return_fields, str):\n        return_fields = (return_fields,)\n    if len(group_fields) &lt; 1 or len(return_fields) &lt; 1:\n        raise ValueError(\"Group Fields and Return Fields must be populated\")\n\n    group_fields = list(group_fields)\n    return_fields = list(return_fields)\n    _all_fields = group_fields + return_fields\n    for group in self.distinct(group_fields):\n        group_key = {field : value for field, value in zip(group_fields, group)}\n        where_clause = \" AND \".join(f\"{field} = {norm(value)}\" for field, value in group_key.items())\n        if '@' not in where_clause: # Handle valid clause (no tokens)\n            with self.search_cursor(*return_fields, where_clause=where_clause) as group_cur:\n                yield (extract_singleton(group), (extract_singleton(row) for row in group_cur))\n        else: # Handle token being passed by iterating a cursor and checking values directly\n            for row in filter(lambda row: all(row[k] == group_key[k] for k in group_key), self[set(_all_fields)]):\n                yield (extract_singleton(group), (row.pop(k) for k in return_fields)) # type: ignore (TypedDict Generic causes issues)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.has_field","title":"<code>has_field(fieldname)</code>","text":"<p>Check if the field exists in the featureclass or is a valid Token (@[TOKEN])</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def has_field(self, fieldname: str) -&gt; bool:\n    \"\"\"Check if the field exists in the featureclass or is a valid Token (@[TOKEN])\"\"\"\n    return fieldname in self.fields or fieldname in self.Tokens\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.insert_cursor","title":"<code>insert_cursor(*field_names, insert_options=None, **overrides)</code>","text":"<p>See <code>Table.search_cursor</code> doc for general info. Operation of this method is identical but returns an <code>InsertCursor</code></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def insert_cursor(self, *field_names: FieldName,\n                  insert_options: InsertOptions|None=None, \n                  **overrides: Unpack[InsertOptions]) -&gt; InsertCursor:\n    \"\"\"See `Table.search_cursor` doc for general info. Operation of this method is identical but returns an `InsertCursor`\"\"\"\n    if 'datum_transformation' in overrides and overrides['datum_transformation'] is None:\n        overrides.pop('datum_transformation')\n    if insert_options and 'datum_transformation' in insert_options and insert_options['datum_transformation'] is None:\n        insert_options.pop('datum_transformation')\n    return InsertCursor(self.path, field_names, **self._resolve_insert_options(insert_options, overrides))\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.insert_record","title":"<code>insert_record(record, ignore_errors=False)</code>","text":"<p>Insert a single record into the table</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def insert_record(self, record: _Schema, ignore_errors: bool=False) -&gt; int | None:\n    \"\"\"Insert a single record into the table\"\"\"\n    if missing_fields := set(record.keys()).difference(self.fields):\n        if ignore_errors:\n            return None\n        else:\n            raise ValueError(f'{missing_fields} not in {self.fields}')\n    with self.insert_cursor(*record.keys()) as cur:\n        return cur.insertRow(list(record.values()))\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.insert_records","title":"<code>insert_records(records, ignore_errors=False)</code>","text":"<p>Provide an iterable of records to insert Args:     records (Iterable[RowRecord]): The sequence of records to insert     ignore_errors (bool): Ignore per-row errors and continue. Otherwise raise KeyError (default: True)</p> <p>Returns:</p> Type Description <code> Iterator[int] </code> <p>Returns the OIDs of the newly inserted rows</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the records have varying keys or the keys are not in the Table or FeatureClass</p> Example <pre><code>&gt;&gt;&gt; new_rows = [\n...    {'first': 'John', 'last': 'Cleese', 'year': 1939}, \n...    {'first': 'Michael', 'last': 'Palin', 'year': 1943}\n... ]\n&gt;&gt;&gt; print(fc.insert_rows(new_rows))\n(2,3)\n\n&gt;&gt;&gt; # Insert all shapes from fc into fc2\n&gt;&gt;&gt; fc2.insert_rows(fc.get_records(['first', 'last', 'year']))\n(1,2)\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def insert_records(self, records: Iterable[_Schema] , ignore_errors: bool=False) -&gt; Iterator[int]:\n    \"\"\"Provide an iterable of records to insert\n    Args:\n        records (Iterable[RowRecord]): The sequence of records to insert\n        ignore_errors (bool): Ignore per-row errors and continue. Otherwise raise KeyError (default: True)\n\n    Returns:\n        ( Iterator[int] ): Returns the OIDs of the newly inserted rows\n\n    Raises:\n        ( KeyError ): If the records have varying keys or the keys are not in the Table or FeatureClass\n\n    Example:\n        ```python\n        &gt;&gt;&gt; new_rows = [\n        ...    {'first': 'John', 'last': 'Cleese', 'year': 1939}, \n        ...    {'first': 'Michael', 'last': 'Palin', 'year': 1943}\n        ... ]\n        &gt;&gt;&gt; print(fc.insert_rows(new_rows))\n        (2,3)\n\n        &gt;&gt;&gt; # Insert all shapes from fc into fc2\n        &gt;&gt;&gt; fc2.insert_rows(fc.get_records(['first', 'last', 'year']))\n        (1,2)\n        ```\n    \"\"\"\n    yield from filter(None, (self.insert_record(record, ignore_errors=ignore_errors) for record in records))\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.options","title":"<code>options(*, strict=False, search_options=None, update_options=None, insert_options=None, clause=None)</code>","text":"<p>Enter a context block where the supplied options replace the stored options for the <code>Table</code> or <code>FeatureClass</code></p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If this is set to <code>True</code> the <code>Table</code> or <code>FeatureClass</code> will not fallback on existing options when set to <code>False</code>, provided options override existing options (default: <code>False</code>)</p> <code>False</code> <code>search_options</code> <code>SearchOptions</code> <p>Contextual search overrides</p> <code>None</code> <code>update_options</code> <code>UpdateOptions</code> <p>Contextual update overrides</p> <code>None</code> <code>insert_options</code> <code>InsertOptions</code> <p>Contextual insert overrides</p> <code>None</code> <code>clause</code> <code>SQLClause</code> <p>Contextual <code>sql_clause</code> override</p> <code>None</code> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef options(self,\n            *, \n            strict: bool = False,\n            search_options: SearchOptions|None=None, \n            update_options: UpdateOptions|None=None, \n            insert_options: InsertOptions|None=None, \n            clause: SQLClause|None=None):\n    \"\"\"Enter a context block where the supplied options replace the stored options for the `Table` or `FeatureClass`\n\n    Args:\n        strict (bool): If this is set to `True` the `Table` or `FeatureClass` will not fallback on existing options\n            when set to `False`, provided options override existing options (default: `False`)\n        search_options (SearchOptions): Contextual search overrides\n        update_options (UpdateOptions): Contextual update overrides\n        insert_options (InsertOptions): Contextual insert overrides\n        clause (SQLClause): Contextual `sql_clause` override\n    \"\"\"\n    _src_ops = self.search_options\n    _upd_ops = self.update_options\n    _ins_ops = self.insert_options\n    _clause  = self.clause\n    try:\n        self._search_options = (\n            self._resolve_search_options(_src_ops, search_options or {}) \n            if not strict\n            else search_options or SearchOptions()\n        )\n        self._update_options = (\n            self._resolve_update_options(_upd_ops, update_options or {})\n            if not strict \n            else insert_options or UpdateOptions()\n        )\n        self._insert_options = (\n            self._resolve_insert_options(_ins_ops, insert_options or {})\n            if not strict \n            else insert_options or InsertOptions()\n        )\n        self._clause = (\n            clause or _clause\n            if not strict \n            else SQLClause(None, None)\n        )\n        yield self\n\n    finally:\n        self._search_options = _src_ops\n        self._update_options = _upd_ops\n        self.insert_options = _ins_ops\n        self._clause = _clause\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.row_updater","title":"<code>row_updater(*field_names, strict=False, update_options=None, **overrides)</code>","text":"<p>A Bi-Directional generator that yields rows and updates them with the sent value</p> Note <p>This method will assume the full provided schema if there is one, so make sure you keep track of any applied field filters.</p> <p>Parameters:</p> Name Type Description Default <code>field_names</code> <code>FieldName | str</code> <p>The fields to include in the update operation (default: All)</p> <code>()</code> <code>strict</code> <code>bool</code> <p>Raise a KeyError if an invalid fieldname is passed, otherwise drop invalid updates (default: False)</p> <code>False</code> <code>update_options</code> <code>UpdateOptions</code> <p>Additional context to pass to the UpdateCursor as a dictionary</p> <code>None</code> <code>**overrides</code> <code>UpdateOptions</code> <p>Additional context to pass to the UpdateCursor as keyword arguments</p> <code>{}</code> Example <pre><code>&gt;&gt;&gt; updater = fc.row_updater()\n&gt;&gt;&gt; for row in updater:\n...     if row['Name'] = 'No Name':\n...         row['Name'] = None\n...         updater.send(row)\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def row_updater(self, *field_names: FieldName,\n                strict: bool=False,\n                update_options: UpdateOptions|None=None, \n                **overrides: Unpack[UpdateOptions]) -&gt; Generator[_Schema, _Schema|None, None]:\n    \"\"\"A Bi-Directional generator that yields rows and updates them with the sent value\n\n    Note:\n        This method will assume the full provided schema if there is one, so make sure you keep track of\n        any applied field filters.\n\n    Args:\n        field_names (FieldName|str): The fields to include in the update operation (default: All)\n        strict (bool): Raise a KeyError if an invalid fieldname is passed, otherwise drop invalid updates (default: False)\n        update_options (UpdateOptions): Additional context to pass to the UpdateCursor as a dictionary\n        **overrides (UpdateOptions): Additional context to pass to the UpdateCursor as keyword arguments\n\n    Example:\n        ```python\n        &gt;&gt;&gt; updater = fc.row_updater()\n        &gt;&gt;&gt; for row in updater:\n        ...     if row['Name'] = 'No Name':\n        ...         row['Name'] = None\n        ...         updater.send(row)\n        ```\n    \"\"\"\n    with self.update_cursor(*(field_names or self.fields), update_options=update_options, **overrides) as cur:\n        for row in self.as_dict(cur):\n            upd = yield row\n            if strict and (invalid := set(upd or []) - set(row)):\n                raise KeyError(f'{invalid} fields not found in {self.name}')\n            if upd is not None:\n                cur.updateRow([upd.get(f, row[f]) for f in cur.fields])\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.search_cursor","title":"<code>search_cursor(*field_names, search_options=None, **overrides)</code>","text":"<p>Get a <code>SearchCursor</code> for the <code>Table</code> or <code>FeatureClass</code> Supplied search options are resolved by updating the base <code>Table</code> or <code>FeatureClass</code> Search options in this order:</p> <p><code>**overrides['kwarg'] -&gt; search_options['kwarg'] -&gt; self.search_options['kwarg']</code></p> <p>This is implemented using unpacking operations with the lowest importance option set being unpacked first</p> <p><code>{**self.search_options, **(search_options or {}), **overrides}</code></p> <p>With direct key word arguments (<code>**overrides</code>) shadowing all other supplied options. This allows a FeatureClass to be initialized using a base set of options, then a shared SearchOptions set to be applied in some contexts, then a direct keyword override to be supplied while never mutating the base options of the FeatureClass.</p> <p>Parameters:</p> Name Type Description Default <code>field_names</code> <code>str | Iterable[str]</code> <p>The column names to include from the <code>Table</code> or <code>FeatureClass</code></p> <code>()</code> <code>search_options</code> <code>SearchOptions | None</code> <p>A <code>SeachOptions</code> instance that will be used to shadow <code>search_options</code> set on the <code>Table</code> or <code>FeatureClass</code></p> <code>None</code> <code>**overrides</code> <code>Unpack[SeachOptions]</code> <p>Additional keyword arguments for the cursor that shadow  both the <code>seach_options</code> variable and the <code>Table</code> or <code>FeatureClass</code> instance <code>SearchOptions</code></p> <code>{}</code> <p>Returns:</p> Type Description <code> SearchCursor </code> <p>A <code>SearchCursor</code> for the <code>Table</code> or <code>FeatureClass</code> instance that has all supplied options resolved and applied</p> Example <pre><code>    &gt;&gt;&gt; cleese_search = SearchOptions(where_clause=\"NAME = 'John Cleese'\")\n    &gt;&gt;&gt; idle_search = SearchOptions(where_clause=\"NAME = 'Eric Idle'\")\n    &gt;&gt;&gt; monty = Table or FeatureClass('&lt;path&gt;', search_options=cleese_search)\n    &gt;&gt;&gt; print(list(monty.search_cursor('NAME')))\n    [('John Cleese',)]\n    &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)))\n    [('Eric Idle', )]\n    &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)), where_clause=\"NAME = Graham Chapman\")\n    [('Graham Chapman', )]\n</code></pre> <p>In this example, you can see that the keyword override is the most important. The fact that the other searches are created outside initialization allows you to store common queries in one place and update them for all cursors using  them at the same time, while still allowing specific instances of a cursor to override those shared/stored defaults.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def search_cursor(self, *field_names: FieldName,\n                  search_options: SearchOptions|None=None, \n                  **overrides: Unpack[SearchOptions]) -&gt; SearchCursor:\n    \"\"\"Get a `SearchCursor` for the `Table` or `FeatureClass`\n    Supplied search options are resolved by updating the base `Table` or `FeatureClass` Search options in this order:\n\n    `**overrides['kwarg'] -&gt; search_options['kwarg'] -&gt; self.search_options['kwarg']`\n\n    This is implemented using unpacking operations with the lowest importance option set being unpacked first\n\n    `{**self.search_options, **(search_options or {}), **overrides}`\n\n    With direct key word arguments (`**overrides`) shadowing all other supplied options. This allows a FeatureClass to\n    be initialized using a base set of options, then a shared SearchOptions set to be applied in some contexts,\n    then a direct keyword override to be supplied while never mutating the base options of the FeatureClass.\n\n    Args:\n        field_names (str | Iterable[str]): The column names to include from the `Table` or `FeatureClass`\n        search_options (SearchOptions|None): A `SeachOptions` instance that will be used to shadow\n            `search_options` set on the `Table` or `FeatureClass`\n        **overrides ( Unpack[SeachOptions] ): Additional keyword arguments for the cursor that shadow \n            both the `seach_options` variable and the `Table` or `FeatureClass` instance `SearchOptions`\n\n    Returns:\n        ( SearchCursor ): A `SearchCursor` for the `Table` or `FeatureClass` instance that has all supplied options\n            resolved and applied\n\n    Example:\n        ```python\n            &gt;&gt;&gt; cleese_search = SearchOptions(where_clause=\"NAME = 'John Cleese'\")\n            &gt;&gt;&gt; idle_search = SearchOptions(where_clause=\"NAME = 'Eric Idle'\")\n            &gt;&gt;&gt; monty = Table or FeatureClass('&lt;path&gt;', search_options=cleese_search)\n            &gt;&gt;&gt; print(list(monty.search_cursor('NAME')))\n            [('John Cleese',)]\n            &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)))\n            [('Eric Idle', )]\n            &gt;&gt;&gt; print(list(monty.search_cursor('NAME', search_options=idle_search)), where_clause=\"NAME = Graham Chapman\")\n            [('Graham Chapman', )]\n        ```\n    In this example, you can see that the keyword override is the most important. The fact that the other searches are\n    created outside initialization allows you to store common queries in one place and update them for all cursors using \n    them at the same time, while still allowing specific instances of a cursor to override those shared/stored defaults.\n    \"\"\"\n    return SearchCursor(self.path, field_names, **self._resolve_search_options(search_options, overrides))\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.select","title":"<code>select(method='NEW')</code>","text":"<p>If the Table or FeatureClass is bound to a layer, update the layer selection with the active SearchOptions</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['NEW', 'DIFFERENCE', 'INTERSECT', 'SYMDIFFERENCE', 'UNION']</code> <p>The method to use to apply the selection</p> <p><code>DIFFERENCE</code>: Selects the features that are not in the current selection but are in the Table or FeatureClass.</p> <p><code>INTERSECT</code>: Selects the features that are in the current selection and the Table or FeatureClass.</p> <p><code>NEW</code>: Creates a new feature selection from the Table or FeatureClass.</p> <p><code>SYMDIFFERENCE</code>: Selects the features that are in the current selection or the Table or FeatureClass but not both.</p> <p><code>UNION</code>: Selects all the features in both the current selection and those in Table or FeatureClass.</p> <code>'NEW'</code> Note <p>Selection changes require the project file to be saved to take effect.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def select(self, method: Literal['NEW','DIFFERENCE','INTERSECT','SYMDIFFERENCE','UNION']='NEW') -&gt; None:\n    \"\"\"If the Table or FeatureClass is bound to a layer, update the layer selection with the active SearchOptions\n\n    Args:\n        method: The method to use to apply the selection\\n\n            `DIFFERENCE`: Selects the features that are not in the current selection but are in the Table or FeatureClass.\\n\n            `INTERSECT`: Selects the features that are in the current selection and the Table or FeatureClass.\\n\n            `NEW`: Creates a new feature selection from the Table or FeatureClass.\\n\n            `SYMDIFFERENCE`: Selects the features that are in the current selection or the Table or FeatureClass but not both.\\n\n            `UNION`: Selects all the features in both the current selection and those in Table or FeatureClass.\\n\n\n    Note:\n        Selection changes require the project file to be saved to take effect. \n    \"\"\"\n    if self.layer:\n        _selected = list(self['OID@'])\n        self.layer.setSelectionSet(_selected, method=method)\n        try: # Try to select the layer in the active map\n            if len(_selected) == 1:\n                _query = f'{self.oid_field_name} = {_selected.pop()})'\n            if len(_selected) &gt; 1:\n                _query = f'{self.oid_field_name} IN ({format_query_list(_selected)})'\n            else:\n                return\n            SelectLayerByAttribute(self.layer.longName, 'NEW_SELECTION', _query)\n        except Exception:\n            return\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.unselect","title":"<code>unselect()</code>","text":"<p>If the Table or FeatureClass is bound to a layer, Remove layer selection</p> Note <p>Selection changes require the project file to be saved to take effect.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def unselect(self) -&gt; None:\n    \"\"\"If the Table or FeatureClass is bound to a layer, Remove layer selection\n\n    Note:\n        Selection changes require the project file to be saved to take effect.\n    \"\"\"\n    if self.layer:\n        self.layer.setSelectionSet(method='NEW')\n        try: # Try to unselect the layer in the active map\n            SelectLayerByAttribute(self.layer.longName, 'CLEAR_SELECTION')\n        except Exception:\n            return\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.update_cursor","title":"<code>update_cursor(*field_names, update_options=None, **overrides)</code>","text":"<p>See <code>Table.search_cursor</code> doc for general info. Operation of this method is identical but returns an <code>UpdateCursor</code></p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def update_cursor(self, *field_names: FieldName,\n                update_options: UpdateOptions|None=None, \n                **overrides: Unpack[UpdateOptions]) -&gt; UpdateCursor:\n    \"\"\"See `Table.search_cursor` doc for general info. Operation of this method is identical but returns an `UpdateCursor`\"\"\"\n    if 'datum_transformation' in overrides and overrides['datum_transformation'] is None:\n        overrides.pop('datum_transformation')\n    if update_options and 'datum_transformation' in update_options and update_options['datum_transformation'] is None:\n        update_options.pop('datum_transformation')\n    return UpdateCursor(self.path, field_names, **self._resolve_update_options(update_options, overrides))\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.updater","title":"<code>updater(*fields, strict=False)</code>","text":"<p>A wrapper around <code>row_updater</code> that allows use as a context manager</p> <p>This simplifies the interaction with the <code>row_updater</code> method by allowing inline declaration of the generator. For most simple update operations, this manager should work well. </p> <p>Parameters:</p> Name Type Description Default <code>fields</code> <code>FieldName | str</code> <p>The fields to include in the update operation (default: All)</p> <code>()</code> <code>stict</code> <code>bool</code> <p>Raise a KeyError if an invalid fieldname is passed, otherwise drop invalid updates (default: False)</p> required Example <p>with fc.editor, fc.updater() as upd: ...     for row in upd: ...         row['Name'] = 'Dave' ...         upd.send(row)</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef updater(self, *fields: FieldName, strict: bool=False):\n    \"\"\"A wrapper around `row_updater` that allows use as a context manager\n\n    This simplifies the interaction with the `row_updater` method by allowing inline declaration\n    of the generator. For most simple update operations, this manager should work well. \n\n    Args:\n        fields (FieldName|str): The fields to include in the update operation (default: All)\n        stict (bool): Raise a KeyError if an invalid fieldname is passed, otherwise drop invalid updates (default: False)\n\n    Example:\n        &gt;&gt;&gt; with fc.editor, fc.updater() as upd:\n        ...     for row in upd:\n        ...         row['Name'] = 'Dave'\n        ...         upd.send(row)\n    \"\"\"\n    try:\n        yield self.row_updater(*(fields or self.fields), strict=strict)\n    finally:\n        pass\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.Table.where","title":"<code>where(where_clause)</code>","text":"<p>Apply a where clause to a Table or FeatureClass in a context</p> <p>Parameters:</p> Name Type Description Default <code>where_clause</code> <code>WhereClause | str</code> <p>The where clause to apply to the Table or FeatureClass</p> required Example <pre><code>&gt;&gt;&gt; with fc.where(\"first = 'John'\") as f:\n...     for f in fc:\n...         print(f)\n{'first': 'John', 'last': 'Cleese', 'year': 1939}\n\n&gt;&gt;&gt; with fc.where('year &gt; 1939'):\n...     print(len(fc))\n5\n... print(len(fc))\n6\n</code></pre> Note <p>This method of filtering a Table or FeatureClass will always be more performant than using the  <code>.filter</code> method. If you can achieve the filtering you want with a where clause, do it.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>@contextmanager\ndef where(self, where_clause: WhereClause|str):\n    \"\"\"Apply a where clause to a Table or FeatureClass in a context\n\n    Args:\n        where_clause (WhereClause|str): The where clause to apply to the Table or FeatureClass\n\n    Example:\n        ```python\n        &gt;&gt;&gt; with fc.where(\"first = 'John'\") as f:\n        ...     for f in fc:\n        ...         print(f)\n        {'first': 'John', 'last': 'Cleese', 'year': 1939}\n\n        &gt;&gt;&gt; with fc.where('year &gt; 1939'):\n        ...     print(len(fc))\n        5\n        ... print(len(fc))\n        6\n        ```\n\n    Note:\n        This method of filtering a Table or FeatureClass will always be more performant than using the \n        `.filter` method. If you can achieve the filtering you want with a where clause, do it.\n    \"\"\"\n    with self.options(\n        search_options=SearchOptions(where_clause=str(where_clause)),\n        update_options=UpdateOptions(where_clause=str(where_clause))):\n        yield self\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.as_dict","title":"<code>as_dict(cursor)</code>","text":"<p>Take a Cusrsor object and yield rows from it </p> <p>Parameters:</p> Name Type Description Default <code>cursor</code> <code>SearchCursor | UpdateCursor</code> <p>The cursor to convert to a RowRecord iterator</p> required <p>Yields:</p> Type Description <code>RowRecord</code> <p>Iterator[RowRecord]</p> Example <p>```python</p> <p>for row in as_dict(SearchCursor('table', ['Name', 'City'])) ...     print(f'{row[\"Name\"]} lives in {row[\"City\"]}') Dave lives in New York City Robert lives in Kansas City ...</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def as_dict(cursor: SearchCursor | UpdateCursor) -&gt; Iterator[RowRecord]:\n    \"\"\"Take a Cusrsor object and yield rows from it \n\n    Args:\n        cursor (SearchCursor | UpdateCursor): The cursor to convert to a RowRecord iterator\n\n    Yields:\n        Iterator[RowRecord]\n\n    Example:\n        ```python\n        &gt;&gt;&gt; for row in as_dict(SearchCursor('table', ['Name', 'City']))\n        ...     print(f'{row[\"Name\"]} lives in {row[\"City\"]}')\n        Dave lives in New York City\n        Robert lives in Kansas City\n        ...\n    \"\"\"\n    yield from (dict(zip(cursor.fields, row)) for row in cursor)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.count","title":"<code>count(featureclass)</code>","text":"<p>Get the record count of a FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>featureclass</code> <code>FeatureClass | Iterator</code> <p>The FeatureClass or Iterator/view to count</p> required Example <pre><code>&gt;&gt;&gt; fc = FeatureClass[PointGeometry]('MyFC')\n&gt;&gt;&gt; count(fc)\n1000\n&gt;&gt;&gt; count(fc[where('1=0')])\n0\n&gt;&gt;&gt; boundary = next(FeatureClass[Polygon]('Boundaries').shapes)\n&gt;&gt;&gt; count(fc[boundary])\n325\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def count(featureclass: FeatureClass | Iterator[Any]) -&gt; int:\n    \"\"\"Get the record count of a FeatureClass\n\n    Args:\n        featureclass (FeatureClass | Iterator): The FeatureClass or Iterator/view to count\n\n    Example:\n        ```python\n        &gt;&gt;&gt; fc = FeatureClass[PointGeometry]('MyFC')\n        &gt;&gt;&gt; count(fc)\n        1000\n        &gt;&gt;&gt; count(fc[where('1=0')])\n        0\n        &gt;&gt;&gt; boundary = next(FeatureClass[Polygon]('Boundaries').shapes)\n        &gt;&gt;&gt; count(fc[boundary])\n        325\n        ```\n    \"\"\"\n    # The __len__() method of FeatureClass only iterates\n    # object ID values so this is a small optimisation we can do\n    if isinstance(featureclass, FeatureClass):\n        return len(featureclass)\n\n    return sum(1 for _ in featureclass)\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.extract_singleton","title":"<code>extract_singleton(vals)</code>","text":"<p>Helper function to allow passing single values to arguments that expect a tuple</p> <p>Parameters:</p> Name Type Description Default <code>vals</code> <code>Sequence[Any] | Any</code> <p>The values to normalize based on item count</p> required <p>Returns:</p> Type Description <code> Sequence[Any] | Any  </code> <p>The normalized sequence</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def extract_singleton(vals: Sequence[Any] | Any) -&gt; Any | Sequence[Any]:\n    \"\"\"Helper function to allow passing single values to arguments that expect a tuple\n\n    Args:\n        vals (Sequence[Any] | Any): The values to normalize based on item count\n\n    Returns:\n        ( Sequence[Any] | Any  ): The normalized sequence\n    \"\"\"\n    # String sequences are returned directly\n    if isinstance(vals, str):\n        return vals\n\n    # Singleton sequences are flattened to the first value\n    if len(vals) == 1:\n        return vals[0]\n\n    # Default to returning the arg\n    return vals\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.filter_fields","title":"<code>filter_fields(*fields)</code>","text":"<p>Decorator for filter functions that limits fields checked by the SearchCursor</p> <p>Parameters:</p> Name Type Description Default <code>*fields</code> <code>FieldName</code> <p>Varargs for the fields to limit the filter to</p> <code>()</code> <p>Returns:</p> Type Description <code>FilterFunc</code> <p>A filter function with a <code>fields</code> attribute added</p> <code>Callable[[FilterFunc[RowRecord]], FilterFunc[RowRecord]]</code> <p>Used with FeatureClass.filter to limit columns</p> Note <p>Iterating filtered rows using a decorated filter will limit available columns inside the  context of the filter. This should only be used if you need to improve performance of a  filter and don't care about the fields not included in the <code>filter_fields</code> decorator:</p> <p>Example:     <pre><code>&gt;&gt;&gt; @filter_fields('Name', 'Age')\n&gt;&gt;&gt; def age_over_21(row):\n...     return row['Age'] &gt; 21\n...\n&gt;&gt;&gt; for row in feature_class[age_over_21]:\n...     print(row)\n...\n{'Name': 'John', 'Age': 23}\n{'Name': 'Terry', 'Age': 42}\n...\n&gt;&gt;&gt; for row in feature_class:\n...     print(row)\n...\n{'Name': 'John', 'LastName': 'Cleese', 'Age': 23}\n{'Name': 'Graham', 'LastName': 'Chapman', 'Age': 18}\n{'Name': 'Terry', 'LastName': 'Gilliam', 'Age': 42}\n...\n</code></pre></p> Note <p>You can achieve field filtering using the <code>FeatureClass.fields_as</code> context manager as well.  This method adds a level of indentation and can be more extensible:</p> <p>Example:     <pre><code>&gt;&gt;&gt; def age_over_21(row):\n...     return row['Age'] &gt; 21\n...\n&gt;&gt;&gt; with feature_class.fields_as('Name', 'Age'):\n...     for row in feature_class[age_over_21]:\n...         print(row)\n...\n{'Name': 'John', 'Age': 23}\n{'Name': 'Terry', 'Age': 42}\n</code></pre> Since the inspected fields live in the same code block as the filter that uses them, you can  easily add the fields in one place. This method is preferred for data manipulation operations  while counting operations can use the decorated filter to cut down on boilerplate.</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def filter_fields(*fields: FieldName) -&gt; Callable[[FilterFunc[RowRecord]], FilterFunc[RowRecord]]:\n    \"\"\"Decorator for filter functions that limits fields checked by the SearchCursor\n\n    Args:\n        *fields (FieldName): Varargs for the fields to limit the filter to\n\n    Returns:\n        (FilterFunc): A filter function with a `fields` attribute added\n        Used with FeatureClass.filter to limit columns\n\n    Note:\n        Iterating filtered rows using a decorated filter will limit available columns inside the \n        context of the filter. This should only be used if you need to improve performance of a \n        filter and don't care about the fields not included in the `filter_fields` decorator:\n\n        Example:\n            ```python\n            &gt;&gt;&gt; @filter_fields('Name', 'Age')\n            &gt;&gt;&gt; def age_over_21(row):\n            ...     return row['Age'] &gt; 21\n            ...\n            &gt;&gt;&gt; for row in feature_class[age_over_21]:\n            ...     print(row)\n            ...\n            {'Name': 'John', 'Age': 23}\n            {'Name': 'Terry', 'Age': 42}\n            ...\n            &gt;&gt;&gt; for row in feature_class:\n            ...     print(row)\n            ...\n            {'Name': 'John', 'LastName': 'Cleese', 'Age': 23}\n            {'Name': 'Graham', 'LastName': 'Chapman', 'Age': 18}\n            {'Name': 'Terry', 'LastName': 'Gilliam', 'Age': 42}\n            ...\n            ```\n\n    Note:\n        You can achieve field filtering using the `FeatureClass.fields_as` context manager as well. \n        This method adds a level of indentation and can be more extensible:\n\n        Example:\n            ```python\n            &gt;&gt;&gt; def age_over_21(row):\n            ...     return row['Age'] &gt; 21\n            ...\n            &gt;&gt;&gt; with feature_class.fields_as('Name', 'Age'):\n            ...     for row in feature_class[age_over_21]:\n            ...         print(row)\n            ...\n            {'Name': 'John', 'Age': 23}\n            {'Name': 'Terry', 'Age': 42}\n            ```\n        Since the inspected fields live in the same code block as the filter that uses them, you can \n        easily add the fields in one place. This method is preferred for data manipulation operations \n        while counting operations can use the decorated filter to cut down on boilerplate.\n    \"\"\"\n    def _filter_wrapper(func: FilterFunc):\n        setattr(func, 'fields', fields)\n        return func\n    return _filter_wrapper\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.format_query_list","title":"<code>format_query_list(vals)</code>","text":"<p>Format a list of values into a SQL list</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def format_query_list(vals: Iterable[Any]) -&gt; str:\n    \"\"\"Format a list of values into a SQL list\"\"\"\n    if isinstance(vals, (str , int)):\n        return f\"{vals}\"\n    return ','.join([f\"{val}\" for val in vals])\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.norm","title":"<code>norm(val)</code>","text":"<p>Normalize a value for SQL query (wrap strings in single quotes)</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def norm(val: Any) -&gt; str:\n    \"\"\"Normalize a value for SQL query (wrap strings in single quotes)\"\"\"\n    if isinstance(val, str):\n        return f\"'{val}'\"\n    return val\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.valid_field","title":"<code>valid_field(fieldname)</code>","text":"<p>Validate a fieldname</p> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def valid_field(fieldname: FieldName) -&gt; bool:\n    \"\"\"Validate a fieldname\"\"\"\n    return not (\n            # Has characters\n            len(fieldname) == 0\n            # Is under 160 characters\n            or len(fieldname) &gt; 160\n            # Doesn't start with a number\n            or fieldname[0] in digits \n            # Only has alphanum and underscore\n            or not set(fieldname).issubset(ascii_letters + digits + '_')\n            # Doesn't have reserved prefix\n            or any(fieldname.startswith(reserved) for reserved in ('gdb_', 'sde_', 'delta_'))\n        )\n</code></pre>"},{"location":"modules/featureclass/#arcpie.featureclass.where","title":"<code>where(where_clause)</code>","text":"<p>Wrap a string in a WhereClause object to use with indexing</p> <p>Parameters:</p> Name Type Description Default <code>where_clause</code> <code>str</code> <p>A where clause string to mark as a clause</p> required <p>Returns:</p> Type Description <code>WhereClause</code> <p>WhereClause</p> Example <pre><code>&gt;&gt;&gt; for row in features[where('SHAPE_LENGTH &gt; 10')]:\n...     print(row)\n{'OBJECTID': 1, 'SHAPE_LENGTH': 11}\n{'OBJECTID': 2, 'SHAPE_LENGTH': 34}\n{'OBJECTID': 3, 'SHAPE_LENGTH': 78}\n...\n</code></pre> Source code in <code>src/arcpie/featureclass.py</code> <pre><code>def where(where_clause: str) -&gt; WhereClause:\n    \"\"\"Wrap a string in a WhereClause object to use with indexing\n\n    Args:\n        where_clause (str): A where clause string to mark as a clause\n\n    Returns:\n        WhereClause\n\n    Example:\n        ```python\n        &gt;&gt;&gt; for row in features[where('SHAPE_LENGTH &gt; 10')]:\n        ...     print(row)\n        {'OBJECTID': 1, 'SHAPE_LENGTH': 11}\n        {'OBJECTID': 2, 'SHAPE_LENGTH': 34}\n        {'OBJECTID': 3, 'SHAPE_LENGTH': 78}\n        ...\n        ```\n    \"\"\"\n    return WhereClause(where_clause)\n</code></pre>"},{"location":"modules/network/","title":"network","text":""},{"location":"modules/network/#arcpie.network.FeatureGraph","title":"<code>FeatureGraph</code>","text":"Source code in <code>src/arcpie/network.py</code> <pre><code>class FeatureGraph:\n    def __init__(self, edges: FeatureClass[Polyline, Any], nodes: FeatureClass[PointGeometry, Any], tolerance: float=0.0,\n                 *,\n                 node_attributes: Sequence[str] | None=None,\n                 edge_attributes: Sequence[str] | None=None) -&gt; None:\n        self.node_features = nodes\n        self.edge_features = edges\n        self.node_attributes = node_attributes or tuple()\n        self.edge_attributes = edge_attributes or tuple()\n        self.tolerance = tolerance\n        self._graph = self.build_graph()\n        self.user_nodes: list[tuple[int, PointGeometry]] = []\n\n    @property\n    def graph(self) -&gt; nx.Graph:\n        return self._graph\n\n    @property\n    def nodes(self) -&gt; Iterator[tuple[int, dict[str, Any]]]:\n        return self.graph.nodes.data()\n\n    def refresh(self) -&gt; None:\n        self.user_nodes = []\n        self._graph = self.build_graph()\n\n    def build_graph(self) -&gt; nx.Graph:\n        \"\"\"Build a graph from the provided features\n        Structure of the Graph will be:\n\n        `node:oid[attrs] &lt;-(edge:[attrs])-&gt; node:oid[attrs]`\n\n        e.g.\n\n        `45: {'name': 'bill'} &lt;-{'length': 1200.4, 'link_name': 'direct'}-&gt; 46: {'name': 'sue'}`\n\n        Returns:\n            (nx.Graph): A networkx Graph with all points connected by the provided edges\n\n        \"\"\"\n\n        # Initialize an undirected graph\n        g = nx.Graph()\n\n        # Add all points as nodes (with specified attributes)\n        for oid, node, *node_attrs in self.node_features[('OID@', 'SHAPE@', *self.node_attributes)]:\n            user_attrs: dict[str, Any] = dict(zip(self.node_attributes, node_attrs))\n            system_attrs: dict[str, Any] = {'OID@': oid, 'SHAPE@': node}\n            # Merge user and system attrs then unpack into **attr\n            g.add_node(oid, **{**user_attrs, **system_attrs})\n\n        # Connect all nodes using edges (with specified attributes)\n        for oid, edge, *edge_attrs in self.edge_features[('OID@', 'SHAPE@', *self.edge_attributes)]:\n            edge: Polyline\n            fp = PointGeometry(edge.firstPoint)\n            lp = PointGeometry(edge.lastPoint)\n\n            # Buffer anything with a specified non-zero tolerance\n            if self.tolerance:\n                fp = fp.buffer(self.tolerance)\n                lp = lp.buffer(self.tolerance)\n\n            # Get all nodes that Intersect the endpoints of the edge\n            with self.node_features.spatial_filter(fp.union(lp)):\n                to_add: list[int] = list(self.node_features['OID@'])\n\n            # Generate all unique connections for the edge and add them to the graph with the edge attrs\n            # avoid connecting nodes to themselves\n            for cxn in {tuple(sorted([a, b])) for a in to_add for b in to_add if a != b}:\n                user_attrs: dict[str, Any] = dict(zip(self.edge_attributes, edge_attrs))\n                system_attrs: dict[str, Any] = {'length': edge.length, 'OID@': oid, 'SHAPE@': edge}\n                # Merge user and system attrs then unpack into **attr\n                g.add_edge(cxn[0], cxn[1], **{**user_attrs, **system_attrs})\n        return g        \n\n    @overload\n    def __contains__(self, node: int) -&gt; bool: ...\n    @overload\n    def __contains__(self, node: PointGeometry) -&gt; bool: ...\n\n    def __contains__(self, node: int | PointGeometry) -&gt; bool:\n        if not isinstance(node, PointGeometry):\n            return node in self.graph\n        for _, data in self.nodes:\n            shape: PointGeometry = data['SHAPE@']\n            if shape == node:\n                return True\n        return False\n\n    def index_of(self, node: PointGeometry) -&gt; int:\n        for oid, data in self.nodes:\n            oid: int\n            shape: PointGeometry = data['SHAPE@']\n            if node == shape:\n                return oid\n\n        raise IndexError(f'Node: {node} not found in graph!')\n\n    def shortest_path(self, from_node: int|PointGeometry, to_node: int|PointGeometry) -&gt; Iterator[Polyline]:\n        \"\"\"Return the line geometries that make up the shortest path between the provided nodes\n\n        Args:\n            from_node (int|PointGeometry): The starting node in the graph\n            to_node (int|PointGeometry): The ending node in the graph\n\n        Returns:\n            (Iterator[Polyline]): An iterator of Polyline geometries that make up the shortest path \n        \"\"\"\n        if isinstance(from_node, PointGeometry):\n            from_node = self.index_of(from_node)\n\n        if isinstance(to_node, PointGeometry):\n            to_node = self.index_of(to_node)\n\n        route: list[int] = nx.shortest_path(self.graph, from_node, to_node, weight='length')\n\n        for i in range(len(route)-1):\n            yield self.graph.get_edge_data(route[i], route[i+1])['SHAPE@']\n\n    def add_node(self, node: PointGeometry, **data: Any) -&gt; int:\n        \"\"\"Adds a node to the graph\n\n        Note:\n            User added nodes will be assigned negative ids to prevent collision with system nodes from the base featureclass.\n            These nodes will also be removed if the graph is refreshed, this method is primarily for checking a geometry against a \n            network as a one off.\n\n        Args:\n            node (PointGeometry): The node to add\n            **data (Any): User defined attributes to add to the node\n\n        Returns:\n            (int): The new index of the node (negative indexed)\n        \"\"\"\n        new_index = -1*(len(self.user_nodes)+1)\n        user_attrs = data\n        system_attrs: dict[str, Any] = {'OID@': new_index, 'SHAPE@': node}\n        self.graph.add_node(new_index, **{**user_attrs, **system_attrs})\n        self.user_nodes.append((new_index, node))\n\n        # Buffer anything with a specified non-zero tolerance\n        if self.tolerance:\n            node_buff = node.buffer(self.tolerance)\n        else:\n            node_buff = node\n\n        with self.edge_features.spatial_filter(node_buff):\n            connecting_edges = tuple(self.edge_features[('OID@', 'SHAPE@', *self.edge_attributes)])\n\n        for oid, edge_shape, *edge_attrs in connecting_edges:\n            oid: int\n            edge_shape: Polyline\n\n            fp = PointGeometry(edge_shape.firstPoint)\n            lp = PointGeometry(edge_shape.lastPoint)\n\n            # Buffer anything with a specified non-zero tolerance\n            if self.tolerance:\n                fp = fp.buffer(self.tolerance)\n                lp = lp.buffer(self.tolerance)\n\n            with self.node_features.spatial_filter(fp.union(lp)):\n                cxns = list(self.node_features['OID@'])\n\n            user_attrs = dict(zip(self.edge_attributes, edge_attrs))\n            system_attrs: dict[str, Any] = {'length': edge_shape.length, 'OID@': oid, 'SHAPE@': edge_shape}\n            self.graph.add_edges_from([(new_index, n) for n in cxns], **{**user_attrs, **system_attrs})\n        return new_index\n</code></pre>"},{"location":"modules/network/#arcpie.network.FeatureGraph.add_node","title":"<code>add_node(node, **data)</code>","text":"<p>Adds a node to the graph</p> Note <p>User added nodes will be assigned negative ids to prevent collision with system nodes from the base featureclass. These nodes will also be removed if the graph is refreshed, this method is primarily for checking a geometry against a  network as a one off.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>PointGeometry</code> <p>The node to add</p> required <code>**data</code> <code>Any</code> <p>User defined attributes to add to the node</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>The new index of the node (negative indexed)</p> Source code in <code>src/arcpie/network.py</code> <pre><code>def add_node(self, node: PointGeometry, **data: Any) -&gt; int:\n    \"\"\"Adds a node to the graph\n\n    Note:\n        User added nodes will be assigned negative ids to prevent collision with system nodes from the base featureclass.\n        These nodes will also be removed if the graph is refreshed, this method is primarily for checking a geometry against a \n        network as a one off.\n\n    Args:\n        node (PointGeometry): The node to add\n        **data (Any): User defined attributes to add to the node\n\n    Returns:\n        (int): The new index of the node (negative indexed)\n    \"\"\"\n    new_index = -1*(len(self.user_nodes)+1)\n    user_attrs = data\n    system_attrs: dict[str, Any] = {'OID@': new_index, 'SHAPE@': node}\n    self.graph.add_node(new_index, **{**user_attrs, **system_attrs})\n    self.user_nodes.append((new_index, node))\n\n    # Buffer anything with a specified non-zero tolerance\n    if self.tolerance:\n        node_buff = node.buffer(self.tolerance)\n    else:\n        node_buff = node\n\n    with self.edge_features.spatial_filter(node_buff):\n        connecting_edges = tuple(self.edge_features[('OID@', 'SHAPE@', *self.edge_attributes)])\n\n    for oid, edge_shape, *edge_attrs in connecting_edges:\n        oid: int\n        edge_shape: Polyline\n\n        fp = PointGeometry(edge_shape.firstPoint)\n        lp = PointGeometry(edge_shape.lastPoint)\n\n        # Buffer anything with a specified non-zero tolerance\n        if self.tolerance:\n            fp = fp.buffer(self.tolerance)\n            lp = lp.buffer(self.tolerance)\n\n        with self.node_features.spatial_filter(fp.union(lp)):\n            cxns = list(self.node_features['OID@'])\n\n        user_attrs = dict(zip(self.edge_attributes, edge_attrs))\n        system_attrs: dict[str, Any] = {'length': edge_shape.length, 'OID@': oid, 'SHAPE@': edge_shape}\n        self.graph.add_edges_from([(new_index, n) for n in cxns], **{**user_attrs, **system_attrs})\n    return new_index\n</code></pre>"},{"location":"modules/network/#arcpie.network.FeatureGraph.build_graph","title":"<code>build_graph()</code>","text":"<p>Build a graph from the provided features Structure of the Graph will be:</p> <p><code>node:oid[attrs] &lt;-(edge:[attrs])-&gt; node:oid[attrs]</code></p> <p>e.g.</p> <p><code>45: {'name': 'bill'} &lt;-{'length': 1200.4, 'link_name': 'direct'}-&gt; 46: {'name': 'sue'}</code></p> <p>Returns:</p> Type Description <code>Graph</code> <p>A networkx Graph with all points connected by the provided edges</p> Source code in <code>src/arcpie/network.py</code> <pre><code>def build_graph(self) -&gt; nx.Graph:\n    \"\"\"Build a graph from the provided features\n    Structure of the Graph will be:\n\n    `node:oid[attrs] &lt;-(edge:[attrs])-&gt; node:oid[attrs]`\n\n    e.g.\n\n    `45: {'name': 'bill'} &lt;-{'length': 1200.4, 'link_name': 'direct'}-&gt; 46: {'name': 'sue'}`\n\n    Returns:\n        (nx.Graph): A networkx Graph with all points connected by the provided edges\n\n    \"\"\"\n\n    # Initialize an undirected graph\n    g = nx.Graph()\n\n    # Add all points as nodes (with specified attributes)\n    for oid, node, *node_attrs in self.node_features[('OID@', 'SHAPE@', *self.node_attributes)]:\n        user_attrs: dict[str, Any] = dict(zip(self.node_attributes, node_attrs))\n        system_attrs: dict[str, Any] = {'OID@': oid, 'SHAPE@': node}\n        # Merge user and system attrs then unpack into **attr\n        g.add_node(oid, **{**user_attrs, **system_attrs})\n\n    # Connect all nodes using edges (with specified attributes)\n    for oid, edge, *edge_attrs in self.edge_features[('OID@', 'SHAPE@', *self.edge_attributes)]:\n        edge: Polyline\n        fp = PointGeometry(edge.firstPoint)\n        lp = PointGeometry(edge.lastPoint)\n\n        # Buffer anything with a specified non-zero tolerance\n        if self.tolerance:\n            fp = fp.buffer(self.tolerance)\n            lp = lp.buffer(self.tolerance)\n\n        # Get all nodes that Intersect the endpoints of the edge\n        with self.node_features.spatial_filter(fp.union(lp)):\n            to_add: list[int] = list(self.node_features['OID@'])\n\n        # Generate all unique connections for the edge and add them to the graph with the edge attrs\n        # avoid connecting nodes to themselves\n        for cxn in {tuple(sorted([a, b])) for a in to_add for b in to_add if a != b}:\n            user_attrs: dict[str, Any] = dict(zip(self.edge_attributes, edge_attrs))\n            system_attrs: dict[str, Any] = {'length': edge.length, 'OID@': oid, 'SHAPE@': edge}\n            # Merge user and system attrs then unpack into **attr\n            g.add_edge(cxn[0], cxn[1], **{**user_attrs, **system_attrs})\n    return g        \n</code></pre>"},{"location":"modules/network/#arcpie.network.FeatureGraph.shortest_path","title":"<code>shortest_path(from_node, to_node)</code>","text":"<p>Return the line geometries that make up the shortest path between the provided nodes</p> <p>Parameters:</p> Name Type Description Default <code>from_node</code> <code>int | PointGeometry</code> <p>The starting node in the graph</p> required <code>to_node</code> <code>int | PointGeometry</code> <p>The ending node in the graph</p> required <p>Returns:</p> Type Description <code>Iterator[Polyline]</code> <p>An iterator of Polyline geometries that make up the shortest path</p> Source code in <code>src/arcpie/network.py</code> <pre><code>def shortest_path(self, from_node: int|PointGeometry, to_node: int|PointGeometry) -&gt; Iterator[Polyline]:\n    \"\"\"Return the line geometries that make up the shortest path between the provided nodes\n\n    Args:\n        from_node (int|PointGeometry): The starting node in the graph\n        to_node (int|PointGeometry): The ending node in the graph\n\n    Returns:\n        (Iterator[Polyline]): An iterator of Polyline geometries that make up the shortest path \n    \"\"\"\n    if isinstance(from_node, PointGeometry):\n        from_node = self.index_of(from_node)\n\n    if isinstance(to_node, PointGeometry):\n        to_node = self.index_of(to_node)\n\n    route: list[int] = nx.shortest_path(self.graph, from_node, to_node, weight='length')\n\n    for i in range(len(route)-1):\n        yield self.graph.get_edge_data(route[i], route[i+1])['SHAPE@']\n</code></pre>"},{"location":"modules/project/","title":"project","text":"<p>Classes:</p> Name Description <code>Bookmark</code> <code>BookmarkManager</code> <code>BookmarkMapSeries</code> <p>Wrapper around an arcpy.mp BookmarkMapSeries object that provides an ergonomic interface</p> <code>ElevationSurface</code> <code>ElevationSurfaceManager</code> <code>Layer</code> <p>mp.Layer wrapper</p> <code>LayerManager</code> <code>Layout</code> <code>LayoutManager</code> <code>Manager</code> <p>Base access interfaces for all manager classes. Specific interfaces are defined in the subclass</p> <code>Map</code> <code>MapManager</code> <code>MapSeries</code> <p>Wrapper around an arcpy.mp MapSeries object that provides an ergonomic interface</p> <code>MappingWrapper</code> <p>Internal wrapper class for wrapping existing objects with new functionality</p> <code>Project</code> <p>Wrapper for an ArcGISProject (.aprx)</p> <code>Report</code> <code>ReportManager</code> <code>Table</code> <code>TableManager</code> <code>Wildcard</code> <p>Clarify that the string passed to a Manager index is a wildcard so the type checker knows you're getting a Sequence back</p> <p>Functions:</p> Name Description <code>name_of</code> <p>Handle the naming hierarchy of mapping objects URI -&gt; longName -&gt; name</p>"},{"location":"modules/project/#arcpie.project.Bookmark","title":"<code>Bookmark</code>","text":"<p>               Bases: <code>MappingWrapper[Bookmark, CIMBookmark]</code>, <code>Bookmark</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Bookmark(MappingWrapper[_Bookmark, CIMBookmark], _Bookmark): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.BookmarkManager","title":"<code>BookmarkManager</code>","text":"<p>               Bases: <code>Manager[Bookmark]</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class BookmarkManager(Manager[Bookmark]): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.BookmarkMapSeries","title":"<code>BookmarkMapSeries</code>","text":"<p>               Bases: <code>MappingWrapper[BookmarkMapSeries, CIMBookmarkMapSeries]</code>, <code>BookmarkMapSeries</code></p> <p>Wrapper around an arcpy.mp BookmarkMapSeries object that provides an ergonomic interface</p> <p>Methods:</p> Name Description <code>__getitem__</code> <p>Allow indexing the BookmarkMapSeries by name, index, or Bookmark object</p> <code>__iter__</code> <code>__len__</code> Source code in <code>src/arcpie/project.py</code> <pre><code>class BookmarkMapSeries(MappingWrapper[_BookmarkMapSeries, CIMBookmarkMapSeries], _BookmarkMapSeries):\n    \"\"\"Wrapper around an arcpy.mp BookmarkMapSeries object that provides an ergonomic interface\"\"\"\n\n    def __iter__(self) -&gt; Iterator[BookmarkMapSeries]:\n        _orig_page = self.currentPageNumber\n        for page in range(1, self.pageCount):\n            self.currentPageNumber = page\n            yield self\n        if _orig_page:\n            self.currentPageNumber = _orig_page\n\n    def __getitem__(self, page: int|str|_Bookmark) -&gt; BookmarkMapSeries:\n        \"\"\"Allow indexing the BookmarkMapSeries by name, index, or Bookmark object\"\"\"\n        match page:\n            case _Bookmark():\n                self.currentBookmark = page\n            case str():\n                self.currentPageNumber = self.getPageNumberFromName(page)\n            case int():\n                self.currentPageNumber = page\n        return self\n\n    def __len__(self) -&gt; int:\n        return len(self.bookmarks)\n</code></pre>"},{"location":"modules/project/#arcpie.project.BookmarkMapSeries.__getitem__","title":"<code>__getitem__(page)</code>","text":"<p>Allow indexing the BookmarkMapSeries by name, index, or Bookmark object</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def __getitem__(self, page: int|str|_Bookmark) -&gt; BookmarkMapSeries:\n    \"\"\"Allow indexing the BookmarkMapSeries by name, index, or Bookmark object\"\"\"\n    match page:\n        case _Bookmark():\n            self.currentBookmark = page\n        case str():\n            self.currentPageNumber = self.getPageNumberFromName(page)\n        case int():\n            self.currentPageNumber = page\n    return self\n</code></pre>"},{"location":"modules/project/#arcpie.project.BookmarkMapSeries.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __iter__(self) -&gt; Iterator[BookmarkMapSeries]:\n    _orig_page = self.currentPageNumber\n    for page in range(1, self.pageCount):\n        self.currentPageNumber = page\n        yield self\n    if _orig_page:\n        self.currentPageNumber = _orig_page\n</code></pre>"},{"location":"modules/project/#arcpie.project.BookmarkMapSeries.__len__","title":"<code>__len__()</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.bookmarks)\n</code></pre>"},{"location":"modules/project/#arcpie.project.ElevationSurface","title":"<code>ElevationSurface</code>","text":"<p>               Bases: <code>MappingWrapper[ElevationSurface, CIMElevationSurfaceLayer]</code>, <code>ElevationSurface</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class ElevationSurface(MappingWrapper[_ElevationSurface, CIMElevationSurfaceLayer], _ElevationSurface): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.ElevationSurfaceManager","title":"<code>ElevationSurfaceManager</code>","text":"<p>               Bases: <code>Manager[ElevationSurface]</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class ElevationSurfaceManager(Manager[ElevationSurface]): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.Layer","title":"<code>Layer</code>","text":"<p>               Bases: <code>MappingWrapper[Layer, CIMBaseLayer]</code>, <code>Layer</code></p> <p>mp.Layer wrapper</p> <p>Methods:</p> Name Description <code>export_lyrx</code> <p>Export the layer to a lyrx file in the target directory</p> <code>import_lyrx</code> <p>Import the layer state from an lyrx file</p> <p>Attributes:</p> Name Type Description <code>cim</code> <code>CIMBaseLayer</code> <code>feature_class</code> <code>FeatureClass</code> <p>Get a <code>arcpie.FeatureClass</code> object that is initialized using the layer and its current state</p> <code>lyrx</code> <code>dict[str, Any] | None</code> <p>Get a dictionary representation of the layer that can be saved to an lyrx file using <code>json.dumps</code></p> <code>symbology</code> <code>Symbology</code> <p>Get the base symbology object for the layer</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Layer(MappingWrapper[_Layer, CIMBaseLayer], _Layer):\n    \"\"\"mp.Layer wrapper\"\"\"\n\n    @property\n    def feature_class(self) -&gt; FeatureClass:\n        \"\"\"Get a `arcpie.FeatureClass` object that is initialized using the layer and its current state\"\"\"\n        return FeatureClass.from_layer(self)\n\n    @property\n    def symbology(self) -&gt; Symbology:\n        \"\"\"Get the base symbology object for the layer\"\"\"\n        return self._obj.symbology\n\n    @property\n    def lyrx(self) -&gt; dict[str, Any] | None:\n        \"\"\"Get a dictionary representation of the layer that can be saved to an lyrx file using `json.dumps`\n\n        Note:\n            GroupLayer objects will return a lyrx template with all sub-layers included\n        \"\"\"\n        _def = self.cim_dict\n        if _def is None:\n            return None\n        _lyrx: dict[str, Any] = { # Base required keys for lyrx file\n            'type': 'CIMLayerDocument',\n            'layers': [self.uri],\n            'layerDefinitions': [_def],\n        }\n\n        # Handle Group Layers\n        if self.isGroupLayer and self.parent and isinstance(self.parent, Map):\n            if _child_tables := [uri for uri in _def.get('tables', [])]:\n                _child_tables: list[str]\n                _table_uris = set(_child_tables) &amp; set(self.parent.tables.uris) # Skip dead nodes\n                _lyrx['tableDefinitions'] = [self.parent.tables[uri].cim_dict for uri in _table_uris]\n            if _child_layers := [uri for uri in _def.get('layers', [])]:\n                _child_layers: list[str]\n                _layer_uris = set(_child_layers) &amp; set(self.parent.layers.uris) # Skip dead nodes\n                _lyrx['layerDefinitions'] = [_def] + [self.parent.layers[uri].cim_dict for uri in _layer_uris]\n        return _lyrx\n\n    @property\n    def cim(self) -&gt; CIMBaseLayer:\n        return super().cim\n\n    def export_lyrx(self, out_dir: Path|str) -&gt; None:\n        \"\"\"Export the layer to a lyrx file in the target directory\n\n        Args:\n            out_dir (Path|str): The location to export the mapx to\n        \"\"\"\n        out_dir = Path(out_dir)\n        target = out_dir / f'{self.longName}.lyrx'\n        # Make Containing directory for grouped layers\n        target.parent.mkdir(exist_ok=True, parents=True)\n        target.write_text(json.dumps(self.lyrx, indent=2), encoding='utf-8')\n\n    def import_lyrx(self, lyrx: Path|str) -&gt; None:\n        \"\"\"Import the layer state from an lyrx file\n\n        Args:\n            lyrx (Path|str): The lyrx file to update this layer with\n\n        Note:\n            CIM changes require the APRX to be saved to take effect. If you are accessing this\n            layer via a Project, use `project.save()` after importing the layerfile\n        \"\"\"\n        _lyrx = LayerFile(str(lyrx))\n        _lyrx_layers = {l.name: l for l in _lyrx.listLayers()}\n        if not (_lyrx_layer := _lyrx_layers.get(self.name)):\n            print(f'{self.name} not found in {str(lyrx)}')\n        else:\n            # Update Connection\n            _lyrx_layer = Layer(_lyrx_layer)\n            _lyrx_cim_dict = _lyrx_layer.cim_dict or {}\n            _lyrx_layer_cim = _lyrx_layer.cim\n            if _lyrx_cim_dict.get('featureTable') and _lyrx_cim_dict['featureTable'].get('dataConnection'):\n                _lyrx_layer_cim.featureTable.dataConnection = self.cim.featureTable.dataConnection # type: ignore (this is how CIM works)\n            try:\n                self.setDefinition(_lyrx_layer_cim) # pyright: ignore[reportArgumentType]\n            except AttributeError:\n                print(f'Failed to update CIM for {self.__class__.__name__}{self.name}')\n</code></pre>"},{"location":"modules/project/#arcpie.project.Layer.cim","title":"<code>cim</code>  <code>property</code>","text":""},{"location":"modules/project/#arcpie.project.Layer.feature_class","title":"<code>feature_class</code>  <code>property</code>","text":"<p>Get a <code>arcpie.FeatureClass</code> object that is initialized using the layer and its current state</p>"},{"location":"modules/project/#arcpie.project.Layer.lyrx","title":"<code>lyrx</code>  <code>property</code>","text":"<p>Get a dictionary representation of the layer that can be saved to an lyrx file using <code>json.dumps</code></p> Note <p>GroupLayer objects will return a lyrx template with all sub-layers included</p>"},{"location":"modules/project/#arcpie.project.Layer.symbology","title":"<code>symbology</code>  <code>property</code>","text":"<p>Get the base symbology object for the layer</p>"},{"location":"modules/project/#arcpie.project.Layer.export_lyrx","title":"<code>export_lyrx(out_dir)</code>","text":"<p>Export the layer to a lyrx file in the target directory</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>Path | str</code> <p>The location to export the mapx to</p> required Source code in <code>src/arcpie/project.py</code> <pre><code>def export_lyrx(self, out_dir: Path|str) -&gt; None:\n    \"\"\"Export the layer to a lyrx file in the target directory\n\n    Args:\n        out_dir (Path|str): The location to export the mapx to\n    \"\"\"\n    out_dir = Path(out_dir)\n    target = out_dir / f'{self.longName}.lyrx'\n    # Make Containing directory for grouped layers\n    target.parent.mkdir(exist_ok=True, parents=True)\n    target.write_text(json.dumps(self.lyrx, indent=2), encoding='utf-8')\n</code></pre>"},{"location":"modules/project/#arcpie.project.Layer.import_lyrx","title":"<code>import_lyrx(lyrx)</code>","text":"<p>Import the layer state from an lyrx file</p> <p>Parameters:</p> Name Type Description Default <code>lyrx</code> <code>Path | str</code> <p>The lyrx file to update this layer with</p> required Note <p>CIM changes require the APRX to be saved to take effect. If you are accessing this layer via a Project, use <code>project.save()</code> after importing the layerfile</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def import_lyrx(self, lyrx: Path|str) -&gt; None:\n    \"\"\"Import the layer state from an lyrx file\n\n    Args:\n        lyrx (Path|str): The lyrx file to update this layer with\n\n    Note:\n        CIM changes require the APRX to be saved to take effect. If you are accessing this\n        layer via a Project, use `project.save()` after importing the layerfile\n    \"\"\"\n    _lyrx = LayerFile(str(lyrx))\n    _lyrx_layers = {l.name: l for l in _lyrx.listLayers()}\n    if not (_lyrx_layer := _lyrx_layers.get(self.name)):\n        print(f'{self.name} not found in {str(lyrx)}')\n    else:\n        # Update Connection\n        _lyrx_layer = Layer(_lyrx_layer)\n        _lyrx_cim_dict = _lyrx_layer.cim_dict or {}\n        _lyrx_layer_cim = _lyrx_layer.cim\n        if _lyrx_cim_dict.get('featureTable') and _lyrx_cim_dict['featureTable'].get('dataConnection'):\n            _lyrx_layer_cim.featureTable.dataConnection = self.cim.featureTable.dataConnection # type: ignore (this is how CIM works)\n        try:\n            self.setDefinition(_lyrx_layer_cim) # pyright: ignore[reportArgumentType]\n        except AttributeError:\n            print(f'Failed to update CIM for {self.__class__.__name__}{self.name}')\n</code></pre>"},{"location":"modules/project/#arcpie.project.LayerManager","title":"<code>LayerManager</code>","text":"<p>               Bases: <code>Manager[Layer]</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class LayerManager(Manager[Layer]): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.Layout","title":"<code>Layout</code>","text":"<p>               Bases: <code>MappingWrapper[Layout, CIMLayout]</code>, <code>Layout</code></p> <p>Methods:</p> Name Description <code>to_pdf</code> <p>Get the bytes for a pdf export of the Layout</p> <p>Attributes:</p> Name Type Description <code>mapseries</code> <code>MapSeries | BookmarkMapSeries | None</code> <p>Get the Layout MapSeries/BookmarkMapSeries if it exists</p> <code>pagx</code> <code>dict[str, Any]</code> <p>Access the raw CIM dictionary of the layout</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Layout(MappingWrapper[_Layout, CIMLayout], _Layout):\n\n    @property\n    def mapseries(self) -&gt; MapSeries | BookmarkMapSeries| None:\n        \"\"\"Get the Layout MapSeries/BookmarkMapSeries if it exists\"\"\"\n        if not self.mapSeries:\n            return None\n        if isinstance(self.mapSeries, _MapSeries):\n            return MapSeries(self.mapSeries, self)\n        return BookmarkMapSeries(self.mapSeries, self)\n\n    @property\n    def pagx(self) -&gt; dict[str, Any]:\n        \"\"\"Access the raw CIM dictionary of the layout\n\n        Returns:\n            (dict[str, Any]): A dictionary representation of the pagx json\n        \"\"\"\n        with NamedTemporaryFile() as tmp:\n            self.exportToPAGX(tmp.name)\n            return json.loads(Path(f'{tmp.name}.pagx').read_text(encoding='utf-8'))\n\n    def to_pdf(self, **settings: Unpack[PDFSetting]) -&gt; BytesIO:\n        \"\"\"Get the bytes for a pdf export of the Layout\n\n        Args:\n            **settings (PDFSetting): Optional settings for the export (default: `PDFDefault`)\n\n        Returns:\n            (bytes): Raw bytes of the PDF for use in a write operation or stream\n\n        Example:\n            ```python\n                # Get the layout object from a project file\n                lyt = prj.layouts['Layout_1']\n\n                # Create a pdf then write the output of to_pdf to it\n                pdf = Path('pdf_path').write_bytes(lyt.to_pdf())\n            ```   \n        \"\"\"\n        with NamedTemporaryFile() as tmp:\n            _settings = PDFDefault.copy()\n            for arg in _settings:\n                if val := settings.get(arg):\n                    _settings[arg] = val\n            pdf = self.exportToPDF(tmp.name, **_settings)\n            return BytesIO(Path(pdf).open('rb').read())\n</code></pre>"},{"location":"modules/project/#arcpie.project.Layout.mapseries","title":"<code>mapseries</code>  <code>property</code>","text":"<p>Get the Layout MapSeries/BookmarkMapSeries if it exists</p>"},{"location":"modules/project/#arcpie.project.Layout.pagx","title":"<code>pagx</code>  <code>property</code>","text":"<p>Access the raw CIM dictionary of the layout</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary representation of the pagx json</p>"},{"location":"modules/project/#arcpie.project.Layout.to_pdf","title":"<code>to_pdf(**settings)</code>","text":"<p>Get the bytes for a pdf export of the Layout</p> <p>Parameters:</p> Name Type Description Default <code>**settings</code> <code>PDFSetting</code> <p>Optional settings for the export (default: <code>PDFDefault</code>)</p> <code>{}</code> <p>Returns:</p> Type Description <code>bytes</code> <p>Raw bytes of the PDF for use in a write operation or stream</p> Example <pre><code>    # Get the layout object from a project file\n    lyt = prj.layouts['Layout_1']\n\n    # Create a pdf then write the output of to_pdf to it\n    pdf = Path('pdf_path').write_bytes(lyt.to_pdf())\n</code></pre> Source code in <code>src/arcpie/project.py</code> <pre><code>def to_pdf(self, **settings: Unpack[PDFSetting]) -&gt; BytesIO:\n    \"\"\"Get the bytes for a pdf export of the Layout\n\n    Args:\n        **settings (PDFSetting): Optional settings for the export (default: `PDFDefault`)\n\n    Returns:\n        (bytes): Raw bytes of the PDF for use in a write operation or stream\n\n    Example:\n        ```python\n            # Get the layout object from a project file\n            lyt = prj.layouts['Layout_1']\n\n            # Create a pdf then write the output of to_pdf to it\n            pdf = Path('pdf_path').write_bytes(lyt.to_pdf())\n        ```   \n    \"\"\"\n    with NamedTemporaryFile() as tmp:\n        _settings = PDFDefault.copy()\n        for arg in _settings:\n            if val := settings.get(arg):\n                _settings[arg] = val\n        pdf = self.exportToPDF(tmp.name, **_settings)\n        return BytesIO(Path(pdf).open('rb').read())\n</code></pre>"},{"location":"modules/project/#arcpie.project.LayoutManager","title":"<code>LayoutManager</code>","text":"<p>               Bases: <code>Manager[Layout]</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class LayoutManager(Manager[Layout]): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.Manager","title":"<code>Manager</code>","text":"<p>               Bases: <code>Generic[_MappingObject]</code></p> <p>Base access interfaces for all manager classes. Specific interfaces are defined in the subclass</p> <p>Index itentifiers are URI -&gt; longName -&gt; name depending on what is available in the managed class</p> <p>Methods:</p> Name Description <code>__contains__</code> <p>Check to see if a URI/name is present in the Manager</p> <code>__getitem__</code> <p>Access objects using a regex pattern (re.compile), wildcard (STRING), index, slice, name, or URI</p> <code>__init__</code> <code>__iter__</code> <code>__len__</code> <code>get</code> <p>Get a value from the Project with a safe default value</p> <p>Attributes:</p> Name Type Description <code>names</code> <code>list[str]</code> <p>Get the names of all managed objects (skips URIs)</p> <code>objects</code> <code>list[_MappingObject]</code> <p>Get a list of all managed objects</p> <code>uris</code> <code>list[str]</code> <p>Get URIs/CIMPATH for all managed objects</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Manager(Generic[_MappingObject]):\n    \"\"\"Base access interfaces for all manager classes. Specific interfaces are defined in the subclass\n\n    Index itentifiers are URI -&gt; longName -&gt; name depending on what is available in the managed class\n    \"\"\"\n\n    def __init__(self, objs: Iterable[_MappingObject]) -&gt; None:\n        self._objects: dict[str, _MappingObject] = {}\n        for o in objs:\n            if (_uri := o.uri) not in self._objects:\n                self._objects[_uri] = o\n\n    @property\n    def objects(self) -&gt; list[_MappingObject]:\n        \"\"\"Get a list of all managed objects\"\"\"\n        return list(self._objects.values())\n\n    @property\n    def names(self) -&gt; list[str]:\n        \"\"\"Get the names of all managed objects (skips URIs)\"\"\"\n        return [o.unique_name for o in self.objects]\n\n    @property\n    def uris(self) -&gt; list[str]:\n        \"\"\"Get URIs/CIMPATH for all managed objects\n\n        Note:\n            Default to a Python id() call if no URI is present\n        \"\"\"\n        return [o.uri for o in self.objects]\n\n    @overload\n    def __getitem__(self, name: str) -&gt; _MappingObject: ...\n    @overload\n    def __getitem__(self, name: int) -&gt; _MappingObject: ...\n    @overload\n    def __getitem__(self, name: Wildcard) -&gt; list[_MappingObject]: ...\n    @overload\n    def __getitem__(self, name: re.Pattern[str]) -&gt; list[_MappingObject]: ...\n    @overload\n    def __getitem__(self, name: slice) -&gt; list[_MappingObject]: ...\n\n    def __getitem__(self, name: str|Wildcard|re.Pattern[str]|int|slice) -&gt; _MappingObject|list[_MappingObject]:\n        \"\"\"Access objects using a regex pattern (re.compile), wildcard (*STRING*), index, slice, name, or URI\"\"\"\n        if isinstance(name, str) and '*' in name:\n            name = Wildcard(name) # Allow passing a wildcard directly (lose type inference)\n        match name:\n            case int() | slice():\n                return self.objects[name] # Will raise IndexError\n            case str(name) if name in self._objects:\n                return self._objects[name]\n            case str(name) if name in self.names:\n                for o in self.objects:\n                    if o.unique_name == name:\n                        return o\n            case re.Pattern():\n                return [o for o in self.objects if name.match(name_of(o, skip_uri=True))]\n            case Wildcard():\n                return [o for o in self.objects if all(part in name_of(o, skip_uri=True) for part in name.split('*'))]\n            case _ :\n                pass # Fallthrough to raise a KeyError\n\n        raise KeyError(f'{name} not found in objects: ({self.names})')\n\n    @overload\n    def get(self, name: str) -&gt; _MappingObject: ...\n    @overload\n    def get(self, name: Wildcard) -&gt; list[_MappingObject]: ...\n    @overload\n    def get(self, name: str, default: _Default) -&gt; _MappingObject | _Default: ...\n    @overload\n    def get(self, name: Wildcard, default: _Default) -&gt; list[_MappingObject] | _Default: ...\n    def get(self, name: str|Wildcard, default: _Default|None=None) -&gt; _MappingObject|list[_MappingObject]|_Default|None:\n        \"\"\"Get a value from the Project with a safe default value\"\"\"\n        try:\n            return self[name]\n        except KeyError:\n            return default\n\n    def __contains__(self, name: str|_MappingObject) -&gt; bool:\n        \"\"\"Check to see if a URI/name is present in the Manager\"\"\"\n        match name:\n            case str():\n                return True if self.get(name) else False\n            case _:\n                return any(o == name for o in self.objects)\n\n    def __iter__(self) -&gt; Iterator[_MappingObject]:\n        return iter(self._objects.values())\n\n    def __len__(self) -&gt; int:\n        return len(self._objects)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Manager.names","title":"<code>names</code>  <code>property</code>","text":"<p>Get the names of all managed objects (skips URIs)</p>"},{"location":"modules/project/#arcpie.project.Manager.objects","title":"<code>objects</code>  <code>property</code>","text":"<p>Get a list of all managed objects</p>"},{"location":"modules/project/#arcpie.project.Manager.uris","title":"<code>uris</code>  <code>property</code>","text":"<p>Get URIs/CIMPATH for all managed objects</p> Note <p>Default to a Python id() call if no URI is present</p>"},{"location":"modules/project/#arcpie.project.Manager.__contains__","title":"<code>__contains__(name)</code>","text":"<p>Check to see if a URI/name is present in the Manager</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def __contains__(self, name: str|_MappingObject) -&gt; bool:\n    \"\"\"Check to see if a URI/name is present in the Manager\"\"\"\n    match name:\n        case str():\n            return True if self.get(name) else False\n        case _:\n            return any(o == name for o in self.objects)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Manager.__getitem__","title":"<code>__getitem__(name)</code>","text":"<pre><code>__getitem__(name: str) -&gt; _MappingObject\n</code></pre><pre><code>__getitem__(name: int) -&gt; _MappingObject\n</code></pre><pre><code>__getitem__(name: Wildcard) -&gt; list[_MappingObject]\n</code></pre><pre><code>__getitem__(name: re.Pattern[str]) -&gt; list[_MappingObject]\n</code></pre><pre><code>__getitem__(name: slice) -&gt; list[_MappingObject]\n</code></pre> <p>Access objects using a regex pattern (re.compile), wildcard (STRING), index, slice, name, or URI</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def __getitem__(self, name: str|Wildcard|re.Pattern[str]|int|slice) -&gt; _MappingObject|list[_MappingObject]:\n    \"\"\"Access objects using a regex pattern (re.compile), wildcard (*STRING*), index, slice, name, or URI\"\"\"\n    if isinstance(name, str) and '*' in name:\n        name = Wildcard(name) # Allow passing a wildcard directly (lose type inference)\n    match name:\n        case int() | slice():\n            return self.objects[name] # Will raise IndexError\n        case str(name) if name in self._objects:\n            return self._objects[name]\n        case str(name) if name in self.names:\n            for o in self.objects:\n                if o.unique_name == name:\n                    return o\n        case re.Pattern():\n            return [o for o in self.objects if name.match(name_of(o, skip_uri=True))]\n        case Wildcard():\n            return [o for o in self.objects if all(part in name_of(o, skip_uri=True) for part in name.split('*'))]\n        case _ :\n            pass # Fallthrough to raise a KeyError\n\n    raise KeyError(f'{name} not found in objects: ({self.names})')\n</code></pre>"},{"location":"modules/project/#arcpie.project.Manager.__init__","title":"<code>__init__(objs)</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __init__(self, objs: Iterable[_MappingObject]) -&gt; None:\n    self._objects: dict[str, _MappingObject] = {}\n    for o in objs:\n        if (_uri := o.uri) not in self._objects:\n            self._objects[_uri] = o\n</code></pre>"},{"location":"modules/project/#arcpie.project.Manager.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __iter__(self) -&gt; Iterator[_MappingObject]:\n    return iter(self._objects.values())\n</code></pre>"},{"location":"modules/project/#arcpie.project.Manager.__len__","title":"<code>__len__()</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self._objects)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Manager.get","title":"<code>get(name, default=None)</code>","text":"<pre><code>get(name: str) -&gt; _MappingObject\n</code></pre><pre><code>get(name: Wildcard) -&gt; list[_MappingObject]\n</code></pre><pre><code>get(\n    name: str, default: _Default\n) -&gt; _MappingObject | _Default\n</code></pre><pre><code>get(\n    name: Wildcard, default: _Default\n) -&gt; list[_MappingObject] | _Default\n</code></pre> <p>Get a value from the Project with a safe default value</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def get(self, name: str|Wildcard, default: _Default|None=None) -&gt; _MappingObject|list[_MappingObject]|_Default|None:\n    \"\"\"Get a value from the Project with a safe default value\"\"\"\n    try:\n        return self[name]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"modules/project/#arcpie.project.Map","title":"<code>Map</code>","text":"<p>               Bases: <code>MappingWrapper[Map, CIMMapDocument]</code>, <code>Map</code></p> <p>Methods:</p> Name Description <code>__getitem__</code> <code>export_assoc_lyrx</code> <p>Export all child layers to lyrx files the target directory</p> <code>export_mapx</code> <p>Export the map definitions to a mapx file in the target directory</p> <code>get</code> <code>import_assoc_lyrx</code> <p>Imports lyrx files that were exported using the <code>export_assoc_lyrx</code> method</p> <code>import_mapx</code> <p>Attributes:</p> Name Type Description <code>bookmarks</code> <code>BookmarkManager</code> <p>Get a BookmarkManager for all bookmarks in the Map</p> <code>cim</code> <code>CIMMapDocument</code> <code>cim_dict</code> <code>dict[str, Any]</code> <code>elevation_surfaces</code> <code>ElevationSurfaceManager</code> <p>Get an ElevationSurfaceManager for all elevation surfaces in the Map</p> <code>layers</code> <code>LayerManager</code> <p>Get a LayerManager for all layers in the Map</p> <code>mapx</code> <code>dict[str, Any]</code> <code>tables</code> <code>TableManager</code> <p>Get a TableManager for all tables in the Map</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Map(MappingWrapper[_Map, CIMMapDocument], _Map):\n    @cached_property\n    def layers(self) -&gt; LayerManager:\n        \"\"\"Get a LayerManager for all layers in the Map\"\"\"\n        return LayerManager(Layer(l, self) for l in self.listLayers() or [])\n\n    @cached_property\n    def tables(self) -&gt; TableManager:\n        \"\"\"Get a TableManager for all tables in the Map\"\"\"\n        return TableManager(Table(t, self) for t in self.listTables() or [])\n\n    @cached_property\n    def bookmarks(self) -&gt; BookmarkManager:\n        \"\"\"Get a BookmarkManager for all bookmarks in the Map\"\"\"\n        return BookmarkManager(Bookmark(b, self) for b in self.listBookmarks() or [])\n\n    @cached_property\n    def elevation_surfaces(self) -&gt; ElevationSurfaceManager:\n        \"\"\"Get an ElevationSurfaceManager for all elevation surfaces in the Map\"\"\"\n        return ElevationSurfaceManager(ElevationSurface(es, self) for es in self.listElevationSurfaces() or [])\n\n    @property\n    def mapx(self) -&gt; dict[str, Any]:\n        with NamedTemporaryFile(suffix='.mapx') as tmp:\n            self.exportToMAPX(tmp.name)\n            return json.loads(Path(tmp.name).read_text(encoding='utf-8'))\n\n    @property\n    def cim(self) -&gt; CIMMapDocument:\n        return super().cim\n\n    @property\n    def cim_dict(self) -&gt; dict[str, Any]:\n        return json.loads(json.dumps(self.cim, cls=CimJsonEncoder, indent=2))\n\n    @overload\n    def __getitem__(self, name: str) -&gt; Layer | Table: ...\n    @overload\n    def __getitem__(self, name: Wildcard) -&gt; list[Layer] | list[Table]: ...\n    def __getitem__(self, name: str | Wildcard) -&gt; Any:\n        _obj = self.layers.get(name, None) or self.tables.get(name, None)\n        if _obj is None:\n            raise KeyError(f'{name} not found in map {self.unique_name}')\n        return _obj\n\n    @overload\n    def get(self, name: str, default: _Default) -&gt; Layer | Table | _Default: ...\n    @overload\n    def get(self, name: Wildcard, default: _Default) -&gt; list[Layer] | list[Table] | _Default: ...\n    def get(self, name: str | Wildcard, default: _Default=None) -&gt; Any | _Default:\n        try:\n            return self[name]\n        except KeyError:\n            return default\n\n    def export_mapx(self, out_dir: Path|str) -&gt; None:\n        \"\"\"Export the map definitions to a mapx file in the target directory\n\n        Args:\n            out_dir (Path|str): The location to export the mapx to\n        \"\"\"\n        target = Path(out_dir) / f'{self.unique_name}'\n        target.write_text(json.dumps(self.mapx, indent=2), encoding='utf-8')\n\n    def export_assoc_lyrx(self, out_dir: Path|str, *, skip_groups: bool=False, skip_grouped: bool=False) -&gt; None:\n        \"\"\"Export all child layers to lyrx files the target directory\n\n        Args:\n            out_dir (Path|str): The location to export the lyrx files to\n            skip_groups (bool): Skip group layerfiles and export each layer individually in a group subdirectory (default: False)\n            skip_grouped (bool): Inverse of skip groups and instead only exports the group lyrx, skipping the individual layers (default: False)\n        \"\"\"\n        out_dir = Path(out_dir)\n        for layer in self.layers:\n            if layer.isGroupLayer and skip_groups:\n                continue\n            try:\n                layer.export_lyrx(out_dir / self.unique_name)\n            except json.JSONDecodeError as e:\n                print(f'Failed to export layer: {layer}: {e}')\n\n        for table in self.tables:\n            try:\n                table.export_lyrx(out_dir / self.unique_name)\n            except json.JSONDecodeError as e:\n                print(f'Failed to export table: {table}: {e}')\n\n    def import_assoc_lyrx(self, lyrx_dir: Path|str, *, skip_groups: bool=False) -&gt; None:\n        \"\"\"Imports lyrx files that were exported using the `export_assoc_lyrx` method\n\n        Args:\n            lyrx_dir (Path|str): The directory containing the previously exported lyrx files\n\n        Note:\n            CIM changes require the APRX to be saved to take effect. If you are accessing this\n            layer via a Project, use `project.save()` after importing the layerfile\n        \"\"\"\n        lyrx_dir = Path(lyrx_dir)\n        for lyrx_path in lyrx_dir.rglob('*.lyrx'):\n            _lyrx_name = str(lyrx_path.relative_to(lyrx_dir).with_suffix(''))\n            if _lyrx_name in self.layers:\n                if self.layers[_lyrx_name].isGroupLayer and skip_groups:\n                    continue\n                self.layers[_lyrx_name].import_lyrx(lyrx_path)\n            elif _lyrx_name in self.tables:\n                self.tables[_lyrx_name].import_lyrx(lyrx_path)\n\n    def import_mapx(self, mapx: Path|str) -&gt; None:\n        raise NotImplementedError()\n</code></pre>"},{"location":"modules/project/#arcpie.project.Map.bookmarks","title":"<code>bookmarks</code>  <code>cached</code> <code>property</code>","text":"<p>Get a BookmarkManager for all bookmarks in the Map</p>"},{"location":"modules/project/#arcpie.project.Map.cim","title":"<code>cim</code>  <code>property</code>","text":""},{"location":"modules/project/#arcpie.project.Map.cim_dict","title":"<code>cim_dict</code>  <code>property</code>","text":""},{"location":"modules/project/#arcpie.project.Map.elevation_surfaces","title":"<code>elevation_surfaces</code>  <code>cached</code> <code>property</code>","text":"<p>Get an ElevationSurfaceManager for all elevation surfaces in the Map</p>"},{"location":"modules/project/#arcpie.project.Map.layers","title":"<code>layers</code>  <code>cached</code> <code>property</code>","text":"<p>Get a LayerManager for all layers in the Map</p>"},{"location":"modules/project/#arcpie.project.Map.mapx","title":"<code>mapx</code>  <code>property</code>","text":""},{"location":"modules/project/#arcpie.project.Map.tables","title":"<code>tables</code>  <code>cached</code> <code>property</code>","text":"<p>Get a TableManager for all tables in the Map</p>"},{"location":"modules/project/#arcpie.project.Map.__getitem__","title":"<code>__getitem__(name)</code>","text":"<pre><code>__getitem__(name: str) -&gt; Layer | Table\n</code></pre><pre><code>__getitem__(name: Wildcard) -&gt; list[Layer] | list[Table]\n</code></pre> Source code in <code>src/arcpie/project.py</code> <pre><code>def __getitem__(self, name: str | Wildcard) -&gt; Any:\n    _obj = self.layers.get(name, None) or self.tables.get(name, None)\n    if _obj is None:\n        raise KeyError(f'{name} not found in map {self.unique_name}')\n    return _obj\n</code></pre>"},{"location":"modules/project/#arcpie.project.Map.export_assoc_lyrx","title":"<code>export_assoc_lyrx(out_dir, *, skip_groups=False, skip_grouped=False)</code>","text":"<p>Export all child layers to lyrx files the target directory</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>Path | str</code> <p>The location to export the lyrx files to</p> required <code>skip_groups</code> <code>bool</code> <p>Skip group layerfiles and export each layer individually in a group subdirectory (default: False)</p> <code>False</code> <code>skip_grouped</code> <code>bool</code> <p>Inverse of skip groups and instead only exports the group lyrx, skipping the individual layers (default: False)</p> <code>False</code> Source code in <code>src/arcpie/project.py</code> <pre><code>def export_assoc_lyrx(self, out_dir: Path|str, *, skip_groups: bool=False, skip_grouped: bool=False) -&gt; None:\n    \"\"\"Export all child layers to lyrx files the target directory\n\n    Args:\n        out_dir (Path|str): The location to export the lyrx files to\n        skip_groups (bool): Skip group layerfiles and export each layer individually in a group subdirectory (default: False)\n        skip_grouped (bool): Inverse of skip groups and instead only exports the group lyrx, skipping the individual layers (default: False)\n    \"\"\"\n    out_dir = Path(out_dir)\n    for layer in self.layers:\n        if layer.isGroupLayer and skip_groups:\n            continue\n        try:\n            layer.export_lyrx(out_dir / self.unique_name)\n        except json.JSONDecodeError as e:\n            print(f'Failed to export layer: {layer}: {e}')\n\n    for table in self.tables:\n        try:\n            table.export_lyrx(out_dir / self.unique_name)\n        except json.JSONDecodeError as e:\n            print(f'Failed to export table: {table}: {e}')\n</code></pre>"},{"location":"modules/project/#arcpie.project.Map.export_mapx","title":"<code>export_mapx(out_dir)</code>","text":"<p>Export the map definitions to a mapx file in the target directory</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>Path | str</code> <p>The location to export the mapx to</p> required Source code in <code>src/arcpie/project.py</code> <pre><code>def export_mapx(self, out_dir: Path|str) -&gt; None:\n    \"\"\"Export the map definitions to a mapx file in the target directory\n\n    Args:\n        out_dir (Path|str): The location to export the mapx to\n    \"\"\"\n    target = Path(out_dir) / f'{self.unique_name}'\n    target.write_text(json.dumps(self.mapx, indent=2), encoding='utf-8')\n</code></pre>"},{"location":"modules/project/#arcpie.project.Map.get","title":"<code>get(name, default=None)</code>","text":"<pre><code>get(\n    name: str, default: _Default\n) -&gt; Layer | Table | _Default\n</code></pre><pre><code>get(\n    name: Wildcard, default: _Default\n) -&gt; list[Layer] | list[Table] | _Default\n</code></pre> Source code in <code>src/arcpie/project.py</code> <pre><code>def get(self, name: str | Wildcard, default: _Default=None) -&gt; Any | _Default:\n    try:\n        return self[name]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"modules/project/#arcpie.project.Map.import_assoc_lyrx","title":"<code>import_assoc_lyrx(lyrx_dir, *, skip_groups=False)</code>","text":"<p>Imports lyrx files that were exported using the <code>export_assoc_lyrx</code> method</p> <p>Parameters:</p> Name Type Description Default <code>lyrx_dir</code> <code>Path | str</code> <p>The directory containing the previously exported lyrx files</p> required Note <p>CIM changes require the APRX to be saved to take effect. If you are accessing this layer via a Project, use <code>project.save()</code> after importing the layerfile</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def import_assoc_lyrx(self, lyrx_dir: Path|str, *, skip_groups: bool=False) -&gt; None:\n    \"\"\"Imports lyrx files that were exported using the `export_assoc_lyrx` method\n\n    Args:\n        lyrx_dir (Path|str): The directory containing the previously exported lyrx files\n\n    Note:\n        CIM changes require the APRX to be saved to take effect. If you are accessing this\n        layer via a Project, use `project.save()` after importing the layerfile\n    \"\"\"\n    lyrx_dir = Path(lyrx_dir)\n    for lyrx_path in lyrx_dir.rglob('*.lyrx'):\n        _lyrx_name = str(lyrx_path.relative_to(lyrx_dir).with_suffix(''))\n        if _lyrx_name in self.layers:\n            if self.layers[_lyrx_name].isGroupLayer and skip_groups:\n                continue\n            self.layers[_lyrx_name].import_lyrx(lyrx_path)\n        elif _lyrx_name in self.tables:\n            self.tables[_lyrx_name].import_lyrx(lyrx_path)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Map.import_mapx","title":"<code>import_mapx(mapx)</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def import_mapx(self, mapx: Path|str) -&gt; None:\n    raise NotImplementedError()\n</code></pre>"},{"location":"modules/project/#arcpie.project.MapManager","title":"<code>MapManager</code>","text":"<p>               Bases: <code>Manager[Map]</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class MapManager(Manager[Map]): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.MapSeries","title":"<code>MapSeries</code>","text":"<p>               Bases: <code>MappingWrapper[MapSeries, CIMMapSeries]</code>, <code>MapSeries</code></p> <p>Wrapper around an arcpy.mp MapSeries object that provides an ergonomic interface</p> <p>Methods:</p> Name Description <code>__getitem__</code> <p>Allow indexing a mapseries by a page name or a page index/number</p> <code>__iter__</code> <code>__len__</code> <code>__repr__</code> <code>to_pdf</code> <p>Export the MapSeries to a PDF, See Layer.to_pdf for more info</p> <p>Attributes:</p> Name Type Description <code>current_page_name</code> <code>str</code> <p>Get the name of the active mapseries page</p> <code>feature_class</code> <code>FeatureClass</code> <p>Get the FeatureClass of the parent layer</p> <code>layer</code> <code>Layer</code> <p>Get the mapseries target layer</p> <code>map</code> <code>Map</code> <p>Get the map object that is being seriesed</p> <code>pageRow</code> <p>Get a Row object for the active mapseries page</p> <code>page_field</code> <code>str</code> <p>Get fieldname used as pagename</p> <code>page_field_names</code> <code>list[str]</code> <p>Get all fieldnames for the mapseriesed features</p> <code>page_values</code> <code>dict[str, Any]</code> <p>Get a mapping of values for the current page</p> <code>valid_pages</code> <code>list[str]</code> <p>Get all valid page names for the MapSeries</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class MapSeries(MappingWrapper[_MapSeries, CIMMapSeries], _MapSeries):\n    \"\"\"Wrapper around an arcpy.mp MapSeries object that provides an ergonomic interface\"\"\"\n    @property\n    def layer(self) -&gt; Layer:\n        \"\"\"Get the mapseries target layer\"\"\"\n        return Layer(self.indexLayer, self.map)\n\n    @property # Passthrough\n    def feature_class(self) -&gt; FeatureClass:\n        \"\"\"Get the FeatureClass of the parent layer\"\"\"\n        return self.layer.feature_class\n\n    @property\n    def map(self) -&gt; Map:\n        \"\"\"Get the map object that is being seriesed\"\"\"\n        return Map(self.mapFrame.map, self.parent.parent) #type: ignore (if a MapSeries is initialized this will be a map)\n\n    @property\n    def pageRow(self): # type: ignore (prevent access to uninitialized pageRow raising RuntimeError)\n        \"\"\"Get a Row object for the active mapseries page\"\"\"\n        try:\n            return self._obj.pageRow\n        except RuntimeError:\n            return None\n\n    @property\n    def page_field(self) -&gt; str:\n        \"\"\"Get fieldname used as pagename\"\"\"\n        return self.pageNameField.name\n\n    @cached_property\n    def page_field_names(self) -&gt; list[str]:\n        \"\"\"Get all fieldnames for the mapseriesed features\"\"\"\n        return [f for f in self.feature_class.fields if not f.startswith('@')]\n\n    @property\n    def valid_pages(self) -&gt; list[str]:\n        \"\"\"Get all valid page names for the MapSeries\"\"\"\n        return list(self.feature_class[self.page_field])\n\n    @property\n    def page_values(self) -&gt; dict[str, Any]:\n        \"\"\"Get a mapping of values for the current page\"\"\"\n        if not self.pageRow:\n            return {} # pageRow is unset with no active page\n\n        # Need to access a private `_asdict` method of Row because getValue is broken\n        return {f: self.pageRow._asdict().get(f) for f in self.page_field_names}\n\n    @property\n    def current_page_name(self) -&gt; str:\n        \"\"\"Get the name of the active mapseries page\"\"\"\n        return self.page_values.get(self.page_field, 'No Page')\n\n    def to_pdf(self, **settings: Unpack[MapSeriesPDFSetting]) -&gt; BytesIO:\n        \"\"\"Export the MapSeries to a PDF, See Layer.to_pdf for more info\n\n        Args:\n            **settings (Unpack[MapSeriesPDFSetting]): Passthrough kwargs for layout.exportToPDF\n\n        Note:\n            By default, printing a mapseries will print all pages to a single file. To only print\n            the active page:\n            ```python\n            &gt;&gt;&gt; ms.to_pdf(page_range_type='CURRENT')\n            ```\n        \"\"\"\n        _settings = MapseriesPDFDefault.copy()\n        _settings.update(settings)\n        with NamedTemporaryFile() as tmp:\n            return BytesIO(Path(self.exportToPDF(tmp.name, **_settings)).open('rb').read())\n\n    def __iter__(self) -&gt; Iterator[MapSeries]:\n        _orig_page = self.currentPageNumber\n        for page in range(1, self.pageCount+1):\n            self.currentPageNumber = page\n            yield self\n        if _orig_page:\n            self.currentPageNumber = _orig_page\n\n    def __getitem__(self, page: int|str) -&gt; MapSeries:\n        \"\"\"Allow indexing a mapseries by a page name or a page index/number\"\"\"\n        match page:\n            case str():\n                if page not in self.valid_pages:\n                    raise KeyError(f\"{page} is not a valid page name!\")\n                self.currentPageNumber = self.getPageNumberFromName(page)\n            case int():\n                if page not in range(1, self.pageCount):\n                    raise IndexError(f\"{self} only has {self.pageCount} pages, {page} out of range\")\n                self.currentPageNumber = page\n        return self\n\n    def __len__(self) -&gt; int:\n        return self.pageCount\n\n    def __repr__(self) -&gt; str:\n        return f'MapSeries&lt;{self.layer.unique_name} @ {self.current_page_name}&gt;'\n</code></pre>"},{"location":"modules/project/#arcpie.project.MapSeries.current_page_name","title":"<code>current_page_name</code>  <code>property</code>","text":"<p>Get the name of the active mapseries page</p>"},{"location":"modules/project/#arcpie.project.MapSeries.feature_class","title":"<code>feature_class</code>  <code>property</code>","text":"<p>Get the FeatureClass of the parent layer</p>"},{"location":"modules/project/#arcpie.project.MapSeries.layer","title":"<code>layer</code>  <code>property</code>","text":"<p>Get the mapseries target layer</p>"},{"location":"modules/project/#arcpie.project.MapSeries.map","title":"<code>map</code>  <code>property</code>","text":"<p>Get the map object that is being seriesed</p>"},{"location":"modules/project/#arcpie.project.MapSeries.pageRow","title":"<code>pageRow</code>  <code>property</code>","text":"<p>Get a Row object for the active mapseries page</p>"},{"location":"modules/project/#arcpie.project.MapSeries.page_field","title":"<code>page_field</code>  <code>property</code>","text":"<p>Get fieldname used as pagename</p>"},{"location":"modules/project/#arcpie.project.MapSeries.page_field_names","title":"<code>page_field_names</code>  <code>cached</code> <code>property</code>","text":"<p>Get all fieldnames for the mapseriesed features</p>"},{"location":"modules/project/#arcpie.project.MapSeries.page_values","title":"<code>page_values</code>  <code>property</code>","text":"<p>Get a mapping of values for the current page</p>"},{"location":"modules/project/#arcpie.project.MapSeries.valid_pages","title":"<code>valid_pages</code>  <code>property</code>","text":"<p>Get all valid page names for the MapSeries</p>"},{"location":"modules/project/#arcpie.project.MapSeries.__getitem__","title":"<code>__getitem__(page)</code>","text":"<p>Allow indexing a mapseries by a page name or a page index/number</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def __getitem__(self, page: int|str) -&gt; MapSeries:\n    \"\"\"Allow indexing a mapseries by a page name or a page index/number\"\"\"\n    match page:\n        case str():\n            if page not in self.valid_pages:\n                raise KeyError(f\"{page} is not a valid page name!\")\n            self.currentPageNumber = self.getPageNumberFromName(page)\n        case int():\n            if page not in range(1, self.pageCount):\n                raise IndexError(f\"{self} only has {self.pageCount} pages, {page} out of range\")\n            self.currentPageNumber = page\n    return self\n</code></pre>"},{"location":"modules/project/#arcpie.project.MapSeries.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __iter__(self) -&gt; Iterator[MapSeries]:\n    _orig_page = self.currentPageNumber\n    for page in range(1, self.pageCount+1):\n        self.currentPageNumber = page\n        yield self\n    if _orig_page:\n        self.currentPageNumber = _orig_page\n</code></pre>"},{"location":"modules/project/#arcpie.project.MapSeries.__len__","title":"<code>__len__()</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __len__(self) -&gt; int:\n    return self.pageCount\n</code></pre>"},{"location":"modules/project/#arcpie.project.MapSeries.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f'MapSeries&lt;{self.layer.unique_name} @ {self.current_page_name}&gt;'\n</code></pre>"},{"location":"modules/project/#arcpie.project.MapSeries.to_pdf","title":"<code>to_pdf(**settings)</code>","text":"<p>Export the MapSeries to a PDF, See Layer.to_pdf for more info</p> <p>Parameters:</p> Name Type Description Default <code>**settings</code> <code>Unpack[MapSeriesPDFSetting]</code> <p>Passthrough kwargs for layout.exportToPDF</p> <code>{}</code> Note <p>By default, printing a mapseries will print all pages to a single file. To only print the active page: <pre><code>&gt;&gt;&gt; ms.to_pdf(page_range_type='CURRENT')\n</code></pre></p> Source code in <code>src/arcpie/project.py</code> <pre><code>def to_pdf(self, **settings: Unpack[MapSeriesPDFSetting]) -&gt; BytesIO:\n    \"\"\"Export the MapSeries to a PDF, See Layer.to_pdf for more info\n\n    Args:\n        **settings (Unpack[MapSeriesPDFSetting]): Passthrough kwargs for layout.exportToPDF\n\n    Note:\n        By default, printing a mapseries will print all pages to a single file. To only print\n        the active page:\n        ```python\n        &gt;&gt;&gt; ms.to_pdf(page_range_type='CURRENT')\n        ```\n    \"\"\"\n    _settings = MapseriesPDFDefault.copy()\n    _settings.update(settings)\n    with NamedTemporaryFile() as tmp:\n        return BytesIO(Path(self.exportToPDF(tmp.name, **_settings)).open('rb').read())\n</code></pre>"},{"location":"modules/project/#arcpie.project.MappingWrapper","title":"<code>MappingWrapper</code>","text":"<p>               Bases: <code>Generic[_MapType, _CIMType]</code></p> <p>Internal wrapper class for wrapping existing objects with new functionality</p> Usage <pre><code>&gt;&gt;&gt; MappingWraper[mp.&lt;type&gt;, cim.&lt;type&gt;](mp.&lt;type&gt;)\n</code></pre> Note <p>All</p> <p>Methods:</p> Name Description <code>__eq__</code> <code>__getattr__</code> <code>__init__</code> <code>__repr__</code> <p>Attributes:</p> Name Type Description <code>cim</code> <code>_CIMType</code> <code>cim_dict</code> <code>dict[str, Any] | None</code> <code>parent</code> <p>The parent object for the wrapper</p> <code>unique_name</code> <code>str</code> <p>Get the longName or name of the object. Use id for any object without a name attribute</p> <code>uri</code> <code>str</code> <p>Get the URI for the object or the id with <code>:NO_URI</code> at the end</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class MappingWrapper(Generic[_MapType, _CIMType]):\n    \"\"\"Internal wrapper class for wrapping existing objects with new functionality\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; MappingWraper[mp.&lt;type&gt;, cim.&lt;type&gt;](mp.&lt;type&gt;)\n        ```\n\n    Note:\n        All \n    \"\"\"\n    def __init__(self, obj: _MapType, parent: _MappingObject|Project|None=None) -&gt; None:\n        self._obj = obj\n        self._parent = parent\n\n    @property\n    def parent(self):\n        \"\"\"The parent object for the wrapper\n\n        `Project -&gt; Map -&gt; Layer`\\n\n        `Project -&gt; Layout -&gt; Map -&gt; MapSeries`\\n\n        `Project -&gt; Report`\n\n        The general parent/child relationships are based on how you would access the object in ArcPro.\n        Projects have maps, maps have layers, layouts have mapseries etc.\n        \"\"\"\n        return self._parent\n\n    @property\n    def cim(self) -&gt; _CIMType:\n        try:\n            return getattr(self._obj, 'getDefinition')('V3')\n        except json.JSONDecodeError:\n            print(f'Invalid layer definition found')\n            return CIMDefinition(name='INVALID CIM') # pyright: ignore[reportReturnType]\n\n    @property\n    def unique_name(self) -&gt; str:\n        \"\"\"Get the longName or name of the object. Use id for any object without a name attribute\"\"\"\n        return getattr(self._obj, 'longName', None) or getattr(self._obj, 'name', None) or str(id(self._obj))\n\n    @property\n    def uri(self) -&gt; str:\n        \"\"\"Get the URI for the object or the id with `:NO_URI` at the end\"\"\"\n        _uri = getattr(self._obj, 'URI', None)\n        if _uri is None:\n            _uri = json.loads(self._obj._arc_object.GetCimJSONString())['uRI'] # type: ignore\n        return _uri\n\n    @property\n    def cim_dict(self) -&gt; dict[str, Any] | None:\n        if _cim := self.cim:\n            return json.loads(json.dumps(_cim, cls=CimJsonEncoder, indent=2))\n\n    def __getattr__(self, attr: str) -&gt; Any:\n        return getattr(self._obj, attr)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self._obj.__class__.__name__}({name_of(self, skip_uri=True)})\"\n\n    def __eq__(self, other: MappingWrapper[Any, Any] | Any) -&gt; bool:\n        if hasattr(other, '_obj'):\n            return self._obj is getattr(other, '_obj', None)\n        else:\n            return super().__eq__(other)\n</code></pre>"},{"location":"modules/project/#arcpie.project.MappingWrapper.cim","title":"<code>cim</code>  <code>property</code>","text":""},{"location":"modules/project/#arcpie.project.MappingWrapper.cim_dict","title":"<code>cim_dict</code>  <code>property</code>","text":""},{"location":"modules/project/#arcpie.project.MappingWrapper.parent","title":"<code>parent</code>  <code>property</code>","text":"<p>The parent object for the wrapper</p> <p><code>Project -&gt; Map -&gt; Layer</code></p> <p><code>Project -&gt; Layout -&gt; Map -&gt; MapSeries</code></p> <p><code>Project -&gt; Report</code></p> <p>The general parent/child relationships are based on how you would access the object in ArcPro. Projects have maps, maps have layers, layouts have mapseries etc.</p>"},{"location":"modules/project/#arcpie.project.MappingWrapper.unique_name","title":"<code>unique_name</code>  <code>property</code>","text":"<p>Get the longName or name of the object. Use id for any object without a name attribute</p>"},{"location":"modules/project/#arcpie.project.MappingWrapper.uri","title":"<code>uri</code>  <code>property</code>","text":"<p>Get the URI for the object or the id with <code>:NO_URI</code> at the end</p>"},{"location":"modules/project/#arcpie.project.MappingWrapper.__eq__","title":"<code>__eq__(other)</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __eq__(self, other: MappingWrapper[Any, Any] | Any) -&gt; bool:\n    if hasattr(other, '_obj'):\n        return self._obj is getattr(other, '_obj', None)\n    else:\n        return super().__eq__(other)\n</code></pre>"},{"location":"modules/project/#arcpie.project.MappingWrapper.__getattr__","title":"<code>__getattr__(attr)</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __getattr__(self, attr: str) -&gt; Any:\n    return getattr(self._obj, attr)\n</code></pre>"},{"location":"modules/project/#arcpie.project.MappingWrapper.__init__","title":"<code>__init__(obj, parent=None)</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __init__(self, obj: _MapType, parent: _MappingObject|Project|None=None) -&gt; None:\n    self._obj = obj\n    self._parent = parent\n</code></pre>"},{"location":"modules/project/#arcpie.project.MappingWrapper.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"{self._obj.__class__.__name__}({name_of(self, skip_uri=True)})\"\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project","title":"<code>Project</code>","text":"<p>Wrapper for an ArcGISProject (.aprx)</p> Usage <pre><code>&gt;&gt;&gt; prj = Project('&lt;path/to/aprx&gt;')\n&gt;&gt;&gt; lay = prj.layouts.get('My Layout')\n&gt;&gt;&gt; Path('My Layout.pdf').write_bytes(prj.layouts.get('My Layout').to_pdf())\n4593490 # Bytes written\n&gt;&gt;&gt; for map in prj.maps:\n...     print(f'{map.name} has {len(map.layers)} layers')\nMy Map has 5 layers\nMy Map 2 has 15 layers\nOther Map has 56 layers\n</code></pre> <p>Methods:</p> Name Description <code>__getitem__</code> <p>Resolve the name by looking in Maps, then Layouts, then Reports</p> <code>__init__</code> <code>__repr__</code> <code>export_layers</code> <p>Export all layers in the project to a structured directory of layerfiles</p> <code>export_mapx</code> <p>Export all maps to a directory</p> <code>export_pagx</code> <p>Export all layouts to a directory</p> <code>get</code> <code>import_layers</code> <p>Import a structured directory of layerfiles generated with <code>export_layers</code></p> <code>import_mapx</code> <p>Import a mapx file into this project</p> <code>import_pagx</code> <p>Import a pagx file into this project</p> <code>refresh</code> <p>Clear cached object managers</p> <code>save</code> <p>Save this project</p> <code>save_as</code> <p>Saves the project under a new name</p> <p>Attributes:</p> Name Type Description <code>aprx</code> <code>ArcGISProject</code> <p>Get the base ArcGISProject for the Project</p> <code>broken_layers</code> <code>LayerManager</code> <p>Get a LayerManager for all layers in the project with broken datasources</p> <code>broken_tables</code> <code>TableManager</code> <p>Get a TableManager for all tables in the project with broken datasources</p> <code>layouts</code> <code>LayoutManager</code> <p>Get a LayoutManager for the Project layouts</p> <code>maps</code> <code>MapManager</code> <p>Get a MapManager for the Project maps</p> <code>name</code> <code>str</code> <p>Get the file name of the wrapped aprx minus the file extension</p> <code>reports</code> <code>ReportManager</code> <p>Get a ReportManager for the Project reports</p> <code>tree</code> <code>dict[str, Any]</code> Source code in <code>src/arcpie/project.py</code> <pre><code>class Project:\n    \"\"\"Wrapper for an ArcGISProject (.aprx)\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; prj = Project('&lt;path/to/aprx&gt;')\n        &gt;&gt;&gt; lay = prj.layouts.get('My Layout')\n        &gt;&gt;&gt; Path('My Layout.pdf').write_bytes(prj.layouts.get('My Layout').to_pdf())\n        4593490 # Bytes written\n        &gt;&gt;&gt; for map in prj.maps:\n        ...     print(f'{map.name} has {len(map.layers)} layers')\n        My Map has 5 layers\n        My Map 2 has 15 layers\n        Other Map has 56 layers\n        ```\n    \"\"\"\n    def __init__(self, aprx_path: str|Path|Literal['CURRENT']='CURRENT') -&gt; None:\n        self._path = str(aprx_path)\n\n    def __repr__(self) -&gt; str:\n        return f\"Project({Path(self.aprx.filePath).stem}.aprx)\"\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Get the file name of the wrapped aprx minus the file extension\"\"\"\n        return Path(self.aprx.filePath).stem\n\n    @property\n    def aprx(self) -&gt; ArcGISProject:\n        \"\"\"Get the base ArcGISProject for the Project\"\"\"\n        return ArcGISProject(self._path)\n\n    @cached_property\n    def maps(self) -&gt; MapManager:\n        \"\"\"Get a MapManager for the Project maps\"\"\"\n        return MapManager(Map(m, self) for m in self.aprx.listMaps())\n\n    @cached_property\n    def layouts(self) -&gt; LayoutManager:\n        \"\"\"Get a LayoutManager for the Project layouts\"\"\"\n        return LayoutManager(Layout(l, self) for l in self.aprx.listLayouts())\n\n    @cached_property\n    def reports(self) -&gt; ReportManager:\n        \"\"\"Get a ReportManager for the Project reports\"\"\"\n        return ReportManager(Report(r, self) for r in self.aprx.listReports())\n\n    @property\n    def broken_layers(self) -&gt; LayerManager:\n        \"\"\"Get a LayerManager for all layers in the project with broken datasources\"\"\"\n        return LayerManager(Layer(l, self) for l in self.aprx.listBrokenDataSources() if isinstance(l, _Layer))\n\n    @property\n    def broken_tables(self) -&gt; TableManager:\n        \"\"\"Get a TableManager for all tables in the project with broken datasources\"\"\"\n        return TableManager(Table(t, self) for t in self.aprx.listBrokenDataSources() if isinstance(t, _Table))\n\n    @property\n    def tree(self) -&gt; dict[str, Any]:\n        return {\n            repr(self) : \n                {\n                    'maps': {\n                        repr(m): \n                            {\n                                'tables': m.tables.names,\n                                'layers': m.layers.names,\n                            }\n                        for m in self.maps\n                    },\n                    'layouts': self.layouts.names,\n                    'reports': self.reports.names,\n                    'broken': {\n                        'layers': self.broken_layers.names,\n                        'tables': self.broken_layers.names,\n                    }\n                }\n        }\n\n    @overload\n    def __getitem__(self, name: str) -&gt; Map | Layout | Report: ...\n    @overload\n    def __getitem__(self, name: Wildcard) -&gt; list[Map] | list[Layout] | list[Report]: ...\n    def __getitem__(self, name: str | Wildcard) -&gt; Any | list[Any]:\n        \"\"\"Resolve the name by looking in Maps, then Layouts, then Reports\"\"\"\n        _obj = self.maps.get(name, None) or self.layouts.get(name, None) or self.reports.get(name, None)\n        if _obj is None:\n            raise KeyError(f'{name} not found in {self.name}')\n        return _obj\n\n    @overload\n    def get(self, name: str, default: _Default) -&gt; Map | Layout | Report | _Default: ...\n    @overload\n    def get(self, name: Wildcard, default: _Default) -&gt; list[Map] | list[Layout] | list[Report] | _Default: ...\n    def get(self, name: str | Wildcard, default: _Default=None) -&gt; Any | _Default:\n        try:\n            return self[name]\n        except KeyError:\n            return default\n\n    def save(self) -&gt; None:\n        \"\"\"Save this project\"\"\"\n        self.aprx.save()\n\n    def save_as(self, path: Path|str) -&gt; Project:\n        \"\"\"Saves the project under a new name\n\n        Args:\n            path (Path|str): The filepath of the new aprx\n\n        Returns:\n            (Project): A Project representing the new project file\n\n        Note:\n            Saving a Project as a new project will not update this instance, and instead returns a new\n            Project instance targeted at the new file\n        \"\"\"\n        path = Path(path)\n        self.aprx.saveACopy(str(path.with_suffix(f'{path.suffix}.aprx')))\n        return Project(path)\n\n    def import_pagx(self, pagx: Path|str, *, reuse_existing_maps: bool=True) -&gt; Layout:\n        \"\"\"Import a pagx file into this project\n\n        Args:\n            pagx (Path|str): The path to the pagx document\n\n        Returns:\n            (Layout): A Layout parented to this project\n        \"\"\"\n        pagx = Path(pagx)\n        if not pagx.suffix == '.pagx':\n            raise ValueError(f'{pagx} is not a pagx file!')\n\n        _imported = self.aprx.importDocument(str(pagx), reuse_existing_maps=reuse_existing_maps)\n        # Ensure that the imported document is a Layout\n        if not isinstance(_imported, _Layout):\n            self.aprx.deleteItem(_imported)\n            raise ValueError(f'{pagx} is not a valid pagx file!')\n\n        self.refresh('layouts')\n        return Layout(_imported, parent=self)\n\n    def export_pagx(self, target_dir: Path|str) -&gt; None:\n        \"\"\"Export all layouts to a directory\"\"\"\n        target_dir = Path(target_dir)\n        target_dir.mkdir(exist_ok=True, parents=True)\n        for layout in self.layouts:\n            (target_dir / f'{layout.unique_name}.pagx').write_text(json.dumps(layout.pagx, indent=2), encoding='utf-8')\n\n    def import_mapx(self, mapx: Path|str) -&gt; Map:\n        \"\"\"Import a mapx file into this project\n\n        Args:\n            mapx (Path|str): The path to the mapx document\n\n        Returns:\n            (Map): A Map parented to this project\n        \"\"\"\n        mapx = Path(mapx)\n        if not mapx.suffix == '.mapx':\n            raise ValueError(f'{mapx} is not a mapx file!')\n\n        _imported = self.aprx.importDocument(str(mapx))\n        # Ensure that the imported document is a Map\n        if not isinstance(_imported, _Map):\n            self.aprx.deleteItem(_imported)\n            raise ValueError(f'{mapx} is not a valid mapx file!')\n\n        self.refresh('maps')\n        return Map(_imported, parent=self)\n\n    def export_mapx(self, target_dir: Path|str) -&gt; None:\n        \"\"\"Export all maps to a directory\"\"\"\n        target_dir = Path(target_dir)\n        target_dir.mkdir(exist_ok=True, parents=True)\n        for m in self.maps:\n            (target_dir / f'{m.unique_name}.mapx').write_text(json.dumps(m.mapx, indent=2), encoding='utf-8')\n\n    def export_layers(self, target_dir: Path|str, *, skip_groups: bool = False, skip_grouped: bool = False) -&gt; None:\n        \"\"\"Export all layers in the project to a structured directory of layerfiles\n\n        Args:\n            target_dir (Path|str): The target directory to export the layerfiles to\n            skip_groups (bool): Skip group layerfiles and export each layer individually in a group subdirectory (default: False)\n            skip_grouped (bool): Inverse of skip groups and instead only exports the group lyrx, skipping the individual layers (default: False)\n        \"\"\"\n        target_dir = Path(target_dir)\n        for m in self.maps:\n            m.export_assoc_lyrx(target_dir, skip_groups=skip_groups, skip_grouped=skip_grouped)\n\n    def import_layers(self, src_dir: Path|str) -&gt; None:\n        \"\"\"Import a structured directory of layerfiles generated with `export_layers`\n\n        Args:\n            src_dir (Path|str): A directory containing layer files in map directories and group directories\n\n        Note:\n            CIM changes require the APRX to be saved to take effect. If you are accessing this\n            layer via a Project, use `project.save()` after importing the layerfile\n        \"\"\"\n        src_dir = Path(src_dir)\n        for m in self.maps:\n            map_dir = src_dir / m.unique_name\n            if not map_dir.exists():\n                print(f'Map {m.unique_name} does not have a valid source in the source directory, skipping')\n                continue\n            m.import_assoc_lyrx(map_dir)\n\n        self.refresh('layers')\n\n    def refresh(self, *managers: str) -&gt; None:\n        \"\"\"Clear cached object managers\n\n        Args:\n            *managers (*str): Optionally limit cache clearing to certain managers (attribute name)\n        \"\"\"\n        for prop in list(self.__dict__):\n            if prop.startswith('_') or managers and prop not in managers:\n                continue # Skip private instance attributes and non-requested\n            self.__dict__.pop(prop, None)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.aprx","title":"<code>aprx</code>  <code>property</code>","text":"<p>Get the base ArcGISProject for the Project</p>"},{"location":"modules/project/#arcpie.project.Project.broken_layers","title":"<code>broken_layers</code>  <code>property</code>","text":"<p>Get a LayerManager for all layers in the project with broken datasources</p>"},{"location":"modules/project/#arcpie.project.Project.broken_tables","title":"<code>broken_tables</code>  <code>property</code>","text":"<p>Get a TableManager for all tables in the project with broken datasources</p>"},{"location":"modules/project/#arcpie.project.Project.layouts","title":"<code>layouts</code>  <code>cached</code> <code>property</code>","text":"<p>Get a LayoutManager for the Project layouts</p>"},{"location":"modules/project/#arcpie.project.Project.maps","title":"<code>maps</code>  <code>cached</code> <code>property</code>","text":"<p>Get a MapManager for the Project maps</p>"},{"location":"modules/project/#arcpie.project.Project.name","title":"<code>name</code>  <code>property</code>","text":"<p>Get the file name of the wrapped aprx minus the file extension</p>"},{"location":"modules/project/#arcpie.project.Project.reports","title":"<code>reports</code>  <code>cached</code> <code>property</code>","text":"<p>Get a ReportManager for the Project reports</p>"},{"location":"modules/project/#arcpie.project.Project.tree","title":"<code>tree</code>  <code>property</code>","text":""},{"location":"modules/project/#arcpie.project.Project.__getitem__","title":"<code>__getitem__(name)</code>","text":"<pre><code>__getitem__(name: str) -&gt; Map | Layout | Report\n</code></pre><pre><code>__getitem__(\n    name: Wildcard,\n) -&gt; list[Map] | list[Layout] | list[Report]\n</code></pre> <p>Resolve the name by looking in Maps, then Layouts, then Reports</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def __getitem__(self, name: str | Wildcard) -&gt; Any | list[Any]:\n    \"\"\"Resolve the name by looking in Maps, then Layouts, then Reports\"\"\"\n    _obj = self.maps.get(name, None) or self.layouts.get(name, None) or self.reports.get(name, None)\n    if _obj is None:\n        raise KeyError(f'{name} not found in {self.name}')\n    return _obj\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.__init__","title":"<code>__init__(aprx_path='CURRENT')</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __init__(self, aprx_path: str|Path|Literal['CURRENT']='CURRENT') -&gt; None:\n    self._path = str(aprx_path)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>src/arcpie/project.py</code> <pre><code>def __repr__(self) -&gt; str:\n    return f\"Project({Path(self.aprx.filePath).stem}.aprx)\"\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.export_layers","title":"<code>export_layers(target_dir, *, skip_groups=False, skip_grouped=False)</code>","text":"<p>Export all layers in the project to a structured directory of layerfiles</p> <p>Parameters:</p> Name Type Description Default <code>target_dir</code> <code>Path | str</code> <p>The target directory to export the layerfiles to</p> required <code>skip_groups</code> <code>bool</code> <p>Skip group layerfiles and export each layer individually in a group subdirectory (default: False)</p> <code>False</code> <code>skip_grouped</code> <code>bool</code> <p>Inverse of skip groups and instead only exports the group lyrx, skipping the individual layers (default: False)</p> <code>False</code> Source code in <code>src/arcpie/project.py</code> <pre><code>def export_layers(self, target_dir: Path|str, *, skip_groups: bool = False, skip_grouped: bool = False) -&gt; None:\n    \"\"\"Export all layers in the project to a structured directory of layerfiles\n\n    Args:\n        target_dir (Path|str): The target directory to export the layerfiles to\n        skip_groups (bool): Skip group layerfiles and export each layer individually in a group subdirectory (default: False)\n        skip_grouped (bool): Inverse of skip groups and instead only exports the group lyrx, skipping the individual layers (default: False)\n    \"\"\"\n    target_dir = Path(target_dir)\n    for m in self.maps:\n        m.export_assoc_lyrx(target_dir, skip_groups=skip_groups, skip_grouped=skip_grouped)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.export_mapx","title":"<code>export_mapx(target_dir)</code>","text":"<p>Export all maps to a directory</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def export_mapx(self, target_dir: Path|str) -&gt; None:\n    \"\"\"Export all maps to a directory\"\"\"\n    target_dir = Path(target_dir)\n    target_dir.mkdir(exist_ok=True, parents=True)\n    for m in self.maps:\n        (target_dir / f'{m.unique_name}.mapx').write_text(json.dumps(m.mapx, indent=2), encoding='utf-8')\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.export_pagx","title":"<code>export_pagx(target_dir)</code>","text":"<p>Export all layouts to a directory</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def export_pagx(self, target_dir: Path|str) -&gt; None:\n    \"\"\"Export all layouts to a directory\"\"\"\n    target_dir = Path(target_dir)\n    target_dir.mkdir(exist_ok=True, parents=True)\n    for layout in self.layouts:\n        (target_dir / f'{layout.unique_name}.pagx').write_text(json.dumps(layout.pagx, indent=2), encoding='utf-8')\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.get","title":"<code>get(name, default=None)</code>","text":"<pre><code>get(\n    name: str, default: _Default\n) -&gt; Map | Layout | Report | _Default\n</code></pre><pre><code>get(\n    name: Wildcard, default: _Default\n) -&gt; list[Map] | list[Layout] | list[Report] | _Default\n</code></pre> Source code in <code>src/arcpie/project.py</code> <pre><code>def get(self, name: str | Wildcard, default: _Default=None) -&gt; Any | _Default:\n    try:\n        return self[name]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.import_layers","title":"<code>import_layers(src_dir)</code>","text":"<p>Import a structured directory of layerfiles generated with <code>export_layers</code></p> <p>Parameters:</p> Name Type Description Default <code>src_dir</code> <code>Path | str</code> <p>A directory containing layer files in map directories and group directories</p> required Note <p>CIM changes require the APRX to be saved to take effect. If you are accessing this layer via a Project, use <code>project.save()</code> after importing the layerfile</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def import_layers(self, src_dir: Path|str) -&gt; None:\n    \"\"\"Import a structured directory of layerfiles generated with `export_layers`\n\n    Args:\n        src_dir (Path|str): A directory containing layer files in map directories and group directories\n\n    Note:\n        CIM changes require the APRX to be saved to take effect. If you are accessing this\n        layer via a Project, use `project.save()` after importing the layerfile\n    \"\"\"\n    src_dir = Path(src_dir)\n    for m in self.maps:\n        map_dir = src_dir / m.unique_name\n        if not map_dir.exists():\n            print(f'Map {m.unique_name} does not have a valid source in the source directory, skipping')\n            continue\n        m.import_assoc_lyrx(map_dir)\n\n    self.refresh('layers')\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.import_mapx","title":"<code>import_mapx(mapx)</code>","text":"<p>Import a mapx file into this project</p> <p>Parameters:</p> Name Type Description Default <code>mapx</code> <code>Path | str</code> <p>The path to the mapx document</p> required <p>Returns:</p> Type Description <code>Map</code> <p>A Map parented to this project</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def import_mapx(self, mapx: Path|str) -&gt; Map:\n    \"\"\"Import a mapx file into this project\n\n    Args:\n        mapx (Path|str): The path to the mapx document\n\n    Returns:\n        (Map): A Map parented to this project\n    \"\"\"\n    mapx = Path(mapx)\n    if not mapx.suffix == '.mapx':\n        raise ValueError(f'{mapx} is not a mapx file!')\n\n    _imported = self.aprx.importDocument(str(mapx))\n    # Ensure that the imported document is a Map\n    if not isinstance(_imported, _Map):\n        self.aprx.deleteItem(_imported)\n        raise ValueError(f'{mapx} is not a valid mapx file!')\n\n    self.refresh('maps')\n    return Map(_imported, parent=self)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.import_pagx","title":"<code>import_pagx(pagx, *, reuse_existing_maps=True)</code>","text":"<p>Import a pagx file into this project</p> <p>Parameters:</p> Name Type Description Default <code>pagx</code> <code>Path | str</code> <p>The path to the pagx document</p> required <p>Returns:</p> Type Description <code>Layout</code> <p>A Layout parented to this project</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def import_pagx(self, pagx: Path|str, *, reuse_existing_maps: bool=True) -&gt; Layout:\n    \"\"\"Import a pagx file into this project\n\n    Args:\n        pagx (Path|str): The path to the pagx document\n\n    Returns:\n        (Layout): A Layout parented to this project\n    \"\"\"\n    pagx = Path(pagx)\n    if not pagx.suffix == '.pagx':\n        raise ValueError(f'{pagx} is not a pagx file!')\n\n    _imported = self.aprx.importDocument(str(pagx), reuse_existing_maps=reuse_existing_maps)\n    # Ensure that the imported document is a Layout\n    if not isinstance(_imported, _Layout):\n        self.aprx.deleteItem(_imported)\n        raise ValueError(f'{pagx} is not a valid pagx file!')\n\n    self.refresh('layouts')\n    return Layout(_imported, parent=self)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.refresh","title":"<code>refresh(*managers)</code>","text":"<p>Clear cached object managers</p> <p>Parameters:</p> Name Type Description Default <code>*managers</code> <code>*str</code> <p>Optionally limit cache clearing to certain managers (attribute name)</p> <code>()</code> Source code in <code>src/arcpie/project.py</code> <pre><code>def refresh(self, *managers: str) -&gt; None:\n    \"\"\"Clear cached object managers\n\n    Args:\n        *managers (*str): Optionally limit cache clearing to certain managers (attribute name)\n    \"\"\"\n    for prop in list(self.__dict__):\n        if prop.startswith('_') or managers and prop not in managers:\n            continue # Skip private instance attributes and non-requested\n        self.__dict__.pop(prop, None)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.save","title":"<code>save()</code>","text":"<p>Save this project</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"Save this project\"\"\"\n    self.aprx.save()\n</code></pre>"},{"location":"modules/project/#arcpie.project.Project.save_as","title":"<code>save_as(path)</code>","text":"<p>Saves the project under a new name</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path | str</code> <p>The filepath of the new aprx</p> required <p>Returns:</p> Type Description <code>Project</code> <p>A Project representing the new project file</p> Note <p>Saving a Project as a new project will not update this instance, and instead returns a new Project instance targeted at the new file</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def save_as(self, path: Path|str) -&gt; Project:\n    \"\"\"Saves the project under a new name\n\n    Args:\n        path (Path|str): The filepath of the new aprx\n\n    Returns:\n        (Project): A Project representing the new project file\n\n    Note:\n        Saving a Project as a new project will not update this instance, and instead returns a new\n        Project instance targeted at the new file\n    \"\"\"\n    path = Path(path)\n    self.aprx.saveACopy(str(path.with_suffix(f'{path.suffix}.aprx')))\n    return Project(path)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Report","title":"<code>Report</code>","text":"<p>               Bases: <code>MappingWrapper[Report, CIMReport]</code>, <code>Report</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Report(MappingWrapper[_Report, CIMReport], _Report): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.ReportManager","title":"<code>ReportManager</code>","text":"<p>               Bases: <code>Manager[Report]</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class ReportManager(Manager[Report]): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.Table","title":"<code>Table</code>","text":"<p>               Bases: <code>MappingWrapper[Table, CIMStandaloneTable]</code>, <code>Table</code></p> <p>Methods:</p> Name Description <code>export_lyrx</code> <p>Export the layer to a lyrx file in the target directory</p> <code>import_lyrx</code> <p>Import the table state from an lyrx file</p> <p>Attributes:</p> Name Type Description <code>cim</code> <code>CIMStandaloneTable</code> <code>lyrx</code> <code>dict[str, Any]</code> <code>table</code> <code>Table</code> <p>Get an <code>arcpie.Table</code> object from the TableLayer</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Table(MappingWrapper[_Table, CIMStandaloneTable], _Table):\n    @property\n    def table(self) -&gt; DataTable:\n        \"\"\"Get an `arcpie.Table` object from the TableLayer\"\"\"\n        return DataTable.from_table(self)\n\n    @property\n    def cim(self) -&gt; CIMStandaloneTable:\n        return super().cim # pyright: ignore[reportReturnType]\n\n    @property\n    def lyrx(self) -&gt; dict[str, Any]:\n        _def = self.cim_dict\n        _lyrx: dict[str, Any] = { # Base required keys for lyrx file\n            'type': 'CIMLayerDocument',\n            'tables': [self.uri],\n            'tableDefinitions': [_def],\n        }\n        return _lyrx\n\n    def export_lyrx(self, out_dir: Path|str) -&gt; None:\n        \"\"\"Export the layer to a lyrx file in the target directory\n\n        Args:\n            out_dir (Path|str): The location to export the lyrx to\n        \"\"\"\n        target = Path(out_dir) / f'{self.longName}.lyrx'\n        # Make Containing directory for grouped layers\n        target.parent.mkdir(exist_ok=True, parents=True)\n        target.write_text(json.dumps(self.lyrx, indent=2), encoding='utf-8')\n\n    def import_lyrx(self, lyrx: Path|str) -&gt; None:\n        \"\"\"Import the table state from an lyrx file\n\n        Args:\n            lyrx (Path|str): The lyrx file to update this table with\n\n        Note:\n            CIM changes require the APRX to be saved to take effect. If you are accessing this\n            layer via a Project, use `project.save()` after importing the layerfile\n        \"\"\"\n        _lyrx = LayerFile(str(lyrx))\n        _lyrx_layers = {t.longName: t for t in _lyrx.listTables()}\n        for table in [self]:\n            _lyrx_table = _lyrx_layers.get(table.longName)\n            if not _lyrx_table:\n                print(f'{self.longName} not found in {str(lyrx)}')\n                continue\n            # Update Connection\n            _lyrx_table.updateConnectionProperties(None, table.connectionProperties) # type: ignore\n            _lyrx_layer_cim = _lyrx_table.getDefinition('V3')\n            self.setDefinition(_lyrx_layer_cim)\n</code></pre>"},{"location":"modules/project/#arcpie.project.Table.cim","title":"<code>cim</code>  <code>property</code>","text":""},{"location":"modules/project/#arcpie.project.Table.lyrx","title":"<code>lyrx</code>  <code>property</code>","text":""},{"location":"modules/project/#arcpie.project.Table.table","title":"<code>table</code>  <code>property</code>","text":"<p>Get an <code>arcpie.Table</code> object from the TableLayer</p>"},{"location":"modules/project/#arcpie.project.Table.export_lyrx","title":"<code>export_lyrx(out_dir)</code>","text":"<p>Export the layer to a lyrx file in the target directory</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>Path | str</code> <p>The location to export the lyrx to</p> required Source code in <code>src/arcpie/project.py</code> <pre><code>def export_lyrx(self, out_dir: Path|str) -&gt; None:\n    \"\"\"Export the layer to a lyrx file in the target directory\n\n    Args:\n        out_dir (Path|str): The location to export the lyrx to\n    \"\"\"\n    target = Path(out_dir) / f'{self.longName}.lyrx'\n    # Make Containing directory for grouped layers\n    target.parent.mkdir(exist_ok=True, parents=True)\n    target.write_text(json.dumps(self.lyrx, indent=2), encoding='utf-8')\n</code></pre>"},{"location":"modules/project/#arcpie.project.Table.import_lyrx","title":"<code>import_lyrx(lyrx)</code>","text":"<p>Import the table state from an lyrx file</p> <p>Parameters:</p> Name Type Description Default <code>lyrx</code> <code>Path | str</code> <p>The lyrx file to update this table with</p> required Note <p>CIM changes require the APRX to be saved to take effect. If you are accessing this layer via a Project, use <code>project.save()</code> after importing the layerfile</p> Source code in <code>src/arcpie/project.py</code> <pre><code>def import_lyrx(self, lyrx: Path|str) -&gt; None:\n    \"\"\"Import the table state from an lyrx file\n\n    Args:\n        lyrx (Path|str): The lyrx file to update this table with\n\n    Note:\n        CIM changes require the APRX to be saved to take effect. If you are accessing this\n        layer via a Project, use `project.save()` after importing the layerfile\n    \"\"\"\n    _lyrx = LayerFile(str(lyrx))\n    _lyrx_layers = {t.longName: t for t in _lyrx.listTables()}\n    for table in [self]:\n        _lyrx_table = _lyrx_layers.get(table.longName)\n        if not _lyrx_table:\n            print(f'{self.longName} not found in {str(lyrx)}')\n            continue\n        # Update Connection\n        _lyrx_table.updateConnectionProperties(None, table.connectionProperties) # type: ignore\n        _lyrx_layer_cim = _lyrx_table.getDefinition('V3')\n        self.setDefinition(_lyrx_layer_cim)\n</code></pre>"},{"location":"modules/project/#arcpie.project.TableManager","title":"<code>TableManager</code>","text":"<p>               Bases: <code>Manager[Table]</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>class TableManager(Manager[Table]): ...\n</code></pre>"},{"location":"modules/project/#arcpie.project.Wildcard","title":"<code>Wildcard</code>","text":"<p>               Bases: <code>UserString</code></p> <p>Clarify that the string passed to a Manager index is a wildcard so the type checker knows you're getting a Sequence back</p> Source code in <code>src/arcpie/project.py</code> <pre><code>class Wildcard(UserString): \n    \"\"\"Clarify that the string passed to a Manager index is a wildcard so the type checker knows you're getting a Sequence back\"\"\"\n    pass\n</code></pre>"},{"location":"modules/project/#arcpie.project.name_of","title":"<code>name_of(o, skip_uri=False, uri_only=False)</code>","text":"<p>Handle the naming hierarchy of mapping objects URI -&gt; longName -&gt; name</p> <p>Allow setting flags to get specific names</p> Note <p>If a URI is requested and no <code>URI</code> attribute is available in object,  <code>'obj.name: NO URI(id(obj))'</code> will be returned, e.g. <code>'my_bookmark: NO URI(1239012093)'</code></p> Source code in <code>src/arcpie/project.py</code> <pre><code>def name_of(o: MappingWrapper[Any, Any], skip_uri: bool=False, uri_only: bool=False) -&gt; str:\n    \"\"\"Handle the naming hierarchy of mapping objects URI -&gt; longName -&gt; name\n\n    Allow setting flags to get specific names\n\n    Note:\n        If a URI is requested and no `URI` attribute is available in object, \n        `'obj.name: NO URI(id(obj))'` will be returned, e.g. `'my_bookmark: NO URI(1239012093)'`\n    \"\"\"\n    _uri: str|None = o.uri if not skip_uri else None\n    _long_name: str|None = getattr(o, 'longName', None) # longName will identify Grouped Layers\n    _name: str|None = getattr(o, 'name', None)\n    _id: str = str(id(o)) # Fallback to a locally unique id (should never happen)\n    if uri_only:\n        return _uri or f\"{id(o)}:NO_URI\"\n    return _uri or _long_name or _name or _id\n</code></pre>"},{"location":"modules/schemas/","title":"schemas","text":""},{"location":"modules/schemas/#arcpie.schemas.layer","title":"<code>layer</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace","title":"<code>workspace</code>","text":"<p>Classes:</p> Name Description <code>SchemaAttributeRule</code> <p>ESRI Attribute Rule Schema</p> <code>SchemaDataset</code> <p>Esri Dataset Schema</p> <code>SchemaDomain</code> <p>ESRI Domain Schema</p> <code>SchemaDomainCode</code> <p>ESRI Domain Code Schema</p> <code>SchemaExtent</code> <p>ESRI Extent Schema</p> <code>SchemaField</code> <p>ESRI Field Schema</p> <code>SchemaFieldInfo</code> <p>ESRI FieldInfo Schema</p> <code>SchemaGeometryDef</code> <p>ESRI Geometry Definition Schema</p> <code>SchemaIndex</code> <p>ESRI Index Schema</p> <code>SchemaIndexArray</code> <p>ESRI Index Array Schema</p> <code>SchemaParcelFabricController</code> <p>ESRI Parcel Fabric Schema</p> <code>SchemaPropertySet</code> <p>ESRI Property Set Schema</p> <code>SchemaRelationshipClasses</code> <p>ESRI Relationship Classes Schema</p> <code>SchemaSpatialRef</code> <p>Esri Spatial Reference Schema</p> <code>SchemaSubtype</code> <p>ESRI Subtype Schema</p> <code>SchemaTopologyController</code> <p>ESRI Topology Controller Schema</p> <code>SchemaTopologyRule</code> <p>ESRI TopologyRule Schema</p> <code>SchemaWorkspace</code> <p>ESRI Workspace Schema</p> <p>Attributes:</p> Name Type Description <code>ESRIAttributeRuleTrigger</code> <code>ESRIAttributeRuleType</code> <code>ESRIClientVersion</code> <code>ESRIDatasetType</code> <code>ESRIDomainMergePolicy</code> <code>ESRIDomainSplitPolicy</code> <code>ESRIDomainType</code> <code>ESRIExtensionType</code> <code>ESRIFeatureType</code> <code>ESRIFieldType</code> <code>ESRIGeometryType</code> <code>ESRISplitModel</code> <code>ESRITopologyRuleType</code> <code>ESRIWorkspaceProgID</code> <code>ESRIWorkspaceType</code> <code>SchemaFieldArray</code>"},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIAttributeRuleTrigger","title":"<code>ESRIAttributeRuleTrigger = Literal['esriARTEUpdate', 'esriARTEInsert', 'esriARTEDelete']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIAttributeRuleType","title":"<code>ESRIAttributeRuleType = Literal['esriARTCalculation', 'esriARTValidation', 'esriARTConstraint']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIClientVersion","title":"<code>ESRIClientVersion = Literal['10.0', '12.3']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIDatasetType","title":"<code>ESRIDatasetType = Literal['DEWorkspace', 'esriDTFeatureClass', 'esriDTTable', 'esriDTTopology']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIDomainMergePolicy","title":"<code>ESRIDomainMergePolicy = Literal['esriMPTDefaultValue']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIDomainSplitPolicy","title":"<code>ESRIDomainSplitPolicy = Literal['esriSPTDuplicate']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIDomainType","title":"<code>ESRIDomainType = Literal['codedValue']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIExtensionType","title":"<code>ESRIExtensionType = Literal['PropertySet']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIFeatureType","title":"<code>ESRIFeatureType = Literal['esriFTSimple']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIFieldType","title":"<code>ESRIFieldType = Literal['esriFieldTypeOID', 'esriFieldTypeString', 'esriFieldTypeInteger', 'esriFieldTypeDouble', 'esriFieldTypeGeometry']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIGeometryType","title":"<code>ESRIGeometryType = Literal['esriGeometryPolyline']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRISplitModel","title":"<code>ESRISplitModel = Literal['esriSMUpdateInsert']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRITopologyRuleType","title":"<code>ESRITopologyRuleType = Literal['esriTRTPointCoveredByLineEndpoint', 'esriTRTPointCoveredByLine', 'esriTRTPointCoincidePoint', 'esriTRTLineCoveredByLineClass', 'esriTRTLineEndpointCoveredByPoint', 'esriTRTLineNoMultipart', 'esriTRTLineNoSelfIntersect', 'esriTRTLineNoSelfOverlap']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIWorkspaceProgID","title":"<code>ESRIWorkspaceProgID = Literal['esriDataSourcesGDB.FileGDBWorkspaceFactory']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.ESRIWorkspaceType","title":"<code>ESRIWorkspaceType = Literal['esriLocalDatabaseWorkspace']</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaFieldArray","title":"<code>SchemaFieldArray = dict[Literal['fieldArray'], list[SchemaField]]</code>  <code>module-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule","title":"<code>SchemaAttributeRule</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Attribute Rule Schema</p> <p>Attributes:</p> Name Type Description <code>batch</code> <code>bool</code> <code>category</code> <code>int</code> <code>checkParameters</code> <code>SchemaPropertySet</code> <code>creationTime</code> <code>int</code> <code>description</code> <code>str</code> <code>errorMessage</code> <code>str</code> <code>errorNumber</code> <code>int</code> <code>evaluationOrder</code> <code>int</code> <code>excludeFromClientEvaluation</code> <code>bool</code> <code>fieldName</code> <code>str</code> <code>id</code> <code>int</code> <code>isEnabled</code> <code>bool</code> <code>name</code> <code>str</code> <code>referencesExternalService</code> <code>bool</code> <code>requiredGeodatabaseClientVersion</code> <code>ESRIClientVersion</code> <code>scriptExpression</code> <code>str</code> <code>severity</code> <code>int</code> <code>subtypeCode</code> <code>int</code> <code>subtypeCodes</code> <code>list[int]</code> <code>tags</code> <code>str</code> <code>triggeringEvents</code> <code>list[ESRIAttributeRuleTrigger]</code> <code>triggeringFields</code> <code>list[str]</code> <code>type</code> <code>ESRIAttributeRuleType</code> <code>userEditable</code> <code>bool</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaAttributeRule(TypedDict):\n    \"\"\"ESRI Attribute Rule Schema\"\"\"\n    id: int\n    name: str\n    type: ESRIAttributeRuleType\n    evaluationOrder: int\n    fieldName: str\n    subtypeCode: int\n    description: str\n    errorNumber: int\n    errorMessage: str\n    userEditable: bool\n    isEnabled: bool\n    referencesExternalService: bool\n    excludeFromClientEvaluation: bool\n    scriptExpression: str\n    triggeringEvents: list[ESRIAttributeRuleTrigger]\n    checkParameters: SchemaPropertySet\n    category: int\n    severity: int\n    tags: str\n    batch: bool\n    requiredGeodatabaseClientVersion: ESRIClientVersion\n    creationTime: int\n    triggeringFields: list[str]\n    subtypeCodes: list[int]\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.batch","title":"<code>batch</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.category","title":"<code>category</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.checkParameters","title":"<code>checkParameters</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.creationTime","title":"<code>creationTime</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.description","title":"<code>description</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.errorMessage","title":"<code>errorMessage</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.errorNumber","title":"<code>errorNumber</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.evaluationOrder","title":"<code>evaluationOrder</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.excludeFromClientEvaluation","title":"<code>excludeFromClientEvaluation</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.fieldName","title":"<code>fieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.id","title":"<code>id</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.isEnabled","title":"<code>isEnabled</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.referencesExternalService","title":"<code>referencesExternalService</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.requiredGeodatabaseClientVersion","title":"<code>requiredGeodatabaseClientVersion</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.scriptExpression","title":"<code>scriptExpression</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.severity","title":"<code>severity</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.subtypeCode","title":"<code>subtypeCode</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.subtypeCodes","title":"<code>subtypeCodes</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.tags","title":"<code>tags</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.triggeringEvents","title":"<code>triggeringEvents</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.triggeringFields","title":"<code>triggeringFields</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.type","title":"<code>type</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaAttributeRule.userEditable","title":"<code>userEditable</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset","title":"<code>SchemaDataset</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Esri Dataset Schema</p> <p>Attributes:</p> Name Type Description <code>aliasName</code> <code>str</code> <code>areaFieldName</code> <code>str</code> <code>attributeRules</code> <code>list[SchemaAttributeRule]</code> <code>canVersion</code> <code>bool</code> <code>catalogID</code> <code>str</code> <code>catalogPath</code> <code>str</code> <code>changeTracked</code> <code>bool</code> <code>childrenExpanded</code> <code>bool</code> <code>clsId</code> <code>str</code> <code>clusterTolerance</code> <code>float</code> <code>configurationKeyword</code> <code>str</code> <code>controllerMemberships</code> <code>list[SchemaTopologyController | SchemaParcelFabricController]</code> <code>createdAtFieldName</code> <code>str</code> <code>creatorFieldName</code> <code>str</code> <code>datasetType</code> <code>ESRIDatasetType</code> <code>defaultSubtypeCode</code> <code>int</code> <code>dsId</code> <code>int</code> <code>editedAtFieldName</code> <code>str</code> <code>editorTrackingEnabled</code> <code>bool</code> <code>extClsId</code> <code>str</code> <code>extensionProperties</code> <code>SchemaPropertySet</code> <code>extent</code> <code>SchemaExtent</code> <code>featureType</code> <code>ESRIFeatureType</code> <code>fieldFilteringEnabled</code> <code>bool</code> <code>fields</code> <code>SchemaFieldArray</code> <code>globalIdFieldName</code> <code>str</code> <code>hasGlobalID</code> <code>bool</code> <code>hasM</code> <code>bool</code> <code>hasOID</code> <code>bool</code> <code>hasOID64</code> <code>bool</code> <code>hasSpatialIndex</code> <code>bool</code> <code>hasZ</code> <code>bool</code> <code>indexes</code> <code>SchemaIndexArray</code> <code>isTimeInUTC</code> <code>bool</code> <code>lastEditorFieldName</code> <code>str</code> <code>layers</code> <code>list[dict[Literal['layerId'], str]]</code> <code>lengthFieldName</code> <code>str</code> <code>maxGeneratedErrorCount</code> <code>int</code> <code>modelName</code> <code>str</code> <code>name</code> <code>str</code> <code>oidFieldName</code> <code>str</code> <code>rasterFieldName</code> <code>str</code> <code>relationshipClassNames</code> <code>SchemaRelationshipClasses</code> <code>replicaTracked</code> <code>bool</code> <code>requiredGeodatabaseClientVersion</code> <code>ESRIClientVersion</code> <code>shapeFieldName</code> <code>str</code> <code>shapeType</code> <code>ESRIGeometryType</code> <code>spatialReference</code> <code>SchemaSpatialRef</code> <code>splitModel</code> <code>ESRISplitModel</code> <code>subtypeFieldName</code> <code>str</code> <code>subtypes</code> <code>list[SchemaSubtype]</code> <code>topologyRules</code> <code>list[SchemaTopologyRule]</code> <code>versioned</code> <code>bool</code> <code>zClusterTolerance</code> <code>float</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaDataset(TypedDict):\n    \"\"\"Esri Dataset Schema\"\"\"\n    catalogPath: str\n    name: str\n    childrenExpanded: bool\n    datasetType: ESRIDatasetType\n    dsId: int\n    versioned: bool\n    canVersion: bool\n    configurationKeyword: str\n    requiredGeodatabaseClientVersion: ESRIClientVersion\n    changeTracked: bool\n    replicaTracked: bool\n    hasOID: bool\n    hasOID64: bool\n    oidFieldName: str\n    fields: SchemaFieldArray\n    indexes: SchemaIndexArray\n    clsId: str\n    extClsId: str\n    relationshipClassNames: SchemaRelationshipClasses\n    aliasName: str\n    modelName: str\n    hasGlobalID: bool\n    globalIdFieldName: str\n    rasterFieldName: str\n    extensionProperties: SchemaPropertySet\n    subtypeFieldName: str\n    defaultSubtypeCode: int\n    subtypes: list[SchemaSubtype]\n    controllerMemberships: list[SchemaTopologyController | SchemaParcelFabricController]\n    editorTrackingEnabled: bool\n    creatorFieldName: str\n    createdAtFieldName: str\n    lastEditorFieldName: str\n    editedAtFieldName: str\n    isTimeInUTC: bool\n    catalogID: str\n    fieldFilteringEnabled: bool\n    attributeRules: list[SchemaAttributeRule]\n    featureType: ESRIFeatureType\n    shapeType: ESRIGeometryType\n    shapeFieldName: str\n    hasM: bool\n    hasZ: bool\n    hasSpatialIndex: bool\n    areaFieldName: str\n    lengthFieldName: str\n    extent: SchemaExtent\n    spatialReference: SchemaSpatialRef\n    splitModel: ESRISplitModel\n\n    # Topology Keys (Move to a new TypedDict?)\n    layers: list[dict[Literal['layerId'], str]]\n    clusterTolerance: float\n    zClusterTolerance: float\n    maxGeneratedErrorCount: int\n    topologyRules: list[SchemaTopologyRule]\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.aliasName","title":"<code>aliasName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.areaFieldName","title":"<code>areaFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.attributeRules","title":"<code>attributeRules</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.canVersion","title":"<code>canVersion</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.catalogID","title":"<code>catalogID</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.catalogPath","title":"<code>catalogPath</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.changeTracked","title":"<code>changeTracked</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.childrenExpanded","title":"<code>childrenExpanded</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.clsId","title":"<code>clsId</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.clusterTolerance","title":"<code>clusterTolerance</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.configurationKeyword","title":"<code>configurationKeyword</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.controllerMemberships","title":"<code>controllerMemberships</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.createdAtFieldName","title":"<code>createdAtFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.creatorFieldName","title":"<code>creatorFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.datasetType","title":"<code>datasetType</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.defaultSubtypeCode","title":"<code>defaultSubtypeCode</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.dsId","title":"<code>dsId</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.editedAtFieldName","title":"<code>editedAtFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.editorTrackingEnabled","title":"<code>editorTrackingEnabled</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.extClsId","title":"<code>extClsId</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.extensionProperties","title":"<code>extensionProperties</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.extent","title":"<code>extent</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.featureType","title":"<code>featureType</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.fieldFilteringEnabled","title":"<code>fieldFilteringEnabled</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.fields","title":"<code>fields</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.globalIdFieldName","title":"<code>globalIdFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.hasGlobalID","title":"<code>hasGlobalID</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.hasM","title":"<code>hasM</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.hasOID","title":"<code>hasOID</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.hasOID64","title":"<code>hasOID64</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.hasSpatialIndex","title":"<code>hasSpatialIndex</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.hasZ","title":"<code>hasZ</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.indexes","title":"<code>indexes</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.isTimeInUTC","title":"<code>isTimeInUTC</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.lastEditorFieldName","title":"<code>lastEditorFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.layers","title":"<code>layers</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.lengthFieldName","title":"<code>lengthFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.maxGeneratedErrorCount","title":"<code>maxGeneratedErrorCount</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.modelName","title":"<code>modelName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.oidFieldName","title":"<code>oidFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.rasterFieldName","title":"<code>rasterFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.relationshipClassNames","title":"<code>relationshipClassNames</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.replicaTracked","title":"<code>replicaTracked</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.requiredGeodatabaseClientVersion","title":"<code>requiredGeodatabaseClientVersion</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.shapeFieldName","title":"<code>shapeFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.shapeType","title":"<code>shapeType</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.spatialReference","title":"<code>spatialReference</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.splitModel","title":"<code>splitModel</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.subtypeFieldName","title":"<code>subtypeFieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.subtypes","title":"<code>subtypes</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.topologyRules","title":"<code>topologyRules</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.versioned","title":"<code>versioned</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDataset.zClusterTolerance","title":"<code>zClusterTolerance</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomain","title":"<code>SchemaDomain</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Domain Schema</p> <p>Attributes:</p> Name Type Description <code>codedValues</code> <code>list[SchemaDomainCode]</code> <code>description</code> <code>str</code> <code>domainName</code> <code>str</code> <code>fieldType</code> <code>ESRIFieldType</code> <code>mergePolicy</code> <code>ESRIDomainMergePolicy</code> <code>splitPolicy</code> <code>ESRIDomainSplitPolicy</code> <code>type</code> <code>ESRIDomainType</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaDomain(TypedDict):\n    \"\"\"ESRI Domain Schema\"\"\"\n    type: ESRIDomainType\n    domainName: str\n    description: str\n    codedValues: list[SchemaDomainCode]\n    fieldType: ESRIFieldType\n    mergePolicy: ESRIDomainMergePolicy\n    splitPolicy: ESRIDomainSplitPolicy\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomain.codedValues","title":"<code>codedValues</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomain.description","title":"<code>description</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomain.domainName","title":"<code>domainName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomain.fieldType","title":"<code>fieldType</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomain.mergePolicy","title":"<code>mergePolicy</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomain.splitPolicy","title":"<code>splitPolicy</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomain.type","title":"<code>type</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomainCode","title":"<code>SchemaDomainCode</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Domain Code Schema</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>str</code> <code>name</code> <code>str</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaDomainCode(TypedDict):\n    \"\"\"ESRI Domain Code Schema\"\"\"\n    name: str\n    code: str\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomainCode.code","title":"<code>code</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaDomainCode.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaExtent","title":"<code>SchemaExtent</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Extent Schema</p> <p>Attributes:</p> Name Type Description <code>spatialReference</code> <code>SchemaSpatialRef</code> <code>xmax</code> <code>float | Literal['NaN']</code> <code>xmin</code> <code>float | Literal['NaN']</code> <code>ymax</code> <code>float | Literal['NaN']</code> <code>ymin</code> <code>float | Literal['NaN']</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaExtent(TypedDict):\n    \"\"\"ESRI Extent Schema\"\"\"\n    xmin: float | Literal['NaN']\n    ymin: float | Literal['NaN']\n    xmax: float | Literal['NaN']\n    ymax: float | Literal['NaN']\n    spatialReference: SchemaSpatialRef\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaExtent.spatialReference","title":"<code>spatialReference</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaExtent.xmax","title":"<code>xmax</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaExtent.xmin","title":"<code>xmin</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaExtent.ymax","title":"<code>ymax</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaExtent.ymin","title":"<code>ymin</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField","title":"<code>SchemaField</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Field Schema</p> <p>Attributes:</p> Name Type Description <code>aliasName</code> <code>str</code> <code>domain</code> <code>SchemaDomain</code> <code>editable</code> <code>bool</code> <code>geometryDef</code> <code>SchemaGeometryDef</code> <code>isNullable</code> <code>bool</code> <code>length</code> <code>int</code> <code>name</code> <code>str</code> <code>precision</code> <code>int</code> <code>required</code> <code>bool</code> <code>scale</code> <code>int</code> <code>type</code> <code>ESRIFieldType</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaField(TypedDict, total=False):\n    \"\"\"ESRI Field Schema\"\"\"\n    name: str\n    type: ESRIFieldType\n    isNullable: bool\n    length: int\n    precision: int\n    scale: int\n    required: bool\n    editable: bool\n    aliasName: str\n    geometryDef: SchemaGeometryDef\n    domain: SchemaDomain\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.aliasName","title":"<code>aliasName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.domain","title":"<code>domain</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.editable","title":"<code>editable</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.geometryDef","title":"<code>geometryDef</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.isNullable","title":"<code>isNullable</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.length","title":"<code>length</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.precision","title":"<code>precision</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.required","title":"<code>required</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.scale","title":"<code>scale</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaField.type","title":"<code>type</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaFieldInfo","title":"<code>SchemaFieldInfo</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI FieldInfo Schema</p> <p>Attributes:</p> Name Type Description <code>defaultValue</code> <code>Any</code> <code>domainName</code> <code>str</code> <code>fieldName</code> <code>str</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaFieldInfo(TypedDict):\n    \"\"\"ESRI FieldInfo Schema\"\"\"\n    fieldName: str\n    domainName: str\n    defaultValue: Any\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaFieldInfo.defaultValue","title":"<code>defaultValue</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaFieldInfo.domainName","title":"<code>domainName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaFieldInfo.fieldName","title":"<code>fieldName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaGeometryDef","title":"<code>SchemaGeometryDef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Geometry Definition Schema</p> <p>Attributes:</p> Name Type Description <code>avgNumPoints</code> <code>int</code> <code>geometryType</code> <code>ESRIGeometryType</code> <code>gridSize0</code> <code>int</code> <code>hasM</code> <code>bool</code> <code>hasZ</code> <code>bool</code> <code>spatialReference</code> <code>SchemaSpatialRef</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaGeometryDef(TypedDict):\n    \"\"\"ESRI Geometry Definition Schema\"\"\"\n    avgNumPoints: int\n    geometryType: ESRIGeometryType\n    hasM: bool\n    hasZ: bool\n    spatialReference: SchemaSpatialRef\n    gridSize0: int\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaGeometryDef.avgNumPoints","title":"<code>avgNumPoints</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaGeometryDef.geometryType","title":"<code>geometryType</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaGeometryDef.gridSize0","title":"<code>gridSize0</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaGeometryDef.hasM","title":"<code>hasM</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaGeometryDef.hasZ","title":"<code>hasZ</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaGeometryDef.spatialReference","title":"<code>spatialReference</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaIndex","title":"<code>SchemaIndex</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Index Schema</p> <p>Attributes:</p> Name Type Description <code>fields</code> <code>SchemaFieldArray</code> <code>isAscending</code> <code>bool</code> <code>isUnique</code> <code>bool</code> <code>name</code> <code>str</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaIndex(TypedDict):\n    \"\"\"ESRI Index Schema\"\"\"\n    name: str\n    isUnique: bool\n    isAscending: bool\n    fields: SchemaFieldArray\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaIndex.fields","title":"<code>fields</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaIndex.isAscending","title":"<code>isAscending</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaIndex.isUnique","title":"<code>isUnique</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaIndex.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaIndexArray","title":"<code>SchemaIndexArray</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Index Array Schema</p> <p>Attributes:</p> Name Type Description <code>indexArray</code> <code>list[SchemaIndex]</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaIndexArray(TypedDict):\n    \"\"\"ESRI Index Array Schema\"\"\"\n    indexArray: list[SchemaIndex]\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaIndexArray.indexArray","title":"<code>indexArray</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaParcelFabricController","title":"<code>SchemaParcelFabricController</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Parcel Fabric Schema</p> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaParcelFabricController(TypedDict):\n    \"\"\"ESRI Parcel Fabric Schema\"\"\"\n    ...\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaPropertySet","title":"<code>SchemaPropertySet</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Property Set Schema</p> <p>Attributes:</p> Name Type Description <code>propertySetItems</code> <code>list[Any]</code> <code>type</code> <code>Literal['PropertySet']</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaPropertySet(TypedDict):\n    \"\"\"ESRI Property Set Schema\"\"\"\n    type: Literal['PropertySet']\n    propertySetItems: list[Any]\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaPropertySet.propertySetItems","title":"<code>propertySetItems</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaPropertySet.type","title":"<code>type</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaRelationshipClasses","title":"<code>SchemaRelationshipClasses</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Relationship Classes Schema</p> <p>Attributes:</p> Name Type Description <code>names</code> <code>list[str]</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaRelationshipClasses(TypedDict):\n    \"\"\"ESRI Relationship Classes Schema\"\"\"\n    names: list[str]\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaRelationshipClasses.names","title":"<code>names</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaSpatialRef","title":"<code>SchemaSpatialRef</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Esri Spatial Reference Schema</p> <p>Attributes:</p> Name Type Description <code>latestWkid</code> <code>int</code> <code>wkid</code> <code>int</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaSpatialRef(TypedDict):\n    \"\"\"Esri Spatial Reference Schema\"\"\"\n    wkid: int\n    latestWkid: int\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaSpatialRef.latestWkid","title":"<code>latestWkid</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaSpatialRef.wkid","title":"<code>wkid</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaSubtype","title":"<code>SchemaSubtype</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Subtype Schema</p> <p>Attributes:</p> Name Type Description <code>fieldInfos</code> <code>list[SchemaFieldInfo]</code> <code>subtypeCode</code> <code>int</code> <code>subtypeName</code> <code>str</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaSubtype(TypedDict):\n    \"\"\"ESRI Subtype Schema\"\"\"\n    subtypeName: str\n    subtypeCode: int\n    fieldInfos: list[SchemaFieldInfo]\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaSubtype.fieldInfos","title":"<code>fieldInfos</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaSubtype.subtypeCode","title":"<code>subtypeCode</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaSubtype.subtypeName","title":"<code>subtypeName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyController","title":"<code>SchemaTopologyController</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Topology Controller Schema</p> <p>Attributes:</p> Name Type Description <code>eventNotificationOnValidate</code> <code>bool</code> <code>topologyName</code> <code>str</code> <code>weight</code> <code>int</code> <code>xyRank</code> <code>int</code> <code>zRank</code> <code>int</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaTopologyController(TypedDict):\n    \"\"\"ESRI Topology Controller Schema\"\"\"\n    topologyName: str\n    weight: int\n    xyRank: int\n    zRank: int\n    eventNotificationOnValidate: bool\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyController.eventNotificationOnValidate","title":"<code>eventNotificationOnValidate</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyController.topologyName","title":"<code>topologyName</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyController.weight","title":"<code>weight</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyController.xyRank","title":"<code>xyRank</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyController.zRank","title":"<code>zRank</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule","title":"<code>SchemaTopologyRule</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI TopologyRule Schema</p> <p>Attributes:</p> Name Type Description <code>allDestinationSubtypes</code> <code>bool</code> <code>allOriginSubtypes</code> <code>bool</code> <code>destinationClassID</code> <code>int</code> <code>guid</code> <code>str</code> <code>helpString</code> <code>str</code> <code>name</code> <code>str</code> <code>originClassID</code> <code>int</code> <code>originSubtype</code> <code>int</code> <code>ruleId</code> <code>int</code> <code>topologyRuleType</code> <code>ESRITopologyRuleType</code> <code>triggerErrorEvents</code> <code>bool</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaTopologyRule(TypedDict):\n    \"\"\"ESRI TopologyRule Schema\"\"\"\n    helpString: str\n    ruleId: int\n    name: str\n    guid: str\n    originClassID: int\n    destinationClassID: int\n    originSubtype: int\n    triggerErrorEvents: bool\n    allOriginSubtypes: bool\n    allDestinationSubtypes: bool\n    topologyRuleType: ESRITopologyRuleType\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.allDestinationSubtypes","title":"<code>allDestinationSubtypes</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.allOriginSubtypes","title":"<code>allOriginSubtypes</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.destinationClassID","title":"<code>destinationClassID</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.guid","title":"<code>guid</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.helpString","title":"<code>helpString</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.originClassID","title":"<code>originClassID</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.originSubtype","title":"<code>originSubtype</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.ruleId","title":"<code>ruleId</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.topologyRuleType","title":"<code>topologyRuleType</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaTopologyRule.triggerErrorEvents","title":"<code>triggerErrorEvents</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace","title":"<code>SchemaWorkspace</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>ESRI Workspace Schema</p> <p>Attributes:</p> Name Type Description <code>bugfixVersion</code> <code>int</code> <code>catalogPath</code> <code>str</code> <code>childrenExpanded</code> <code>bool</code> <code>connectionString</code> <code>str</code> <code>datasetType</code> <code>Literal['DEWorkspace']</code> <code>datasets</code> <code>list[SchemaDataset]</code> <code>domains</code> <code>list[SchemaDomain]</code> <code>majorVersion</code> <code>int</code> <code>maxAttributeRuleID</code> <code>int</code> <code>minorVersion</code> <code>int</code> <code>name</code> <code>str</code> <code>realm</code> <code>str</code> <code>workspaceFactoryProgID</code> <code>ESRIWorkspaceProgID</code> <code>workspaceType</code> <code>ESRIWorkspaceType</code> Source code in <code>src/arcpie/schemas/workspace.py</code> <pre><code>class SchemaWorkspace(TypedDict):\n    \"\"\"ESRI Workspace Schema\"\"\"\n    datasetType: Literal['DEWorkspace']\n    catalogPath: str\n    name: str\n    childrenExpanded: bool\n    workspaceType: ESRIWorkspaceType\n    workspaceFactoryProgID: ESRIWorkspaceProgID\n    connectionString: str\n    majorVersion: int\n    minorVersion: int\n    bugfixVersion: int\n    realm: str\n    maxAttributeRuleID: int\n    domains: list[SchemaDomain]\n    datasets: list[SchemaDataset]\n</code></pre>"},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.bugfixVersion","title":"<code>bugfixVersion</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.catalogPath","title":"<code>catalogPath</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.childrenExpanded","title":"<code>childrenExpanded</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.connectionString","title":"<code>connectionString</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.datasetType","title":"<code>datasetType</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.datasets","title":"<code>datasets</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.domains","title":"<code>domains</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.majorVersion","title":"<code>majorVersion</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.maxAttributeRuleID","title":"<code>maxAttributeRuleID</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.minorVersion","title":"<code>minorVersion</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.realm","title":"<code>realm</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.workspaceFactoryProgID","title":"<code>workspaceFactoryProgID</code>  <code>instance-attribute</code>","text":""},{"location":"modules/schemas/#arcpie.schemas.workspace.SchemaWorkspace.workspaceType","title":"<code>workspaceType</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/","title":"toolbox","text":"<p>Classes:</p> Name Description <code>Done</code> <p>An Empty Output parameter that can be used to signal that a tool has completed in Model Builder</p> <code>Double</code> <p>Simple Double/Float parameter with default and filter passthroughs</p> <code>FeatureLayer</code> <p>Simple Feature Layer parameter with filter and default passthroughs</p> <code>FilePath</code> <p>Simple filepath input with default and filter passthroughs</p> <code>Folder</code> <p>Simple Feature Layer parameter with filter and default passthroughs</p> <code>Integer</code> <p>Simple Integer number parameter with default and filter passthroughs</p> <code>Parameter</code> <code>Parameters</code> <p>Wrap a list of parameters and override the index to allow indexing by name</p> <code>String</code> <p>Simple string input parameter with filter options and default passthrough</p> <code>StringList</code> <p>Simple string list with default and filter passthroughs</p> <code>Toggle</code> <p>Simple toggle button with a name and default state</p> <code>Tool</code> <code>ToolABC</code> <code>ToolboxABC</code> <p>Functions:</p> Name Description <code>safe_load</code> <p>Safely load in tools to a toolbox placing all failed imports in a <code>Broken Tools</code> category</p> <code>toolify</code> <p>Convert a typed function into a tool for the specified Toolbox class</p> <p>Attributes:</p> Name Type Description <code>ParameterTypeMap</code>"},{"location":"modules/toolbox/#arcpie.toolbox.ParameterTypeMap","title":"<code>ParameterTypeMap = dict[str, tuple[ParameterDatatype | list[ParameterDatatype] | Parameter, Callable[[Parameter], Any]]]</code>  <code>module-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.Done","title":"<code>Done</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>An Empty Output parameter that can be used to signal that a tool has completed in Model Builder</p> <p>Methods:</p> Name Description <code>__init__</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class Done(Parameter):\n    \"\"\"An Empty Output parameter that can be used to signal that a tool has completed in Model Builder\"\"\"\n    def __init__(self) -&gt; None:\n        self.__class__.__name__ =  __name__ = 'Parameter'\n        super().__init__(\n            displayName='Done',\n            name='done',\n            direction='Output',\n            parameterType='Derived',\n        )\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Done.__init__","title":"<code>__init__()</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.__class__.__name__ =  __name__ = 'Parameter'\n    super().__init__(\n        displayName='Done',\n        name='done',\n        direction='Output',\n        parameterType='Derived',\n    )\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Double","title":"<code>Double</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Simple Double/Float parameter with default and filter passthroughs</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>__name__</code> <code>value</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class Double(Parameter):\n    \"\"\"Simple Double/Float parameter with default and filter passthroughs\"\"\"\n    __name__ = 'Parameter'\n    def __init__(self, displayName: str, \n                 options: list[float]|None=None, \n                 default: float|None=None,\n                 required: bool=True,\n                 name: str|None=None,\n                 category: str|None=None) -&gt; None:\n\n        self.__class__.__name__ =  __name__ = 'Parameter'\n        super().__init__(\n            displayName=displayName,\n            # Snake Case the name\n            name=name or displayName.lower().replace(' ', '_'),\n            parameterType='Required' if required else 'Optional',\n            datatype='GPDouble',\n            direction='Input',\n            category=category,\n        )\n        if self.filter and options:\n            self.filter.list = options\n        if default is not None:\n            self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Double.__name__","title":"<code>__name__ = 'Parameter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.Double.value","title":"<code>value = default</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.Double.__init__","title":"<code>__init__(displayName, options=None, default=None, required=True, name=None, category=None)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self, displayName: str, \n             options: list[float]|None=None, \n             default: float|None=None,\n             required: bool=True,\n             name: str|None=None,\n             category: str|None=None) -&gt; None:\n\n    self.__class__.__name__ =  __name__ = 'Parameter'\n    super().__init__(\n        displayName=displayName,\n        # Snake Case the name\n        name=name or displayName.lower().replace(' ', '_'),\n        parameterType='Required' if required else 'Optional',\n        datatype='GPDouble',\n        direction='Input',\n        category=category,\n    )\n    if self.filter and options:\n        self.filter.list = options\n    if default is not None:\n        self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.FeatureLayer","title":"<code>FeatureLayer</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Simple Feature Layer parameter with filter and default passthroughs</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>__name__</code> <code>controlCLSID</code> <code>value</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class FeatureLayer(Parameter):\n    \"\"\"Simple Feature Layer parameter with filter and default passthroughs\"\"\"\n    __name__ = 'Parameter'\n    def __init__(self, displayName: str, \n                 options: list[str]|None=None,\n                 default: str|None=None,\n                 required: bool=True,\n                 name: str|None=None,\n                 allow_create: bool=False,\n                 category: str|None=None) -&gt; None:\n\n        self.__class__.__name__ =  __name__ = 'Parameter'\n        super().__init__(\n            displayName=displayName,\n            # Snake Case the name\n            name=name or displayName.lower().replace(' ', '_'),\n            parameterType='Required' if required else 'Optional',\n            datatype='GPFeatureLayer',\n            direction='Input',\n            category=category,\n        )\n        if self.filter and options:\n            self.filter.list = options\n        if default is not None:\n            self.value = default\n        if allow_create:\n            self.controlCLSID = '{60061247-BCA8-473E-A7AF-A2026DDE1C2D}'\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.FeatureLayer.__name__","title":"<code>__name__ = 'Parameter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.FeatureLayer.controlCLSID","title":"<code>controlCLSID = '{60061247-BCA8-473E-A7AF-A2026DDE1C2D}'</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.FeatureLayer.value","title":"<code>value = default</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.FeatureLayer.__init__","title":"<code>__init__(displayName, options=None, default=None, required=True, name=None, allow_create=False, category=None)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self, displayName: str, \n             options: list[str]|None=None,\n             default: str|None=None,\n             required: bool=True,\n             name: str|None=None,\n             allow_create: bool=False,\n             category: str|None=None) -&gt; None:\n\n    self.__class__.__name__ =  __name__ = 'Parameter'\n    super().__init__(\n        displayName=displayName,\n        # Snake Case the name\n        name=name or displayName.lower().replace(' ', '_'),\n        parameterType='Required' if required else 'Optional',\n        datatype='GPFeatureLayer',\n        direction='Input',\n        category=category,\n    )\n    if self.filter and options:\n        self.filter.list = options\n    if default is not None:\n        self.value = default\n    if allow_create:\n        self.controlCLSID = '{60061247-BCA8-473E-A7AF-A2026DDE1C2D}'\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.FilePath","title":"<code>FilePath</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Simple filepath input with default and filter passthroughs</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>value</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class FilePath(Parameter):\n    \"\"\"Simple filepath input with default and filter passthroughs\"\"\"\n    def __init__(self, displayName: str, \n                 options: list[str]|None=None, \n                 default: str|None=None,\n                 required: bool=True,\n                 name: str|None=None,\n                 category: str|None=None) -&gt; None:\n\n        self.__class__.__name__ =  __name__ = 'Parameter'\n        super().__init__(\n            displayName=displayName,\n            # Snake Case the name\n            name=name or displayName.lower().replace(' ', '_'),\n            parameterType='Required' if required else 'Optional',\n            datatype='DEFile',\n            direction='Input',\n            category=category,\n        )\n        if self.filter and options:\n            self.filter.list = options\n        if default is not None:\n            self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.FilePath.value","title":"<code>value = default</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.FilePath.__init__","title":"<code>__init__(displayName, options=None, default=None, required=True, name=None, category=None)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self, displayName: str, \n             options: list[str]|None=None, \n             default: str|None=None,\n             required: bool=True,\n             name: str|None=None,\n             category: str|None=None) -&gt; None:\n\n    self.__class__.__name__ =  __name__ = 'Parameter'\n    super().__init__(\n        displayName=displayName,\n        # Snake Case the name\n        name=name or displayName.lower().replace(' ', '_'),\n        parameterType='Required' if required else 'Optional',\n        datatype='DEFile',\n        direction='Input',\n        category=category,\n    )\n    if self.filter and options:\n        self.filter.list = options\n    if default is not None:\n        self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Folder","title":"<code>Folder</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Simple Feature Layer parameter with filter and default passthroughs</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>__name__</code> <code>value</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class Folder(Parameter):\n    \"\"\"Simple Feature Layer parameter with filter and default passthroughs\"\"\"\n    __name__ = 'Parameter'\n    def __init__(self, displayName: str, \n                 options: list[str]|None=None,\n                 default: str|None=None,\n                 required: bool=True,\n                 name: str|None=None,\n                 category: str|None=None) -&gt; None:\n\n        self.__class__.__name__ =  __name__ = 'Parameter'\n        super().__init__(\n            displayName=displayName,\n            # Snake Case the name\n            name=name or displayName.lower().replace(' ', '_'),\n            parameterType='Required' if required else 'Optional',\n            datatype='DEFolder',\n            direction='Input',\n            category=category,\n        )\n        if self.filter and options:\n            self.filter.list = options\n        if default is not None:\n            self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Folder.__name__","title":"<code>__name__ = 'Parameter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.Folder.value","title":"<code>value = default</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.Folder.__init__","title":"<code>__init__(displayName, options=None, default=None, required=True, name=None, category=None)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self, displayName: str, \n             options: list[str]|None=None,\n             default: str|None=None,\n             required: bool=True,\n             name: str|None=None,\n             category: str|None=None) -&gt; None:\n\n    self.__class__.__name__ =  __name__ = 'Parameter'\n    super().__init__(\n        displayName=displayName,\n        # Snake Case the name\n        name=name or displayName.lower().replace(' ', '_'),\n        parameterType='Required' if required else 'Optional',\n        datatype='DEFolder',\n        direction='Input',\n        category=category,\n    )\n    if self.filter and options:\n        self.filter.list = options\n    if default is not None:\n        self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Integer","title":"<code>Integer</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Simple Integer number parameter with default and filter passthroughs</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>__name__</code> <code>value</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class Integer(Parameter):\n    \"\"\"Simple Integer number parameter with default and filter passthroughs\"\"\"\n    __name__ = 'Parameter'\n    def __init__(self, displayName: str, \n                 options: list[int]|range|None=None, \n                 default: int|None=None,\n                 required: bool=True,\n                 name: str|None=None,\n                 category: str|None=None) -&gt; None:\n\n        self.__class__.__name__ =  __name__ = 'Parameter'\n        super().__init__(\n            displayName=displayName,\n            # Snake Case the name\n            name=name or displayName.lower().replace(' ', '_'),\n            parameterType='Required' if required else 'Optional',\n            datatype='GPLong',\n            direction='Input',\n            category=category,\n        )\n        if self.filter and options:\n            if isinstance(options, range):\n                if options.step:\n                    self.filter.list = list(options)\n                else:\n                    self.filter.type = 'Range'\n                    self.filter.list = [options.start, options.stop]\n            else:\n                self.filter.list = options\n        if default is not None:\n            self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Integer.__name__","title":"<code>__name__ = 'Parameter'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.Integer.value","title":"<code>value = default</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.Integer.__init__","title":"<code>__init__(displayName, options=None, default=None, required=True, name=None, category=None)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self, displayName: str, \n             options: list[int]|range|None=None, \n             default: int|None=None,\n             required: bool=True,\n             name: str|None=None,\n             category: str|None=None) -&gt; None:\n\n    self.__class__.__name__ =  __name__ = 'Parameter'\n    super().__init__(\n        displayName=displayName,\n        # Snake Case the name\n        name=name or displayName.lower().replace(' ', '_'),\n        parameterType='Required' if required else 'Optional',\n        datatype='GPLong',\n        direction='Input',\n        category=category,\n    )\n    if self.filter and options:\n        if isinstance(options, range):\n            if options.step:\n                self.filter.list = list(options)\n            else:\n                self.filter.type = 'Range'\n                self.filter.list = [options.start, options.stop]\n        else:\n            self.filter.list = options\n    if default is not None:\n        self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Parameter","title":"<code>Parameter</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Methods:</p> Name Description <code>__init__</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class Parameter(_Parameter):\n    def __init__(self,\n                 name: str | None = None, \n                 displayName: str | None = None, \n                 direction: None | Literal['Input', 'Output'] = None, \n                 datatype: str | None | ParameterDatatype = None, \n                 parameterType: None | Literal['Required', 'Optional', 'Derived'] = None, \n                 enabled: bool | None = None, \n                 category: str | None = None, \n                 symbology: str | None = None, \n                 multiValue: bool | None = None) -&gt; None:\n        super().__init__(name, displayName, direction, datatype, parameterType, enabled, category, symbology, multiValue)\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Parameter.__init__","title":"<code>__init__(name=None, displayName=None, direction=None, datatype=None, parameterType=None, enabled=None, category=None, symbology=None, multiValue=None)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self,\n             name: str | None = None, \n             displayName: str | None = None, \n             direction: None | Literal['Input', 'Output'] = None, \n             datatype: str | None | ParameterDatatype = None, \n             parameterType: None | Literal['Required', 'Optional', 'Derived'] = None, \n             enabled: bool | None = None, \n             category: str | None = None, \n             symbology: str | None = None, \n             multiValue: bool | None = None) -&gt; None:\n    super().__init__(name, displayName, direction, datatype, parameterType, enabled, category, symbology, multiValue)\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Parameters","title":"<code>Parameters</code>","text":"<p>               Bases: <code>list[Parameter]</code></p> <p>Wrap a list of parameters and override the index to allow indexing by name</p> <p>Methods:</p> Name Description <code>__contains__</code> <code>__getitem__</code> <code>get</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class Parameters(list[Parameter]):\n    \"\"\"Wrap a list of parameters and override the index to allow indexing by name\"\"\"\n    @overload\n    def __getitem__(self, key: SupportsIndex, /) -&gt; Parameter: ...\n    @overload\n    def __getitem__(self, key: slice, /) -&gt; list[Parameter]: ...\n    @overload\n    def __getitem__(self, key: str, /) -&gt; Parameter: ...\n    def __getitem__(self, key: SupportsIndex|slice|str, /) -&gt; Parameter | list[Parameter]:\n        if isinstance(key, str):\n            _matches = [p for p in self if p.name == key]\n            if not _matches:\n                raise KeyError(key)\n            if len(_matches) == 1:\n                return _matches.pop()\n            raise KeyError(f'{key} is used for multiple parameters')\n        return self[key]\n\n    @overload\n    def get(self, key: SupportsIndex, default: _Default=None, /) -&gt; Parameter | _Default: ...\n    @overload\n    def get(self, key: slice, default: _Default=None, /) -&gt; list[Parameter] | _Default: ...\n    @overload\n    def get(self, key: str, default: _Default=None, /) -&gt; Parameter | _Default: ...\n    def get(self, key: SupportsIndex|slice|str, default: _Default=None, /) -&gt; Parameter | list[Parameter] | _Default:\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def __contains__(self, key: object) -&gt; bool:\n        match key:\n            case str():\n                return any(p.name == key for p in self)\n            case Parameter():\n                return any(p == key for p in self)\n            case _:\n                return False\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Parameters.__contains__","title":"<code>__contains__(key)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __contains__(self, key: object) -&gt; bool:\n    match key:\n        case str():\n            return any(p.name == key for p in self)\n        case Parameter():\n            return any(p == key for p in self)\n        case _:\n            return False\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Parameters.__getitem__","title":"<code>__getitem__(key)</code>","text":"<pre><code>__getitem__(key: SupportsIndex) -&gt; Parameter\n</code></pre><pre><code>__getitem__(key: slice) -&gt; list[Parameter]\n</code></pre><pre><code>__getitem__(key: str) -&gt; Parameter\n</code></pre> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __getitem__(self, key: SupportsIndex|slice|str, /) -&gt; Parameter | list[Parameter]:\n    if isinstance(key, str):\n        _matches = [p for p in self if p.name == key]\n        if not _matches:\n            raise KeyError(key)\n        if len(_matches) == 1:\n            return _matches.pop()\n        raise KeyError(f'{key} is used for multiple parameters')\n    return self[key]\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Parameters.get","title":"<code>get(key, default=None)</code>","text":"<pre><code>get(\n    key: SupportsIndex, default: _Default = None\n) -&gt; Parameter | _Default\n</code></pre><pre><code>get(\n    key: slice, default: _Default = None\n) -&gt; list[Parameter] | _Default\n</code></pre><pre><code>get(\n    key: str, default: _Default = None\n) -&gt; Parameter | _Default\n</code></pre> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def get(self, key: SupportsIndex|slice|str, default: _Default=None, /) -&gt; Parameter | list[Parameter] | _Default:\n    try:\n        return self[key]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.String","title":"<code>String</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Simple string input parameter with filter options and default passthrough</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>value</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class String(Parameter):\n    \"\"\"Simple string input parameter with filter options and default passthrough\"\"\"\n\n    def __init__(self, displayName: str, \n                 options: list[str]|None=None, \n                 default: str|None=None,\n                 required: bool=True,\n                 name: str|None=None,\n                 category: str|None=None) -&gt; None:\n\n        self.__class__.__name__ =  __name__ = 'Parameter'\n        super().__init__(\n            displayName=displayName,\n            # Snake Case the name\n            name=name or displayName.lower().replace(' ', '_'),\n            parameterType='Required' if required else 'Optional',\n            datatype='GPString',\n            direction='Input',\n            category=category,\n        )\n        if self.filter and options:\n            self.filter.list = options\n        if default is not None:\n            self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.String.value","title":"<code>value = default</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.String.__init__","title":"<code>__init__(displayName, options=None, default=None, required=True, name=None, category=None)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self, displayName: str, \n             options: list[str]|None=None, \n             default: str|None=None,\n             required: bool=True,\n             name: str|None=None,\n             category: str|None=None) -&gt; None:\n\n    self.__class__.__name__ =  __name__ = 'Parameter'\n    super().__init__(\n        displayName=displayName,\n        # Snake Case the name\n        name=name or displayName.lower().replace(' ', '_'),\n        parameterType='Required' if required else 'Optional',\n        datatype='GPString',\n        direction='Input',\n        category=category,\n    )\n    if self.filter and options:\n        self.filter.list = options\n    if default is not None:\n        self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.StringList","title":"<code>StringList</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Simple string list with default and filter passthroughs</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>values</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class StringList(Parameter):\n    \"\"\"Simple string list with default and filter passthroughs\"\"\"\n\n    def __init__(self, displayName: str, \n                 options: list[str]|None=None, \n                 defaults: list[str]|None=None,\n                 required: bool=True,\n                 name: str|None=None,\n                 category: str|None=None) -&gt; None:\n\n        self.__class__.__name__ =  __name__ = 'Parameter'\n        super().__init__(\n            displayName=displayName,\n            # Snake Case the name\n            name=name or displayName.lower().replace(' ', '_'),\n            parameterType='Required' if required else 'Optional',\n            datatype='GPString',\n            direction='Input',\n            category=category,\n            multiValue=True,\n        )\n        if self.filter and options:\n            self.filter.list = options\n        if defaults:\n            self.values = defaults\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.StringList.values","title":"<code>values = defaults</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.StringList.__init__","title":"<code>__init__(displayName, options=None, defaults=None, required=True, name=None, category=None)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self, displayName: str, \n             options: list[str]|None=None, \n             defaults: list[str]|None=None,\n             required: bool=True,\n             name: str|None=None,\n             category: str|None=None) -&gt; None:\n\n    self.__class__.__name__ =  __name__ = 'Parameter'\n    super().__init__(\n        displayName=displayName,\n        # Snake Case the name\n        name=name or displayName.lower().replace(' ', '_'),\n        parameterType='Required' if required else 'Optional',\n        datatype='GPString',\n        direction='Input',\n        category=category,\n        multiValue=True,\n    )\n    if self.filter and options:\n        self.filter.list = options\n    if defaults:\n        self.values = defaults\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Toggle","title":"<code>Toggle</code>","text":"<p>               Bases: <code>Parameter</code></p> <p>Simple toggle button with a name and default state</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>value</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class Toggle(Parameter):\n    \"\"\"Simple toggle button with a name and default state\"\"\"\n\n    def __init__(self, displayName: str, \n                 default: bool=False, \n                 name: str|None=None,\n                 category: str|None=None) -&gt; None:\n\n        self.__class__.__name__ =  __name__ = 'Parameter'\n        super().__init__(\n            displayName=displayName,\n            # Snake Case the name\n            name=name or displayName.lower().replace(' ', '_'),\n            parameterType='Required',\n            datatype='GPBoolean',\n            direction='Input',\n            category=category,\n        )\n        self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Toggle.value","title":"<code>value = default</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.Toggle.__init__","title":"<code>__init__(displayName, default=False, name=None, category=None)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self, displayName: str, \n             default: bool=False, \n             name: str|None=None,\n             category: str|None=None) -&gt; None:\n\n    self.__class__.__name__ =  __name__ = 'Parameter'\n    super().__init__(\n        displayName=displayName,\n        # Snake Case the name\n        name=name or displayName.lower().replace(' ', '_'),\n        parameterType='Required',\n        datatype='GPBoolean',\n        direction='Input',\n        category=category,\n    )\n    self.value = default\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Tool","title":"<code>Tool</code>","text":"<p>               Bases: <code>ToolABC</code></p> <p>Attributes:</p> Name Type Description <code>active_map</code> <code>Map | None</code> <code>project</code> <code>Project | None</code> <p>Get the current project that the tool is running in if it exists (otherwise: None)</p> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class Tool(ToolABC):\n    _current_project: Project | None = None\n\n    @property\n    def project(self) -&gt; Project | None:\n        \"\"\"Get the current project that the tool is running in if it exists (otherwise: None)\"\"\"\n        if __class__._current_project is None:\n            try:\n                __class__._current_project = Project('CURRENT')\n            except Exception:\n                pass\n        return __class__._current_project\n\n    @property\n    def active_map(self) -&gt; Map | None:\n        if self.project and self.project.aprx.activeMap:\n            return Map(self.project.aprx.activeMap, parent=self.project)\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.Tool.active_map","title":"<code>active_map</code>  <code>property</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.Tool.project","title":"<code>project</code>  <code>property</code>","text":"<p>Get the current project that the tool is running in if it exists (otherwise: None)</p>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC","title":"<code>ToolABC</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>__init__</code> <code>execute</code> <code>getParameterInfo</code> <code>isLicensed</code> <code>postExecute</code> <code>updateMessages</code> <code>updateParameters</code> <p>Attributes:</p> Name Type Description <code>category</code> <code>str | None</code> <code>description</code> <code>str</code> <code>label</code> <code>str</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class ToolABC(ABC):\n    def __init__(self) -&gt; None:\n        self.label: str = self.__class__.__name__\n        self.description: str = self.__doc__ or 'No Descrption Provided'\n        self.category: str | None = None\n\n    def getParameterInfo(self) -&gt; Parameters | list[Parameter]: return Parameters()\n    def isLicensed(self) -&gt; bool: return True\n    def updateParameters(self, parameters: Parameters | list[Parameter]) -&gt; None: ...\n    def updateMessages(self, parameters: Parameters | list[Parameter]) -&gt; None: ...\n    def execute(self, parameters: Parameters | list[Parameter], messages: Any) -&gt; None: ...\n    def postExecute(self, parameters: Parameters | list[Parameter]) -&gt; None: ...\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.category","title":"<code>category = None</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.description","title":"<code>description = self.__doc__ or 'No Descrption Provided'</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.label","title":"<code>label = self.__class__.__name__</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.__init__","title":"<code>__init__()</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.label: str = self.__class__.__name__\n    self.description: str = self.__doc__ or 'No Descrption Provided'\n    self.category: str | None = None\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.execute","title":"<code>execute(parameters, messages)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def execute(self, parameters: Parameters | list[Parameter], messages: Any) -&gt; None: ...\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.getParameterInfo","title":"<code>getParameterInfo()</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def getParameterInfo(self) -&gt; Parameters | list[Parameter]: return Parameters()\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.isLicensed","title":"<code>isLicensed()</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def isLicensed(self) -&gt; bool: return True\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.postExecute","title":"<code>postExecute(parameters)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def postExecute(self, parameters: Parameters | list[Parameter]) -&gt; None: ...\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.updateMessages","title":"<code>updateMessages(parameters)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def updateMessages(self, parameters: Parameters | list[Parameter]) -&gt; None: ...\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolABC.updateParameters","title":"<code>updateParameters(parameters)</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def updateParameters(self, parameters: Parameters | list[Parameter]) -&gt; None: ...\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolboxABC","title":"<code>ToolboxABC</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>__init__</code> <p>Attributes:</p> Name Type Description <code>alias</code> <code>str</code> <code>label</code> <code>str</code> <code>tools</code> <code>list[type[ToolABC]]</code> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>class ToolboxABC(ABC):\n    def __init__(self) -&gt; None:\n        self.label: str\n        self.alias: str\n        self.tools: list[type[ToolABC]]\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.ToolboxABC.alias","title":"<code>alias</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.ToolboxABC.label","title":"<code>label</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.ToolboxABC.tools","title":"<code>tools</code>  <code>instance-attribute</code>","text":""},{"location":"modules/toolbox/#arcpie.toolbox.ToolboxABC.__init__","title":"<code>__init__()</code>","text":"Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.label: str\n    self.alias: str\n    self.tools: list[type[ToolABC]]\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.safe_load","title":"<code>safe_load(tools, *, scope=None, reload_module=False)</code>","text":"<p>Safely load in tools to a toolbox placing all failed imports in a <code>Broken Tools</code> category</p> <p>Parameters:</p> Name Type Description Default <code>tools</code> <code>dict[str, list[str]]</code> <p>A mapping of tool modules to tool files or tool classes in a module</p> required <code>scope</code> <code>dict[str, Any]</code> <p>The <code>globals()</code> dict for the Toolbox scope (required so loading happend in Toolbox scope)</p> <code>None</code> <code>reload_module</code> <code>bool</code> <p>Reload the module after importing (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code> list[type[ToolABC]] </code> <p>A list of tool classes</p> Note <p>To isolate bugs in a large toolbox, it is reccomended that you use file/module level importing with matching toolclass names (e.g. <code>Tool.py -&gt; class Tool</code>) where the Tool mapping is:     <code>Tools = {'tools': ['Tool.py']}</code> instead of:     <code>Tools = {'tools.Tool': ['Tool']}</code> This allows the import to fail softly on a single tool instead of breaking imports for all other toolclasses in that <code>Tool.py</code> module.</p> <p>Any tools with errors will be placed in a <code>Broken Tools</code> category in the toolbox with the full stack trace placed in its description field. The final component of the exception will be placed at the end of the tool label for easy debugging.</p> Example <pre><code>&gt;&gt;&gt; # File import\n&gt;&gt;&gt; Tools = {\n...     # import matching class from named file in a submodule (tools)\n...     # where ToolFileA is ToolFileA.py with a class ToolFileA\n...     'tools': ['ToolFileA', 'ToolFileB'],\n...     \n...     # Import explicit ToolClass from toolfile (MyTools.py)\n...     # NOT RECOMMENDED\n...     'tools.MyTools': ['ToolClassA', 'ToolClassB'],\n... }\n&gt;&gt;&gt; tools = safe_import(globals(), Tools)\n</code></pre> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def safe_load(tools: dict[str, list[str]],\n              *,\n              scope: dict[str, Any]|None=None,\n              reload_module: bool=False) -&gt; list[type[ToolABC]]:\n    \"\"\"Safely load in tools to a toolbox placing all failed imports in a `Broken Tools` category\n\n    Args:\n        tools (dict[str, list[str]]): A mapping of tool modules to tool files or tool classes in a module\n        scope (dict[str, Any]): The `globals()` dict for the Toolbox scope (required so loading happend in Toolbox scope)\n        reload_module (bool): Reload the module after importing (default: False)\n\n    Returns:\n        ( list[type[ToolABC]] ): A list of tool classes\n\n    Note:\n        To isolate bugs in a large toolbox, it is reccomended that you use file/module level importing\n        with matching toolclass names (e.g. `Tool.py -&gt; class Tool`) where the Tool mapping is:\n            `Tools = {'tools': ['Tool.py']}`\n        instead of:\n            `Tools = {'tools.Tool': ['Tool']}`\n        This allows the import to fail softly on a single tool instead of breaking imports for all other\n        toolclasses in that `Tool.py` module.\n\n        Any tools with errors will be placed in a `Broken Tools` category in the toolbox with the full\n        stack trace placed in its description field. The final component of the exception will be placed\n        at the end of the tool label for easy debugging.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # File import\n        &gt;&gt;&gt; Tools = {\n        ...     # import matching class from named file in a submodule (tools)\n        ...     # where ToolFileA is ToolFileA.py with a class ToolFileA\n        ...     'tools': ['ToolFileA', 'ToolFileB'],\n        ...     \n        ...     # Import explicit ToolClass from toolfile (MyTools.py)\n        ...     # NOT RECOMMENDED\n        ...     'tools.MyTools': ['ToolClassA', 'ToolClassB'],\n        ... }\n        &gt;&gt;&gt; tools = safe_import(globals(), Tools)\n        ```\n    \"\"\"\n    _tools = [\n        _get_tool(module, tool_name, reload_module)\n        for module in tools\n        for tool_name in tools[module]\n    ]\n    if scope:\n        scope.update({tool.__name__: tool for tool in _tools})\n    return _tools\n</code></pre>"},{"location":"modules/toolbox/#arcpie.toolbox.toolify","title":"<code>toolify(*tool_registries, name=None, params=None, debug=False, logger=None)</code>","text":"<p>Convert a typed function into a tool for the specified Toolbox class</p> <p>Parameters:</p> Name Type Description Default <code>*tool_registries</code> <code>list[type[ToolABC]]</code> <p>The tool registry lists to add this tool to</p> <code>()</code> <code>name</code> <code>str</code> <p>The name of the tool</p> <code>None</code> <code>params</code> <code>ParameterTypeMap</code> <p>A mapping of parameter names to Parameter types and a callable constructor  that converts the parameter to the expected value for the function parameter. You can also pass a fully formed arcpy.Parameter object as the first item in the tuple instead of a simple type</p> <code>None</code> <code>debug</code> <code>bool</code> <p>Print the converted arguments to the ArcGIS Pro message console (default: False)</p> <code>False</code> <code>logger</code> <code>Logger | None</code> <p>An optional logger to use for logging all runs of the toolified tool</p> <code>None</code> Usage <pre><code>&gt;&gt;&gt; @toolify(\n&gt;&gt;&gt;     TOOL_REGISTRY, \n&gt;&gt;&gt;     name='PDF Exporter', \n&gt;&gt;&gt;     params={\n&gt;&gt;&gt;         'project': ('DEFile', lambda p: Project(p.valueAsText)),\n&gt;&gt;&gt;         'outfile': ('DEFile', lambda p: Path(p.valueAsText))\n&gt;&gt;&gt;     }\n&gt;&gt;&gt; )\n&gt;&gt;&gt; def export_pdf(project: Project|str='CURRENT', outfile: Path|str='out.pdf') -&gt; None:\n&gt;&gt;&gt;     ...\n</code></pre> Source code in <code>src/arcpie/toolbox.py</code> <pre><code>def toolify(*tool_registries: list[type[ToolABC]], \n            name: str|None=None, \n            params: ParameterTypeMap|None=None, \n            debug: bool=False, \n            logger: Logger|None=None,\n):\n    \"\"\"Convert a typed function into a tool for the specified Toolbox class\n\n    Args:\n        *tool_registries (list[type[ToolABC]]): The tool registry lists to add this tool to\n        name (str): The name of the tool\n        params (ParameterTypeMap): A mapping of parameter names to Parameter types and a callable constructor \n            that converts the parameter to the expected value for the function parameter. You can also pass\n            a fully formed arcpy.Parameter object as the first item in the tuple instead of a simple type\n        debug (bool): Print the converted arguments to the ArcGIS Pro message console (default: False)\n        logger (Logger|None): An optional logger to use for logging all runs of the toolified tool\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; @toolify(\n        &gt;&gt;&gt;     TOOL_REGISTRY, \n        &gt;&gt;&gt;     name='PDF Exporter', \n        &gt;&gt;&gt;     params={\n        &gt;&gt;&gt;         'project': ('DEFile', lambda p: Project(p.valueAsText)),\n        &gt;&gt;&gt;         'outfile': ('DEFile', lambda p: Path(p.valueAsText))\n        &gt;&gt;&gt;     }\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; def export_pdf(project: Project|str='CURRENT', outfile: Path|str='out.pdf') -&gt; None:\n        &gt;&gt;&gt;     ...\n        ```\n    \"\"\"\n    def _builder(func: Callable[..., Any]):\n\n        @wraps(func)\n        def _execute(*args: Any, **kwargs: Any):\n            return func(*args, **kwargs)\n\n        # Build the tool class\n        _label = func.__name__.replace('_', ' ').title()\n        _description = func.__doc__ or 'No Description Provided'\n        _class_name = _label.replace(' ', '')\n        sig = inspect.signature(func)\n        sig_params = sig.parameters\n\n        # Handle parameter converison\n        def _passthrough_execution(self: ToolABC, parameters: Parameters | list[Parameter], messages: Any) -&gt; None:\n            if debug:\n                print(f'Executing toolified {func.__name__} via {self.label}')\n            args, kwargs = _read_params(parameters, sig_params, params or {})\n            start = time.time()\n            try:\n                if debug:\n                    print(f\"Using *{args}, **{kwargs}\")\n                res = _execute(*args, **kwargs)\n                end = time.time()\n                if logger:\n                    logger.info(f'[{datetime.isoformat(datetime.now())}] PASS \"{self.label}\" ({end-start:0.2f} seconds) [{res}]')\n            except Exception as e:\n                print(f'Something went wrong!:\\n\\t{traceback.format_exc()}', severity='ERROR')\n                end = time.time()\n                if logger:\n                    logger.info(f'[{datetime.isoformat(datetime.now())}] FAIL \"{self.label}\" ({end-start:0.2f} seconds) [{e}] ')\n\n        def _local_build_params(self: ToolABC) -&gt; Parameters | list[Parameter]:\n            return _build_params(sig_params, params or {})\n\n        def _local_init(self: ToolABC) -&gt; None:\n            self.label = name or _label\n            self.description = _description\n\n        _tool_class = type(\n            _class_name, \n            (ToolABC, ),\n            {\n                '__init__': _local_init, \n                'getParameterInfo':_local_build_params, \n                'execute': _passthrough_execution\n            }\n        )\n\n        for registry in tool_registries:\n            if _tool_class.__name__ not in map(lambda c: c.__name__, registry):\n                registry.append(_tool_class)\n                globals()[_class_name] = _tool_class\n        return _execute\n    return _builder\n</code></pre>"},{"location":"modules/utils/","title":"utils","text":"<p>Module for internal utility functions to share between modules</p> <p>Classes:</p> Name Description <code>Vector</code> <p>Simple Vector implementation that takes a start and end point.</p> <p>Functions:</p> Name Description <code>box_on_point</code> <p>Build a rectangular box on a point</p> <code>build_mapx</code> <code>center_circle</code> <p>Create a circle using a center point and a radius</p> <code>convert_schema</code> <p>Convert a Schema from one format to another</p> <code>export_project_lyrx</code> <p>Pull all layers from a project file and output them in a directory as lyrx files</p> <code>export_project_maps</code> <p>Pull all layers from a project file and output them in a directory as mapx files</p> <code>get_subtype_count</code> <p>Get the subtype counts for a Table or FeatureClass</p> <code>get_subtype_counts</code> <p>Get a mapping of subtype counts for all featureclasses that have subtypes in the provided Dataset</p> <code>nat</code> <p>Natural sort key for use in string sorting</p> <code>patch_schema_rules</code> <p>Patch an exported Schema doc by re-linking attribute rules to table names</p> <code>print</code> <p>Print a message to the ArcGIS Pro message queue and stdout</p> <code>shortest_path</code> <p>Find the shortest path or paths given a source point, target point and network of Polylines</p> <code>split_at_points</code> <p>Split lines at provided points</p> <code>split_lines_at_points</code> <p>Split a Polyline or Sequence/Iterable of polylines at provided points</p> <code>two_point_circle</code> <p>Create a circle using a center point and an end point</p> <p>Attributes:</p> Name Type Description <code>LineCollection</code> <code>PointLike</code>"},{"location":"modules/utils/#arcpie.utils.LineCollection","title":"<code>LineCollection = FeatureClass[Polyline, Any] | Sequence[Polyline] | Iterator[Polyline]</code>  <code>module-attribute</code>","text":""},{"location":"modules/utils/#arcpie.utils.PointLike","title":"<code>PointLike = PointGeometry | Point</code>  <code>module-attribute</code>","text":""},{"location":"modules/utils/#arcpie.utils.Vector","title":"<code>Vector</code>  <code>dataclass</code>","text":"<p>Simple Vector implementation that takes a start and end point.</p> <p>If <code>PointGeometries</code> are passed as the start and end points, the end point will inherit the reference of the start point</p> <p>Attributes:</p> Name Type Description <code>x1</code> <code>float</code> <p>The X coordinate of the startpoint</p> <code>y1</code> <code>float</code> <p>The Y coordinate of the startpoint</p> <code>x2</code> <code>float</code> <p>The X coordiante of the endpoint</p> <code>y2</code> <code>float</code> <p>The Y coordiante of the endpoint</p> <code>ang</code> <code>float</code> <p>The angle of the vector in radians</p> <code>dist</code> <code>float</code> <p>The magnitute of the vector (distance b/w start and end)</p> <code>cos</code> <code>float</code> <p>the cos of the vector angle in radians</p> <code>sin</code> <code>float</code> <p>The sin of the vector angle in radians</p> <code>mid</code> <code>Point</code> <p>The midpoint of the vector along its magnitude</p> <p>Methods:</p> Name Description <code>__init__</code> <code>__post_init__</code> <code>translate</code> <p>Translate the provided point along the vector direction.</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>@dataclass\nclass Vector:\n    \"\"\"Simple Vector implementation that takes a start and end point.\\n\n\n    If `PointGeometries` are passed as the start and end points, the end point\n    will inherit the reference of the start point\n\n    Attributes:\n        x1 (float): The X coordinate of the startpoint\n        y1 (float): The Y coordinate of the startpoint\n        x2 (float): The X coordiante of the endpoint\n        y2 (float): The Y coordiante of the endpoint\n        ang (float): The angle of the vector in radians\n        dist (float): The magnitute of the vector (distance b/w start and end)\n        cos (float): the cos of the vector angle in radians\n        sin (float): The sin of the vector angle in radians\n        mid (Point): The midpoint of the vector along its magnitude\n    \"\"\"\n    start: Point | PointGeometry\n    end: Point | PointGeometry\n\n    def __post_init__(self) -&gt; None:\n        _ref = None\n        if isinstance(self.start, PointGeometry):\n            _ref = self.start.spatialReference\n            self.start = self.start.centroid\n        if isinstance(self.end, PointGeometry):\n            if _ref and self.end.spatialReference != _ref:\n                self.end = self.end.projectAs(_ref)\n            self.end = self.end.centroid\n        self.x1: float = self.start.X\n        self.x2: float = self.end.X\n        self.y1: float = self.start.Y\n        self.y2: float = self.end.Y\n        self.ang: float = math.atan2(self.y2-self.y1, self.x2-self.x1)\n        self.dist: float = ((self.x2-self.x1)**2+(self.y2-self.y1)**2)**0.5\n        self.cos = math.cos(self.ang)\n        self.sin = math.sin(self.ang)\n        self.mid: Point = self.translate(self.start, self.dist/2)\n\n    def translate(self, point: _PointType, dist: float|None=None) -&gt; _PointType:\n        \"\"\"Translate the provided point along the vector direction.\n\n        The Point will be moved from its original location along the vector angle the provided distance.\n        The location of the `Vector` object is not taken into account, only angle and magnitude\n\n        Args:\n            point (Point|PointGeometry): The point to translate along the given vector\n            dist (float|None): The distance to translate the point (default: `self.dist`)\n\n        Returns:\n            (Point|PointGeometry): Return the provided geometry back translated\n\n        Note:\n            Whatever point type you provide will be given back to you\n        \"\"\"\n        ref: SpatialReference | None = getattr(point, 'spatialReference')\n        if isinstance(point, Point):\n            target = point\n        else:\n            target = point.centroid\n        dist = dist or self.dist\n        target = Point(target.X+dist*self.cos, target.Y+dist*self.sin, target.Z, target.M, target.ID)\n        if isinstance(point, PointGeometry):\n            return PointGeometry(target, ref) # pyright: ignore[reportReturnType]\n        return target   # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.Vector.end","title":"<code>end</code>  <code>instance-attribute</code>","text":""},{"location":"modules/utils/#arcpie.utils.Vector.start","title":"<code>start</code>  <code>instance-attribute</code>","text":""},{"location":"modules/utils/#arcpie.utils.Vector.__init__","title":"<code>__init__(start, end)</code>","text":""},{"location":"modules/utils/#arcpie.utils.Vector.__post_init__","title":"<code>__post_init__()</code>","text":"Source code in <code>src/arcpie/utils.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    _ref = None\n    if isinstance(self.start, PointGeometry):\n        _ref = self.start.spatialReference\n        self.start = self.start.centroid\n    if isinstance(self.end, PointGeometry):\n        if _ref and self.end.spatialReference != _ref:\n            self.end = self.end.projectAs(_ref)\n        self.end = self.end.centroid\n    self.x1: float = self.start.X\n    self.x2: float = self.end.X\n    self.y1: float = self.start.Y\n    self.y2: float = self.end.Y\n    self.ang: float = math.atan2(self.y2-self.y1, self.x2-self.x1)\n    self.dist: float = ((self.x2-self.x1)**2+(self.y2-self.y1)**2)**0.5\n    self.cos = math.cos(self.ang)\n    self.sin = math.sin(self.ang)\n    self.mid: Point = self.translate(self.start, self.dist/2)\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.Vector.translate","title":"<code>translate(point, dist=None)</code>","text":"<p>Translate the provided point along the vector direction.</p> <p>The Point will be moved from its original location along the vector angle the provided distance. The location of the <code>Vector</code> object is not taken into account, only angle and magnitude</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Point | PointGeometry</code> <p>The point to translate along the given vector</p> required <code>dist</code> <code>float | None</code> <p>The distance to translate the point (default: <code>self.dist</code>)</p> <code>None</code> <p>Returns:</p> Type Description <code>Point | PointGeometry</code> <p>Return the provided geometry back translated</p> Note <p>Whatever point type you provide will be given back to you</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def translate(self, point: _PointType, dist: float|None=None) -&gt; _PointType:\n    \"\"\"Translate the provided point along the vector direction.\n\n    The Point will be moved from its original location along the vector angle the provided distance.\n    The location of the `Vector` object is not taken into account, only angle and magnitude\n\n    Args:\n        point (Point|PointGeometry): The point to translate along the given vector\n        dist (float|None): The distance to translate the point (default: `self.dist`)\n\n    Returns:\n        (Point|PointGeometry): Return the provided geometry back translated\n\n    Note:\n        Whatever point type you provide will be given back to you\n    \"\"\"\n    ref: SpatialReference | None = getattr(point, 'spatialReference')\n    if isinstance(point, Point):\n        target = point\n    else:\n        target = point.centroid\n    dist = dist or self.dist\n    target = Point(target.X+dist*self.cos, target.Y+dist*self.sin, target.Z, target.M, target.ID)\n    if isinstance(point, PointGeometry):\n        return PointGeometry(target, ref) # pyright: ignore[reportReturnType]\n    return target   # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.box_on_point","title":"<code>box_on_point(center, width, height, angle=0.0, ref=None, start='tl')</code>","text":"<p>Build a rectangular box on a point</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Point | PointGeometry</code> <p>The center point of the box</p> required <code>width</code> <code>float</code> <p>The width of the box</p> required <code>height</code> <code>float</code> <p>The height of the box</p> required <code>angle</code> <code>float</code> <p>An angle to roatate the box by in radians (default: 0.0)</p> <code>0.0</code> <code>ref</code> <code>SpatialReference | None</code> <p>An optional spatial reference to apply to the output polygon</p> <code>None</code> <code>start</code> <code>Literal['tl', 'tr', 'bl', 'br']</code> <p>The corner of the box that should be the start point (default: 'tl')</p> <code>'tl'</code> <p>Returns:</p> Type Description <code>Polygon</code> <p>A rectangular polygon (with provided ref or ref inhereted from center)</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def box_on_point(\n    center: Point | PointGeometry, \n    width: float, height: float, \n    angle: float=0.0, \n    ref: SpatialReference|None=None, \n    start: Literal['tl', 'tr', 'bl', 'br']='tl'\n    ) -&gt; Polygon:\n    \"\"\"Build a rectangular box on a point\n\n    Args:\n        center (Point|PointGeometry): The center point of the box\n        width (float): The width of the box\n        height (float): The height of the box\n        angle (float): An angle to roatate the box by in radians (default: 0.0)\n        ref (SpatialReference|None): An optional spatial reference to apply to the output polygon\n        start (Literal['tl', 'tr', 'bl', 'br']): The corner of the box that should be the start point (default: 'tl')\n\n    Returns:\n        (Polygon): A rectangular polygon (with provided ref or ref inhereted from center)\n    \"\"\"\n    if isinstance(center, PointGeometry):\n        ref = ref or center.spatialReference\n        if center.spatialReference != ref:\n            center = center.projectAs(ref)\n        center = center.centroid\n\n    h_width = width/2\n    h_height = height/2\n    tl = Point(center.X-h_width, center.Y+h_height)\n    tr = Point(center.X+h_width, center.Y+h_height)\n    bl = Point(center.X-h_width, center.Y-h_height)\n    br = Point(center.X+h_width, center.Y-h_height)\n    points = deque([tl, tr, br, bl])\n\n    if start == 'tr':\n        points.rotate(-1)\n    elif start == 'br':\n        points.rotate(-2)\n    elif start == 'bl':\n        points.rotate(-3)\n\n    box = Polygon(Array(), spatial_reference=ref)\n    if angle:\n        box = box.rotate(center, angle) # type: ignore\n        assert isinstance(box, Polygon)\n    return box\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.build_mapx","title":"<code>build_mapx(source_map, layers, tables)</code>","text":"Source code in <code>src/arcpie/utils.py</code> <pre><code>def build_mapx(source_map: Map, layers: list[Layer], tables: list[StandaloneTable]) -&gt; dict[str, Any]:\n    _base_map = source_map.mapx\n\n    # Remove existing definitions\n    _base_map.pop('layerDefinition', None)\n    _base_map.pop('tableDefinitions', None)\n\n    # Remove existing CIM paths\n    _map_def: dict[str, Any] = _base_map['mapDefinition']\n    _map_def.pop('layers', None)\n    _map_def.pop('standaloneTables', None)\n\n    if layers:\n        _map_def['layers'] = [l.URI for l in layers]\n        _base_map['layerDefinitions'] = [l.cim_dict for l in layers]\n\n    if tables:\n        _map_def['standaloneTables'] = [t.URI for t in tables]\n        _base_map['tableDefinitions'] = [t.cim_dict for t in tables]\n\n    return _base_map\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.center_circle","title":"<code>center_circle(center, radius, ref=None)</code>","text":"<p>Create a circle using a center point and a radius</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Point | PointGeometry</code> <p>The center of the circle</p> required <code>radius</code> <code>float</code> <p>(float): The dist</p> required <code>ref</code> <code>SpatialReference | None</code> <p>(SpatialReference|None): The SpatialReference to use with the returned geometry</p> <code>None</code> <p>Returns:</p> Type Description <code>Polyline</code> <p>A Circular Polyline</p> Note <p>If a PointGeometry are provided, it will be projected as the provided ref If no ref is provided, the shape will inherit the reference of the center</p> <p>Reference resolution is as follows: <code>ref -&gt; center.spatialReference</code></p> <p>If no center reference can be found and no ref is provided, the returned geometry will  have no reference</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def center_circle(center: Point|PointGeometry, radius: float, ref: SpatialReference|None=None) -&gt; Polyline:\n    \"\"\"Create a circle using a center point and a radius\n\n    Args:\n        center (Point|PointGeometry): The center of the circle\n        radius: (float): The dist\n        ref: (SpatialReference|None): The SpatialReference to use with the returned geometry\n\n    Returns:\n        (Polyline): A Circular Polyline\n\n    Note:\n        If a PointGeometry are provided, it will be projected as the provided ref\n        If no ref is provided, the shape will inherit the reference of the center\n\n        Reference resolution is as follows:\n        `ref -&gt; center.spatialReference`\n\n        If no center reference can be found and no ref is provided, the returned geometry will \n        have no reference\n    \"\"\"\n    if isinstance(center, PointGeometry):\n        ref = ref or center.spatialReference\n        center = center.centroid \n    return two_point_circle(center, Point(center.X, center.Y+radius), ref)\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.convert_schema","title":"<code>convert_schema(schema, to='JSON')</code>","text":"<p>Convert a Schema from one format to another</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Dataset | Path | str</code> <p>Path to the schemafile or Dataset to convert</p> required <code>to</code> <code>Literal['JSON', 'XLSX', 'HTML', 'PDF', 'XML']</code> <p>Target format (default: 'JSON')</p> <code>'JSON'</code> <p>Yields:</p> Name Type Description <code>bytes</code> <code>BytesIO</code> <p>Raw bytes object containing the schema file</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def convert_schema(schema: Dataset[Any]|Path|str, to: Literal['JSON', 'XLSX', 'HTML', 'PDF', 'XML']='JSON') -&gt; BytesIO:\n    \"\"\"Convert a Schema from one format to another\n\n    Args:\n        schema (Dataset|Path|str): Path to the schemafile or Dataset to convert\n        to (Literal['JSON', 'XLSX', 'HTML', 'PDF', 'XML']): Target format (default: 'JSON')\n\n    Yields:\n        bytes: Raw bytes object containing the schema file\n    \"\"\"\n    with TemporaryDirectory(suffix=to) as temp:\n        temp = Path(temp)\n        if not isinstance(schema, (Path, str)):\n            # Convert Dataset to report\n            schema, = GenerateSchemaReport(str(schema.conn), str(temp), 'json_schema', 'JSON')\n        schema = Path(schema)\n        conversion, = ConvertSchemaReport(str(schema), str(temp), 'out', to)\n        return BytesIO(Path(conversion).read_bytes())\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.export_project_lyrx","title":"<code>export_project_lyrx(project, out_dir, *, indent=4, sort=False, skip_empty=True)</code>","text":"<p>Pull all layers from a project file and output them in a directory as lyrx files</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>The <code>arcpie.Project</code> instance to export</p> required <code>out_dir</code> <code>Path | str</code> <p>The target directory for the layer files</p> required <code>indent</code> <code>int</code> <p>Indentation level of the ouput files (default: 4)</p> <code>4</code> <code>sort</code> <code>bool</code> <p>Sort the output file by key name (default: False)</p> <code>False</code> <code>skip_empty</code> <code>bool</code> <p>Skips writing empty lyrx files for layers with no lyrx data (default: True)</p> <code>True</code> Usage <pre><code>&gt;&gt;&gt; export_project_lyrx(arcpie.Project('&lt;path/to/aprx&gt;'), '&lt;path/to/output_dir&gt;')\n</code></pre> Note <p>Output structure will match the structure of the project: <code>Map -&gt; Group -&gt; Layer</code> Where each level is a directory. Group Layers will have a directory entry with individual files for each layer they contain, as well as a single layerfile that contains all their  child layers.</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def export_project_lyrx(project: Project, out_dir: Path, *, indent: int=4, sort: bool=False, skip_empty: bool=True) -&gt; None:\n    \"\"\"Pull all layers from a project file and output them in a directory as lyrx files\n\n    Args:\n        project (Project): The `arcpie.Project` instance to export\n        out_dir (Path|str): The target directory for the layer files\n        indent (int): Indentation level of the ouput files (default: 4)\n        sort (bool): Sort the output file by key name (default: False)\n        skip_empty (bool): Skips writing empty lyrx files for layers with no lyrx data (default: True)\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; export_project_lyrx(arcpie.Project('&lt;path/to/aprx&gt;'), '&lt;path/to/output_dir&gt;')\n        ```\n\n    Note:\n        Output structure will match the structure of the project:\n        `Map -&gt; Group -&gt; Layer`\n        Where each level is a directory. Group Layers will have a directory entry with individual\n        files for each layer they contain, as well as a single layerfile that contains all their \n        child layers.\n    \"\"\"\n    out_dir = Path(out_dir)\n    for map in project.maps:\n        map_dir = out_dir / map.unique_name\n        for layer in map.layers:\n            _lyrx = getattr(layer, 'lyrx', None)\n            if _lyrx is None:\n                print(f'{(layer.cim_dict or {}).get(\"type\")} is invalid!')\n                continue\n            if skip_empty and not _lyrx:\n                continue\n            out_file = (map_dir / layer.longName).with_suffix('.lyrx')\n            out_file.parent.mkdir(parents=True, exist_ok=True)\n            out_file.write_text(json.dumps(_lyrx, indent=indent, sort_keys=sort), encoding='utf-8')\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.export_project_maps","title":"<code>export_project_maps(project, out_dir, *, indent=4, sort=False)</code>","text":"<p>Pull all layers from a project file and output them in a directory as mapx files</p> <p>Parameters:</p> Name Type Description Default <code>project</code> <code>Project</code> <p>The <code>arcpie.Project</code> instance to export</p> required <code>out_dir</code> <code>Path | str</code> <p>The target directory for the mapx files</p> required <code>indent</code> <code>int</code> <p>Indentation level of the ouput files (default: 4)</p> <code>4</code> <code>sort</code> <code>bool</code> <p>Sort the output file by key name (default: False)</p> <code>False</code> Usage <pre><code>&gt;&gt;&gt; export_project_maps(arcpie.Project('&lt;path/to/aprx&gt;'), '&lt;path/to/output_dir&gt;')\n</code></pre> Source code in <code>src/arcpie/utils.py</code> <pre><code>def export_project_maps(project: Project, out_dir: Path|str, *, indent: int=4, sort: bool=False) -&gt; None:\n    \"\"\"Pull all layers from a project file and output them in a directory as mapx files\n\n    Args:\n        project (Project): The `arcpie.Project` instance to export\n        out_dir (Path|str): The target directory for the mapx files\n        indent (int): Indentation level of the ouput files (default: 4)\n        sort (bool): Sort the output file by key name (default: False)\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; export_project_maps(arcpie.Project('&lt;path/to/aprx&gt;'), '&lt;path/to/output_dir&gt;')\n        ```\n    \"\"\"\n    out_dir = Path(out_dir)\n    for map in project.maps:\n        map_dir = out_dir / rf'{map.unique_name}'\n        out_file = map_dir.with_suffix(f'{map_dir.suffix}.mapx') # handle '.' in map name\n        out_file.parent.mkdir(parents=True, exist_ok=True)\n        out_file.write_text(json.dumps(map.mapx, indent=indent, sort_keys=sort), encoding='utf-8')\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.get_subtype_count","title":"<code>get_subtype_count(fc, drop_empty=False)</code>","text":"<p>Get the subtype counts for a Table or FeatureClass</p> <p>Parameters:</p> Name Type Description Default <code>fc</code> <code>Table | FeatureClass</code> <p>The Table/FeatureClass you want subtype counts for</p> required <code>drop_empty</code> <code>bool</code> <p>Drop any counts that have no features from the output dictionary (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>A mapping of subtype name to subtype count</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def get_subtype_count(fc: Table | FeatureClass, drop_empty: bool=False) -&gt; dict[str, int]:\n    \"\"\"Get the subtype counts for a Table or FeatureClass\n\n    Args:\n        fc (Table | FeatureClass): The Table/FeatureClass you want subtype counts for\n        drop_empty (bool): Drop any counts that have no features from the output dictionary (default: False)\n\n    Returns:\n        (dict[str, int]): A mapping of subtype name to subtype count\n    \"\"\"\n    return {\n        subtype['Name']: cnt\n        for code, subtype in fc.subtypes.items() \n        if fc.subtype_field # has Subtypes\n        and (\n            (cnt := count(fc[where(f'{fc.subtype_field} = {code}')])) # Get count\n            or drop_empty # Drop Empty counts?\n        )\n    }\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.get_subtype_counts","title":"<code>get_subtype_counts(gdb, *, drop_empty=False)</code>","text":"<p>Get a mapping of subtype counts for all featureclasses that have subtypes in the provided Dataset</p> <p>Parameters:</p> Name Type Description Default <code>gdb</code> <code>Dataset</code> <p>The Dataset instance to get subtype counts for</p> required <code>drop_empty</code> <code>bool</code> <p>Drop any counts that have no features from the output dictionary (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, dict[str, int]]</code> <p>A mapping of FeatureClass -&gt; SubtypeName -&gt; SubtypeCount</p> Usage <pre><code>&gt;&gt;&gt; get_subtype_counts(Dataset('&lt;path/to/gdb&gt;', drop_empty=True))\n{\n    'FC1': \n        {\n            'Default': 10\n            'Subtype 1': 6\n            ...\n        },\n    ...\n}\n</code></pre> Source code in <code>src/arcpie/utils.py</code> <pre><code>def get_subtype_counts(gdb: Dataset, *, drop_empty: bool=False) -&gt; dict[str, dict[str, int]]:\n    \"\"\"Get a mapping of subtype counts for all featureclasses that have subtypes in the provided Dataset\n\n    Args:\n        gdb (Dataset): The Dataset instance to get subtype counts for\n        drop_empty (bool): Drop any counts that have no features from the output dictionary (default: False)\n\n    Returns:\n        (dict[str, dict[str, int]]): A mapping of FeatureClass -&gt; SubtypeName -&gt; SubtypeCount\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; get_subtype_counts(Dataset('&lt;path/to/gdb&gt;', drop_empty=True))\n        {\n            'FC1': \n                {\n                    'Default': 10\n                    'Subtype 1': 6\n                    ...\n                },\n            ...\n        }\n        ```  \n    \"\"\"\n    feats: list[Table] = [*gdb.feature_classes.values(), *gdb.tables.values()]\n    return {\n        fc.name: counts\n        for fc in feats\n        if (counts := get_subtype_count(fc))\n        or not drop_empty\n    }\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.nat","title":"<code>nat(val)</code>","text":"<p>Natural sort key for use in string sorting</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>str</code> <p>A value that you want the natural sort key for</p> required <p>Returns:</p> Type Description <code>tuple[tuple[int, ...], tuple[str, ...]</code> <p>A tuple containing all numeric and </p> <code>tuple[str, ...]</code> <p>string components in order of appearance. Best used as a sort key</p> Usage <pre><code>&gt;&gt;&gt; pages = ['P-1.3', 'P-2.11', ...]\n&gt;&gt;&gt; pages.sort(key=nat)\n&gt;&gt;&gt; print(pages)\n['P-1.1', 'P-1.2', ...]\n</code></pre> Source code in <code>src/arcpie/utils.py</code> <pre><code>def nat(val: str) -&gt; tuple[tuple[int, ...], tuple[str, ...]]:\n    \"\"\"Natural sort key for use in string sorting\n\n    Args:\n        val (str): A value that you want the natural sort key for\n\n    Returns:\n        (tuple[tuple[int, ...], tuple[str, ...]): A tuple containing all numeric and \n        string components in order of appearance. Best used as a sort key\n\n    Usage:\n        ```python\n        &gt;&gt;&gt; pages = ['P-1.3', 'P-2.11', ...]\n        &gt;&gt;&gt; pages.sort(key=nat)\n        &gt;&gt;&gt; print(pages)\n        ['P-1.1', 'P-1.2', ...]\n        ```\n    \"\"\"\n    _digits: list[int] = []\n    _alpha: list[str] = []\n    _digit_chars: list[str] = []\n    for s in val:\n       if s.isdigit():\n          _digit_chars.append(s)\n       else:\n          _alpha.append(s)\n          if _digit_chars:\n             _digits.append(int(''.join(_digit_chars)))\n             _digit_chars.clear()\n    if _digit_chars:\n       _digits.append(int(''.join(_digit_chars)))\n    return tuple(_digits), tuple(_alpha)\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.patch_schema_rules","title":"<code>patch_schema_rules(schema, *, remove_rules=False)</code>","text":"<p>Patch an exported Schema doc by re-linking attribute rules to table names</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Path | str</code> <p>The input schema to patch</p> required <code>remove_rules</code> <code>bool</code> <p>Remove attribute rules from the schema (default: False)</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SchemaWorkspace</code> <code>SchemaWorkspace</code> <p>A patched schema dictionary</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def patch_schema_rules(schema: SchemaWorkspace|Path|str, \n                       *,\n                       remove_rules: bool=False) -&gt; SchemaWorkspace:\n    \"\"\"Patch an exported Schema doc by re-linking attribute rules to table names\n\n    Args:\n        schema (Path|str): The input schema to patch\n        remove_rules (bool): Remove attribute rules from the schema (default: False)\n\n    Returns:\n        SchemaWorkspace: A patched schema dictionary\n    \"\"\"\n    # Load schema\n    if isinstance(schema, dict):\n        workspace = schema\n    else:\n        schema = Path(schema)\n        if not schema.suffix == '.json':\n            raise ValueError(f'Schema Patching can only be done on json schemas!, got {schema.suffix}')\n        workspace: SchemaWorkspace = json.load(schema.open(encoding='utf-8'))\n\n    # Get all root Features\n    features = [\n        ds \n        for ds in workspace['datasets'] \n        if 'datasets' not in ds\n    ]\n    # Get all features that live in a FeatureDataset\n    # Use listcomp since typing is weird\n    [\n        features.extend(ds['datasets']) \n        for ds in workspace['datasets'] \n        if 'datasets' in ds\n    ]\n    # Get a translation dictionary of catalogID -&gt; name\n    guid_to_name = {\n        fc['catalogID']: fc['name'] \n        for fc in features \n        if 'catalogID' in fc\n    }\n    for feature in filter(lambda fc: 'attributeRules' in fc, features):\n        feature: SchemaDataset\n        if remove_rules:\n            feature['attributeRules'] = []\n            continue\n        rules = feature['attributeRules']\n        for rule in rules:\n            script = rule['scriptExpression']\n            for guid, name in guid_to_name.items():\n                script = script.replace(guid, name)\n            rule['scriptExpression'] = script\n    return workspace\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.print","title":"<code>print(*values, sep=' ', end='\\n', file=None, flush=False, severity=None)</code>","text":"<p>Print a message to the ArcGIS Pro message queue and stdout set severity to 'WARNING' or 'ERROR' to print to the ArcGIS Pro message queue with the appropriate severity</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def print(*values: object,\n          sep: str = \" \",\n          end: str = \"\\n\",\n          file: Any = None,\n          flush: bool = False,\n          severity: Literal['INFO', 'WARNING', 'ERROR']|None = None) -&gt; None:\n    \"\"\" Print a message to the ArcGIS Pro message queue and stdout\n    set severity to 'WARNING' or 'ERROR' to print to the ArcGIS Pro message queue with the appropriate severity\n    \"\"\"\n\n    # Print the message to stdout\n    builtins.print(*values, sep=sep, end=end, file=file, flush=flush)\n\n    end = \"\" if end == '\\n' else end\n    message = f\"{sep.join(map(str, values))}{end}\"\n    # Print the message to the ArcGIS Pro message queue with the appropriate severity\n    match severity:\n        case \"WARNING\":\n            AddWarning(f\"{message}\")\n        case \"ERROR\":\n            AddError(f\"{message}\")\n        case _:\n            AddMessage(f\"{message}\")\n    return\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.shortest_path","title":"<code>shortest_path(source, target, network, *, all_paths=False, method='dijkstra', weighted=True, precision=6)</code>","text":"<pre><code>shortest_path(\n    source: PointLike,\n    target: PointLike,\n    network: LineCollection,\n    *,\n    all_paths: Literal[False] = False,\n    method: Literal[\n        \"dijkstra\", \"bellman-ford\"\n    ] = \"dijkstra\",\n    weighted: bool = True,\n    precision: int = 6,\n) -&gt; Polyline | None\n</code></pre><pre><code>shortest_path(\n    source: PointLike,\n    target: PointLike,\n    network: LineCollection,\n    *,\n    all_paths: Literal[True] = True,\n    method: Literal[\n        \"dijkstra\", \"bellman-ford\"\n    ] = \"dijkstra\",\n    weighted: bool = True,\n    precision: int = 6,\n) -&gt; list[Polyline] | None\n</code></pre> <p>Find the shortest path or paths given a source point, target point and network of Polylines</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>PointGeometry | Point</code> <p>The start point for the path</p> required <code>target</code> <code>PointGeometry | Point</code> <p>The end point for the path</p> required <code>network</code> <code>FeatureClass[Polyline, Any] | Sequence[Polyline] | Iterator[Polyline]</code> <p>The polylines to traverse</p> required <code>all_paths</code> <code>bool</code> <p>If True, yield all shortest paths from (default: False)</p> <code>False</code> <code>method</code> <code>Literal['dijkstra', 'bellman-ford']</code> <p>The graph traversal algorithm to use (default: 'dijkstra')</p> <code>'dijkstra'</code> <code>weighted</code> <code>bool</code> <p>Use line lengths to weight the paths (default: True)</p> <code>True</code> <code>precision</code> <code>int</code> <p>Number of decimal places to round coordinates to (default: 6)</p> <code>6</code> <p>Returns:</p> Type Description <code>Polyline | None</code> <p>The unioned polyline of the path or None if no path is found</p> <p>Yields:</p> Type Description <code>Polyline</code> <p>Yields all shortest paths if <code>all_paths</code> is set (None is still returned if no path found)</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When input arguments are not of the correct types (<code>PointLike</code>, <code>PointLike</code>, <code>LineCollection</code>)</p> Example <pre><code>path = shortest_path(p1, p2, line_features)\npaths = shortest_path(p1, p2, line_features, all_paths=True)\n\nif path is None:\n    print('No Path')\nelse:\n    print(path.length)\n\n# Check that path(s) were found\nif paths is None:\n    print('No Path')\nelse:\n    for p in paths:\n        print(p.length)\n</code></pre> Source code in <code>src/arcpie/utils.py</code> <pre><code>def shortest_path(\n    source: PointLike, \n    target: PointLike, \n    network: LineCollection,\n    *,\n    all_paths: bool=False,\n    method: Literal['dijkstra', 'bellman-ford']='dijkstra',\n    weighted: bool=True,\n    precision: int=6,\n    ) -&gt; Polyline | list[Polyline] | None:\n    \"\"\"Find the shortest path or paths given a source point, target point and network of Polylines\n\n    Args:\n        source (PointGeometry | Point): The start point for the path\n        target (PointGeometry | Point): The end point for the path\n        network (FeatureClass[Polyline, Any] | Sequence[Polyline] | Iterator[Polyline]): The polylines to traverse\n        all_paths (bool): If True, yield all shortest paths from (default: False)\n        method (Literal['dijkstra', 'bellman-ford']): The graph traversal algorithm to use (default: 'dijkstra')\n        weighted (bool): Use line lengths to weight the paths (default: True)\n        precision (int): Number of decimal places to round coordinates to (default: 6)\n\n    Returns:\n        (Polyline | None): The unioned polyline of the path or None if no path is found\n\n    Yields:\n        (Polyline): Yields all shortest paths if `all_paths` is set (None is still *returned* if no path found)\n\n    Raises:\n        (ValueError): When input arguments are not of the correct types (`PointLike`, `PointLike`, `LineCollection`)\n\n    Example:\n        ```python\n        path = shortest_path(p1, p2, line_features)\n        paths = shortest_path(p1, p2, line_features, all_paths=True)\n\n        if path is None:\n            print('No Path')\n        else:\n            print(path.length)\n\n        # Check that path(s) were found\n        if paths is None:\n            print('No Path')\n        else:\n            for p in paths:\n                print(p.length)\n        ```   \n    \"\"\"\n\n    # Parameter Validations\n    if isinstance(network, FeatureClass):\n        if network.describe.shapeType != 'Polyline':\n            raise ValueError(f'network must have polyline geometry')\n        network = list(network.shapes)\n\n    if not isinstance(network, Sequence):\n        network = list(network)\n\n    if not network:\n        return None\n\n    if not isinstance(network[0], Polyline): # type: ignore\n        raise ValueError(f'network must have polyline geometry')\n\n    # Project point geometries to match reference of network, extract X,Y tuples\n    if isinstance(source, PointGeometry):\n        if source.isMultipart:\n            raise ValueError('source point must not be multipart')\n        source = source.projectAs(network[0].spatialReference).centroid\n    _source = (round(source.X, precision), round(source.Y, precision))\n\n    if isinstance(target, PointGeometry):\n        if target.isMultipart:\n            raise ValueError('target point must not be multipart')\n        target = target.projectAs(network[0].spatialReference).centroid\n    _target = (round(target.X, precision), round(target.Y, precision))\n\n    G = Graph(\n        [\n            (\n                (round(l.firstPoint.X, precision), round(l.firstPoint.Y, precision)), \n                (round(l.lastPoint.X, precision), round(l.lastPoint.Y, precision)), \n                {'shape': l, 'length': l.length}\n            ) \n            for l in network\n        ]\n    )\n    try:\n        if all_paths:\n            paths = nx_all_shortest_paths(G, _source, _target, weight='length' if weighted else None, method=method)\n        else:\n            paths = nx_shortest_path(G, _source, _target, weight='length' if weighted else None, method=method)\n    except (NodeNotFound, NetworkXNoPath):\n        return None\n\n    if all_paths:\n        _paths: list[Polyline] = []\n        for path in paths:\n            assert isinstance(path, list)\n            edges: list[Polyline] = [G.get_edge_data(u, v)['shape'] for u, v in zip(path, path[1:])]\n            _paths.append(reduce(lambda acc, s: acc.union(s), edges))  # pyright: ignore[reportArgumentType]\n        return _paths\n\n    else:\n        assert isinstance(paths, list)\n        edges: list[Polyline] = [G.get_edge_data(u, v)['shape'] for u, v in zip(paths, paths[1:])]\n        if edges:\n            return reduce(lambda acc, s: acc.union(s), edges) # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.split_at_points","title":"<code>split_at_points(lines, points, *, buffer=0.0, min_len=0.0)</code>","text":"<p>Split lines at provided points</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>FeatureClass[Polyline]</code> <p>Line features to split</p> required <code>points</code> <code>FeatureClass[PointGeometry]</code> <p>Points to split on</p> required <code>buffer</code> <code>float</code> <p>Split buffer in feature units (default: 0.0 [exact])</p> <code>0.0</code> <code>min_len</code> <code>float</code> <p>Minumum length for a new line in feature units (default: 0.0)</p> <code>0.0</code> <p>Yields:</p> Type Description <code> tuple[int, Polyline]] </code> <p>Tuples of parent OID and child shape</p> Warning <p>When splitting features in differing projections, the point features will be projected into the spatial reference of the line features.</p> Example <pre><code>&gt;&gt;&gt; # Simple process for splitting lines in place\n... \n&gt;&gt;&gt; # Initialize a set to capture the removed ids\n&gt;&gt;&gt; removed: set[int] = set()\n&gt;&gt;&gt; with lines.editor:\n...     # Insert new lines\n...     with lines.insert_cursor('SHAPE@') as cur:\n...         for parent, new_line in split_at_points(lines, points):\n...             cur.insertRow([new_line])\n...             removed.add(parent) # Add parent ID to removed\n...     # Remove old lines (if you're inserting to the same featureclass)\n...     with lines.update_cursor('OID@') as cur:\n...         for _ in filter(lambda r: r[0] in removed, cur):\n...             cur.deleteRow() \n</code></pre> Source code in <code>src/arcpie/utils.py</code> <pre><code>def split_at_points(lines: FeatureClass[Polyline, Any], points: FeatureClass[PointGeometry, Any], \n                *, \n                buffer: float=0.0,\n                min_len: float=0.0) -&gt; Iterator[tuple[int, Polyline]]:\n    \"\"\"Split lines at provided points\n\n    Args:\n        lines (FeatureClass[Polyline]): Line features to split\n        points (FeatureClass[PointGeometry]): Points to split on\n        buffer (float): Split buffer in feature units (default: 0.0 [exact])\n        min_len (float): Minumum length for a new line in feature units (default: 0.0)\n\n    Yields:\n        ( tuple[int, Polyline]] ): Tuples of parent OID and child shape\n\n    Warning:\n        When splitting features in differing projections, the point features will be projected\n        into the spatial reference of the line features.\n\n    Example:\n        ```python\n        &gt;&gt;&gt; # Simple process for splitting lines in place\n        ... \n        &gt;&gt;&gt; # Initialize a set to capture the removed ids\n        &gt;&gt;&gt; removed: set[int] = set()\n        &gt;&gt;&gt; with lines.editor:\n        ...     # Insert new lines\n        ...     with lines.insert_cursor('SHAPE@') as cur:\n        ...         for parent, new_line in split_at_points(lines, points):\n        ...             cur.insertRow([new_line])\n        ...             removed.add(parent) # Add parent ID to removed\n        ...     # Remove old lines (if you're inserting to the same featureclass)\n        ...     with lines.update_cursor('OID@') as cur:\n        ...         for _ in filter(lambda r: r[0] in removed, cur):\n        ...             cur.deleteRow() \n        ```\n    \"\"\"\n    line_iter: Iterator[tuple[Polyline, int]] = lines[('SHAPE@', 'OID@')]\n    for line, oid in line_iter:\n        int_points: list[PointGeometry] = []\n        with points.reference_as(line.spatialReference), points.fields_as('SHAPE@'):\n            int_points = [r['SHAPE@'] for r in points[line.buffer(buffer)]]\n\n        if len(int_points) == 0 or all(p.touches(line) for p in int_points):\n            continue\n\n        prev_measure = 0.0\n        measures = sorted(line.measureOnLine(p) for p in int_points) + [line.length]\n        for measure in measures:\n            seg = line.segmentAlongLine(prev_measure, measure)\n            prev_measure = measure\n            if seg and seg.length &gt;= (min_len or 0):\n                yield oid, seg\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.split_lines_at_points","title":"<code>split_lines_at_points(lines, points)</code>","text":"<p>Split a Polyline or Sequence/Iterable of polylines at provided points</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>Polyline | Sequence[Polyline] | Iterator[Polyline]</code> <p>The line or lines to split</p> required <code>points</code> <code>Sequence[PointGeometry] | Iterator[PointGeometry]</code> <p>The points to split at</p> required <p>Yields:</p> Type Description <code>Polyline</code> <p>Segments of the polyline split at the input points</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def split_lines_at_points(lines: Polyline | Sequence[Polyline] | Iterator[Polyline], points: Sequence[PointGeometry] | Iterator[PointGeometry]) -&gt; Iterator[Polyline]:\n    \"\"\"Split a Polyline or Sequence/Iterable of polylines at provided points\n\n    Args:\n        lines (Polyline | Sequence[Polyline] | Iterator[Polyline]): The line or lines to split\n        points (Sequence[PointGeometry] | Iterator[PointGeometry]): The points to split at\n\n    Yields:\n        (Polyline): Segments of the polyline split at the input points\n    \"\"\"\n    if isinstance(lines, Polyline):\n        lines = [lines]\n    if not isinstance(points, list):\n        points = list(points)\n\n    for line in lines:\n        int_points = [p for p in points if not p.disjoint(line)]\n        if not int_points:\n            yield line\n            continue\n        if all(p.touches(line) for p in int_points):\n            yield line\n            continue\n        prev_measure = 0.0\n        measures = sorted(line.measureOnLine(p) for p in int_points)\n        for measure in measures + [line.length]:\n            if prev_measure == measure:\n                continue\n            yield line.segmentAlongLine(prev_measure, measure)\n            prev_measure = measure\n</code></pre>"},{"location":"modules/utils/#arcpie.utils.two_point_circle","title":"<code>two_point_circle(center, end, ref=None)</code>","text":"<p>Create a circle using a center point and an end point</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Point | PointGeometry</code> <p>The center of the circle</p> required <code>end</code> <code>Point | PointGeometry</code> <p>(Point|PointGeometry): The end point of the arc (distance from center is Circle radius)</p> required <code>ref</code> <code>SpatialReference | None</code> <p>(SpatialReference|None): The SpatialReference to use with the returned geometry</p> <code>None</code> <p>Returns:</p> Type Description <code>Polyline</code> <p>A Circular Polyline</p> Note <p>If PointGeometries are provided, they will be projected as the provided ref If no ref is provided, the shape will inherit the reference of the center</p> <p>Reference resolution is as follows: <code>ref -&gt; center.spatialReference -&gt; end.spatialReference</code></p> <p>If both points are Point objects with no spatial reference, and no ref is provided,  The returned Polyline will have no spatial reference</p> Source code in <code>src/arcpie/utils.py</code> <pre><code>def two_point_circle(center: Point|PointGeometry, end: Point|PointGeometry, ref: SpatialReference|None=None) -&gt; Polyline:\n    \"\"\"Create a circle using a center point and an end point\n\n    Args:\n        center (Point|PointGeometry): The center of the circle\n        end: (Point|PointGeometry): The end point of the arc (distance from center is Circle radius)\n        ref: (SpatialReference|None): The SpatialReference to use with the returned geometry\n\n    Returns:\n        (Polyline): A Circular Polyline\n\n    Note:\n        If PointGeometries are provided, they will be projected as the provided ref\n        If no ref is provided, the shape will inherit the reference of the center\n\n        Reference resolution is as follows:\n        `ref -&gt; center.spatialReference -&gt; end.spatialReference`\n\n        If both points are Point objects with no spatial reference, and no ref is provided, \n        The returned Polyline will have no spatial reference\n    \"\"\"\n    if isinstance(center, PointGeometry):\n        _c_ref = center.spatialReference\n        if ref and _c_ref != ref:\n            center = center.projectAs(ref)\n        else:\n            ref = ref or _c_ref\n        center = center.centroid\n    if isinstance(end, PointGeometry):\n        _e_ref = end.spatialReference\n        if ref and _e_ref != ref:\n            end = end.projectAs(ref)\n        else:\n            ref = ref or _e_ref\n        end = end.centroid\n\n    esri_json: dict[str, Any] = {}\n    _arc: dict[str, Any] = {'a': [[end.X, end.Y, end.Z, end.M], [center.X, center.Y], 0, 1]}\n    esri_json['curvePaths'] = [[[end.X, end.Y, end.Z], _arc]]\n    if ref:\n        esri_json['spatialReference'] = {'wkid': ref.factoryCode, 'latestWkid': ref.factoryCode}\n    return AsShape(esri_json, esri_json=True) # type: ignore\n</code></pre>"}]}